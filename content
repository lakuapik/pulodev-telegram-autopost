{"data":[{"id":2867,"title":"Netlify sebagai Pemendek Tautan","url":"https://opakholis.dev/blog/shortener","body":"Menjadikan Netlify Redirects sebagai layanan URL Shortener pribadi","tags":"netlify, shortener","media":"tulisan","thumbnail":"https://opakholis.dev/static/images/shortener/banner.jpg","owner":"Opa Kholis Majid","draft":false,"original_published_at":"2021-10-08T00:00:00","created_at":"2021-08-10T17:14:44.442527","updated_at":"2021-08-10T17:14:44.442527","deleted_at":null,"source_id":null,"contributor":"opxop"},{"id":2865,"title":"Strategi Memajukan Pendidikan ala Pahamify ft Rousyan | Podcast Ngobrolin Startup","url":"https://www.youtube.com/watch?v=3imzALyj-RE","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-11T09:00:11","created_at":"2021-08-08T18:11:17.990627","updated_at":"2021-08-08T18:11:17.990627","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2871,"title":"Eps. 56 - Strategi Memajukan Pendidikan ala Pahamify","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--56---Strategi-Memajukan-Pendidikan-ala-Pahamify-e15k0h9","body":"Sebenernya apa yang masih belum pas dengan pendidikan kita? Gimana pahamify bisa berperan utk menyelesaikan masalah pendidikan yg njelimet ini? Yuk simak!\n\n--- \n\nSend in a voice message: https://anchor.fm/ngobrolinstartup/message\nSupport this podcast: https://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-08-11T09:00:00","created_at":"2021-08-11T12:15:26.63008","updated_at":"2021-08-11T12:15:26.63008","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2852,"title":"Membuat Backend Sistem Notifikasi Saweria dengan Server Sent Event (SSE) dan Google Cloud Pub/Sub","url":"https://www.youtube.com/watch?v=9RMS4Y0xXa4","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-11T07:11:39","created_at":"2021-08-03T00:37:24.452288","updated_at":"2021-08-03T00:37:24.452288","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2870,"title":"How Monika Saved Me from Unnoticed Server Errors","url":"https://medium.com/hyperjump-tech/how-monika-saved-me-from-unnoticed-server-errors-243e97f35edd?source=rss----fabfd42372dc---4","body":null,"tags":"software-engineering,devops,monitoring,software,javascript","media":"tulisan","thumbnail":null,"owner":"Denny Pradipta","draft":false,"original_published_at":"2021-08-10T03:37:30","created_at":"2021-08-11T12:15:22.819478","updated_at":"2021-08-11T12:15:22.819478","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2866,"title":"Pengantar Kalkulus Lambda","url":"https://www.evilfactorylabs.org/artileda/pengantar-kalkulus-lambda-90e","body":"Kalkulus Lambda adalah model komputasi yang berlandaskan prinsip fungsi M-chan (Matematika-chan), pertama kali di kemukakan oleh Alonzo Church pada awal 1930-an yang menjadi bagian penelitian beliau dalam pembuktian formal dasar matematika.\nModel komputasi merupakan kerangka kerja yang menjelaskan apa yang  dilakukan sebuah fungsi / algoritme dalam menghasilkan nilai keluaran dari sebuah nilai masukan.\nKetika kita menerima nilai masukan 4, Bagaimana kita menghasilkan 6 ?\nlet y = (x) => x + 2\n\ny(4)\n\natau juga\nlet y = (x) => x + (x/2)\n\ny(4)\n\nFenomena banyak cara untuk memenuhi syarat nilai masukan dan keluaran ini disebut dengan undecidability.\nBagaimana bentuknya dalam kalkulus lambda ?\nŒªx.(+ x 2) 4 = (+ 4 2) = 6\n\nPenulisan notasi dengan operator pada awal operasi disebut notasi prefiks. \nNotasi tersebut sama saja dengan\nŒªx.(x + 2) 4 = (4 + 2) = 6\n\nKalkulus lambda salah satu model komputasi fungsional, fungsional berarti komputasi disusun oleh set dan fungsi matematika.\nKalkulus Lambda memiliki 3 ekspresi:\nE := x \n  | E1.E2\n  | Œªx.E1\n\nx , Variable\nE1.E2 , Aplikasi Fungsi\nŒªx.E1 , Abstraksi Fungsi\nRupa kode dalam bentuk tipe data.\ntype rec e = \n  | Variabel(int)\n  | Aplikasi(e,e) \n  | Abstraksi(int,e)\n\nVariable adalah nilai bilangan, seperti 1,2,3 dan seterusnya.\nAbstraksi fungsi adalah cara kita membuat suatu fungsi.\nŒª(parameter).(badan fungsi)\n\nŒªx.E1\n\nŒªx, notasi melambangkan bagaimana kita membuat sebuah fungsi dengan parameter x.\n\n\nE1, eksprsi dari kalkulus lambda\n\n\n\nContoh\nŒªx. (+ (* x 2) x)\n\nŒªy. (- y 2)\n\nDalam bentuk kode\nlet f1 = (x) => (x * 2) + x\n\nlet f2 = (y) => y - 2\n\nAplikasi fungsi bagaimana kita menggunakan fungsi terhadap sesuatu nilai masuka atau ekspresi.\nŒªx. (+ (* x 2) x) 4 \n= (+ (* 4 2) 4)\n= ( + 8 4 )\n= 12\n\nFungsi Œªx. (+ (* x 2) x) diberikan masukan 4.\n\n\nParameter x dan variabel x pada badan fungsi di ganti dengan 4 dan Œªx dihapus karena x sudah terganti, sehingga menghasilkan (+ (* 4 2) 4).\n\n\nKita operasikan dari kurung terdalam yaitu (* 4 2) menjadi ( + 8 4 ) dan dilanjutkan sehingga menghasilkan 12.\n\n\n\nRupa dalam bentuk kode\nlet f = (x) => (x * 2) + x\n\nf(4) // 12\n\nŒªa.(* a a) . Œªx.(+ x 3) . 4\n\nKita punya sebuah fungsi berparameter a dengan isi (* a a) dan diaplikasikan dengan (+ x 3) dan 4 ?\nŒªa. (* a a) (+ x 3) 4\n= (* (Œªx.(+ x 3)) (Œªx.(+ x 3)) 4\n= (* (+ 4 3) (+ 4 3))\n= (* 12 12)\n= 144\n\nBila ditulis dalam bentuk kode\nlet fa = (a) => (a * a)\n\nlet fx = (x) => x + 3\n\nfa(fx(4)) // 144\n\nSekian dari tulisan ini semoga cukup memanaskan kepala and. Apabila penjelasan saya kurang dapat di mengerti, semoga video dibawah ini bisa membantu\n#1 Pengantar | Kalkulus Lambda, Idiosemantik\nTerima kasih.","tags":"teorikomputasi,rescript","media":"tulisan","thumbnail":null,"owner":"‚ñ≤Engelstrassen","draft":false,"original_published_at":"2021-08-08T18:09:50","created_at":"2021-08-08T18:11:45.275497","updated_at":"2021-08-08T18:11:45.275497","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2863,"title":"Pengenalan Program Komputer","url":"https://gadiskoding.my.id/pengenalan-program-komputer.html","body":"Apa sih itu program dan berbagai seluk beluk lainya.","tags":"pemrograman dasar","media":"tulisan","thumbnail":"/images/og.png","owner":"Gadis Koding","draft":false,"original_published_at":"2021-08-08T12:09:12.761","created_at":"2021-08-08T12:09:33.276989","updated_at":"2021-08-08T12:09:33.276989","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2862,"title":"Belajar Test Driven Development","url":"https://anchor.fm/deep-tech/episodes/Belajar-Test-Driven-Development-e15k33f","body":"Dalam proses pengembangan software, seringkali requirements selalu berubah mengikuti kebutuhan. Hal ini menyebabkan timbulnya beberapa masalah teknis seperti bugs. Bahkan menyangkut psikologis, misalnya developer jadi nggak percaya diri untuk mengembangkan fitur karena takut aplikasi akan break.\nMakanya, developer membutuhkan automated test untuk mengecek baris kode. Namun ada cara terbaik dalam penerapan automated test ini yaitu dengan Test Driven Developmet atau biasa disingkat TDD. Yuk belajar lebih dalam mengenai TDD bersama Resi Respati, Senior Front End di Kata dot ai.","tags":"","media":"podcast","thumbnail":null,"owner":"deep tech foundation","draft":false,"original_published_at":"2021-08-08T04:54:12","created_at":"2021-08-08T06:11:31.015908","updated_at":"2021-08-08T06:11:31.015908","deleted_at":null,"source_id":4,"contributor":"hilmanski"},{"id":2861,"title":"üöÄ Coming soon: BlobCDN","url":"https://upset.dev/blobcdn","body":"The CDN for beautiful SVG shapes. Dapatkan early access!","tags":"cdn, svg, blob, design","media":"web","thumbnail":"https://ph-files.imgix.net/70013e6c-c741-484f-9ffb-81be950bd278.png?auto=format","owner":"@fransallen","draft":false,"original_published_at":"2021-08-07T22:58:55.804","created_at":"2021-08-07T23:02:30.855274","updated_at":"2021-08-07T23:02:30.855274","deleted_at":null,"source_id":null,"contributor":"@fransallen"},{"id":2859,"title":"GitHub - artileda/pemrograman-fungsional: Repo berisi sumber dan referensi belajar pemrograman fungsional","url":"https://github.com/artileda/pemrograman-fungsional","body":"Repo berisi sumber dan referensi belajar pemrograman fungsional - GitHub - artileda/pemrograman-fungsional: Repo berisi sumber dan referensi belajar pemrograman fungsional","tags":"pemrograman fungsional","media":"web","thumbnail":"https://opengraph.githubassets.com/244780da8de2db5d675f2932ee5432132a1994f3b47cba4c11af885eefdc38f7/artileda/pemrograman-fungsional","owner":"@artileda","draft":false,"original_published_at":"2021-08-07T18:02:07.714","created_at":"2021-08-07T18:02:49.130657","updated_at":"2021-08-07T18:02:49.130657","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2860,"title":"Strategi Memajukan Pendidikan ala Pahamify ft. Rousyan, CEO Pahamify | Teaser Ngobrolin Startup","url":"https://www.youtube.com/watch?v=H8x0Z4uCTnY","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-07T16:49:30","created_at":"2021-08-07T18:11:04.439352","updated_at":"2021-08-07T18:11:04.439352","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2864,"title":"#1 Pengantar | Kalkulus Lambda","url":"https://www.youtube.com/watch?v=BinlkRGwf_I","body":"Halo kawan-kawan.Video kali ini saya membahas tentang apa itu kalkulus lambda dan pengoperasinya dengan aritmatika sederhana.Model komputasi merupakan gambar...","tags":"teori komputasi,bahasa pemrograman","media":"video","thumbnail":"https://i.ytimg.com/vi/BinlkRGwf_I/maxresdefault.jpg","owner":"Idiosemantik","draft":false,"original_published_at":"2021-08-07T00:00:00","created_at":"2021-08-08T12:11:07.279905","updated_at":"2021-08-08T12:11:07.279905","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2857,"title":"üòé Awesome Indonesia","url":"https://github.com/fransallen/awesome.id","body":"Daftar produk, proyek, acara dan sumber daya lainnya yang dibuat oleh developer dan founder dari Indonesia.","tags":"awesome, open source, indonesia, saas, product","media":"web","thumbnail":"https://opengraph.githubassets.com/5ae19ae4e35f05cda7234520c88f0b6c0b2b2b4b4ea0f71a4c1ee856b3953498/fransallen/awesome.id","owner":"@fransallen","draft":false,"original_published_at":"2021-08-06T07:45:37.523","created_at":"2021-08-06T07:49:07.486213","updated_at":"2021-08-06T07:49:07.486213","deleted_at":null,"source_id":null,"contributor":"@fransallen"},{"id":2856,"title":"Cara Membuat JSON Web Tokens tidak Valid","url":"https://hellodit.medium.com/cara-membuat-json-web-tokens-tidak-valid-4e25615826e?source=rss-bec8db944a8e------2","body":null,"tags":"json-web-token,rest-api,jwt,programming","media":"tulisan","thumbnail":null,"owner":"Asdita Prasetya","draft":false,"original_published_at":"2021-08-04T03:29:13","created_at":"2021-08-04T06:12:47.128271","updated_at":"2021-08-04T06:12:47.128271","deleted_at":null,"source_id":51,"contributor":"hellodit"},{"id":2855,"title":"Berkenalan dengan OpenAPI 2.0/Swagger","url":"https://gadiskoding.my.id/berkenalan-dengan-openapi-2-0-swagger.html","body":"Membuat dokumentasi api sekaligus membangkitkanya.","tags":"restapi,openapi,web","media":"web","thumbnail":"/images/og.png","owner":"Gadis Koding","draft":false,"original_published_at":"2021-08-03T13:59:14.735","created_at":"2021-08-03T13:59:57.456211","updated_at":"2021-08-03T13:59:57.456211","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2854,"title":"Jatuh Bangun Menjalani Bisnis Software Consulting Firm","url":"https://www.youtube.com/watch?v=1L7_rf-at0g","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-03T12:00:02","created_at":"2021-08-03T12:15:28.329283","updated_at":"2021-08-03T12:15:28.329283","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2853,"title":"Eps. 55 - Jatuh Bangun Membangun Software Consulting Firm ","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--55---Jatuh-Bangun-Membangun-Software-Consulting-Firm-e15a194","body":"Gw banyak dapet ilmu dari obrolan bareng Sidiq & Taufan, co-founder Nusantara Beta Studio, tentang apa yang pelajaran mereka ketika ngebangung bisnis software consulting. Simak aja!\nhttps://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-08-03T01:00:00","created_at":"2021-08-03T06:12:13.725109","updated_at":"2021-08-03T06:12:13.725109","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2851,"title":"Thread twitter pelajaran dari proyek bersama WargaBantuWarga ","url":"https://twitter.com/deeptech_id/status/1422162040089575425","body":"","tags":"opensource","media":"tulisan","thumbnail":"","owner":"Twitter Deep Tech","draft":false,"original_published_at":"2021-08-02T23:43:28.697","created_at":"2021-08-02T23:44:48.698456","updated_at":"2021-08-02T23:44:48.698456","deleted_at":null,"source_id":null,"contributor":"hilmanski"},{"id":2850,"title":"Bermain - main dengan awk, tail, dan head","url":"https://www.evilfactorylabs.org/adiatma/bermain-main-dengan-awk-tail-dan-head-3l6n","body":"Oke jadi kali ini gw mau share dikit soal, awk, tail dan head di bash, dan yang paling penting awk sih, karena awk mendukung operasi logic, beda dengan tail, dan head yang hanya sekedar filter biasa doankkkkkkhhh.\nBiasanya enaknya ngabahas sesuatu itu diiringi dengan contoh, biar gak bosan dan tau implementasinya kayak gimana.\nSetelah beberapa menit mikir sambil seruput kopi hangat, rasanya cocok untuk bahas soal nge cetak local ip di antarmuka terminal tercintaahh kalian, dengan menggunakan ifconfig di mac os, dan ip di linux.\nOke contoh yang pertama.\n$ ifconfig\n\nOutputnya kayak dibawah ini nih\n\nNah kesel banget kan liat outputnya yang sebanyak itu.\nOke sekarang biar gak kesel kita akan kombinasikan perintah ifconfig dengan kawan - kawan filternya.\n\nNah sekarang gimana udah lumayan kan?, oke kita lanjut lagi buat nge filter biar terlihat lebih oke dan maknyus.\n\nNah, sekarang udah keren, nah selanjutnya jika butuh untuk nge filter baris kalian butuh tail atau head. karna gw mau tampilin local ip yang paling bawah maka gw pake tail, contohnya kayak gini.\nifconfig | grep inet | awk '{print $2}' | awk '$0 ~ /^[1-9]/{print $0}' | tail -n 1\n\nHasilnya kayak gini.\n172.16.10.4\n\nNah sekarang udah oke, selanjutnya kita akan coba dengan perintah ip di mesin linux. \nOke bentar gw coba untuk ssh dulu ke mesin raspberry gw.\n\nYup, udah berhasil masuk, sekarang coba lagi buat masukin perintah ip a.\n\nOops... gimana kesel kan?\nOke sekarang kita filter lagi, kita coba untuk pakai grep dulu buat nge filter text dengan tulisan global, contohnya kayak gini.\n\nOh iya, yang karakter ini | artinya pipe, artinya akan di proses dari kiri ke kanan, jadinya kiri dulu baru ke kanan, yang ip a dulu hasilnya keluar baru lanjut ke perintah selanjutnya.\nOke kita lanjut lagi ya filternya, selanjutnya adalah bermain dengan awk lagi nih, buat ngambil kolom ke dua, di awk bisa pakai kayak gini awk '{print $2}' nah yang symbol dollar dua itu artinya kolom ke dua.\n\nNah, jadinya kayak gini, gimana mudah kan? \nSelanjutnya cukup pakai head atau tail aja, karena tadi udah pake tail skarang kita pakai head buat ngambil list ip di awal, dannnnn....\n\ntaraaaaa...., mantap!","tags":"bash,jaringan,scripting,cli","media":"tulisan","thumbnail":null,"owner":"Adiatma Kamarudin","draft":false,"original_published_at":"2021-08-02T14:08:08","created_at":"2021-08-02T18:11:47.098321","updated_at":"2021-08-02T18:11:47.098321","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2849,"title":"Reverse Bitwise - Gemastik14 CTF","url":"https://www.evilfactorylabs.org/recursive/reverse-bitwise-gemastik14-ctf-3625","body":"Kemarin pas pemanasan gemastik14 kebagian soal reverse engineering, langsung aja bedah\nSoal :\nimport java.util.*;\n\npublic class KodeBit {\n  public static void main(String[] args) {\n    System.out.print(\"Enter Password: \");\n    Scanner s = new Scanner(System.in);\n    String user_key = s.next();\n    if (user_key.length() != 16) {\n      System.out.println(\"Wrong\");\n      return;\n    }\n\n    char[] verify_arr = {131,195,194,67,1,225,66,2,73,233,0,35,33,9,193,192};\n\n    ArrayList<Character> user_arr = new ArrayList<Character>();\n    char[] user_submitted_arr = user_key.toCharArray();\n\n    for (char ch : user_submitted_arr) {\n      user_arr.add((char)((((ch << 5) | (ch >> 3)) ^ 111) & 255));\n    }\n\n    int i;\n    for(i = 0; i < 16; i++) {\n      if (!user_arr.get(i).equals((char)verify_arr[i])) {\n        System.out.println(\"Wrong\");\n        return;\n      }\n    }\n    System.out.println(\"Success\");\n  }\n}\n\nthe key is here :\n for (char ch : user_submitted_arr) {\n      user_arr.add((char)((((ch << 5) | (ch >> 3)) ^ 111) & 255));\n    }\n\nBuat solving pake python :\nverify_arr = [131,195,194,67,1,225,66,2,73,233,0,35,33,9,193,192]\nkey = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\nfor i in range(16):\n    for k in range(128):\n        if verify_arr[i] == (((k << 5) | (k >> 3)) ^ 111) & 255:\n            key[i] = chr(k)\n\nflag = ''\nfor i in key:\n    flag += i\n\nprint(flag)\n\n\n\n\n\n\n\n  \n  \n  Flag : gemastik14{br3u}","tags":"ctf,reverseengineering","media":"tulisan","thumbnail":null,"owner":"Purgatorio","draft":false,"original_published_at":"2021-08-01T03:28:30","created_at":"2021-08-01T06:12:35.007347","updated_at":"2021-08-01T06:12:35.007347","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2848,"title":"Mengenal dan mengapa menggunakan Function as a Service (FaaS)","url":"https://www.evilfactorylabs.org/faultable/mengenal-dan-mengapa-menggunakan-function-as-a-service-faas-1c4c","body":"Ini adalah bagian dari topik cloud, jika kamu belum terlalu familiar dengan konsep komputasi awan, mungkin bisa mempertimbangkan untuk membaca tulisan berjudul Mengenal \"Cloud\" untuk Software Developer terlebih dahulu.\nDewasa ini (anjay dewasa) proses deployment sebuah layanan ataupun aplikasi sudah semakin beragam khususnya untuk platform web yang melakukan komputasi dibagian server. Dari yang sebelumnya mungkin mendistribusikannya sebagai CGI script, dilanjutkan dengan sebuah berkas be-ekstensi php, lalu sampai ke sebuah berkas arsip yang biasa disebut dengan docker image yang sekarang umum digunakan.\nApapun pendekatan yang dipilih, tujuan utamanya adalah satu: agar dapat memproses sesuatu, dibagian server. Entah untuk alasan keamanan, privasi, ataupun karena pengguna akhir tidak layak untuk melakukan proses tersebut.\nSalah satu keunggulan komputer yang disebut dengan server adalah umumnya dia berjalan secara terus menerus, mungkin sebagaimana arti secara harfiahnya. Beda dengan personal computer (PC) yang memang tugasnya untuk melakukan kegiatan-kegiatan pribadi seperti menonton film ataupun memainkan permainan.\nServer pada dasarnya adalah sebuah komputer, yang berarti memiliki perangkat keras (pastinya) dan perangkat lunak termasuk sistem operasi. Dan jika ingin membuat program untuk pengguna internet, pastinya ada sebuah program berjenis web server yang bertugas untuk melayani permintaan masuk dan keluar.\nTidak sampai situ, ada satu lapisan lagi yang harus dimiliki oleh server: runtime program. Jika kamu ingin menjalankan aplikasi/layanan yang ditulis menggunakan PHP, mungkin kamu membutuhkan php-fpm. Jika itu JavaScript, mungkin itu Node.js. Jika itu C, mungkin libc ataupun musl.\nApakah sudah cukup sampai situ? Tentu tidak. Kamu pasti butuh Reverse proxy karena seharusnya pekerjaan-pekerjaan seperti SSL termination, compression, caching, dsb bukanlah tanggung jawab aplikasi/layanan yang kamu kembangkan.\nSebagai rekap, untuk membuat sebuah program yang menampilkan Hello World menggunakan JavaScript (Node.js), setidaknya komputer (server) kamu harus memiliki komponen berikut:\nSistem operasi (e.g: Ubuntu)\nReverse proxy (e.g: Caddy)\nRuntime program (e.g: Node.js)\nTidak menutup kemungkinan kamu harus tau juga tentang supervisor sehingga program-program yang kamu butuhkan bisa berjalan kembali secara otomatis baik setelah reboot ataupun setelah crash.\nBaiklah, mari kita coba menggunakan pendekatan tradisional terlebih dahulu. Anggap gue menggunakan Ubuntu dan sudah memasang Caddy dan Node.js di server gue, ya.\nPertama kita buat program sederhananya dulu menggunakan JavaScript, berikut kodenya:\n// server.js\nconst http = require('http')\n\nconst server = http.createServer(({ headers, socket }, res) => {\n  const ip = headers['x-forwarded-for'] || socket['remoteAddress']\n\n  res.statusCode = 200\n  res.setHeader('Content-Type', 'text/plain')\n  res.end(`Hello ${ip}\\n`)\n})\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('server run at http://127.0.0.1:8080')\n})\n\nDengan menjalankan node server.js, program sederhana kita sudah bisa diakses melalui localhost:8080 yang mana setiap kali ada permintaan masuk ke path / dengan method GET (ataupun POST, DELETE, dsb) akan memberikan Hello {alamat ip} sebagai respon.\nKita ingin membuat program tersebut dapat diakses oleh pengguna internet, dan tidak lucu bila program kita tersebut diakses menggunakan kombinasi alamat ip + port secara langsung.\nDisini kita butuh Caddy sebagai Reverse Proxy. Dan sebagaimana reverse proxy pada umumnya, kita menggunakan SNI (think like virtual host) untuk melakukan service discovery atau menentukan upstream backend sederhananya.\n# Caddyfile\n\nfake.evilfactorylabs.org {\n  reverse_proxy * 127.0.0.1:8080\n}\n\nReverse proxy umumnya berjalan di port 80 (HTTP) dan 443 (HTTPS), setiap ada permintaan masuk ke fake.evilfactorylabs.org yang mana mengarah ke ip server tersebut, Caddy akan meneruskan permintaannya ke 127.0.0.1:8080 tempat dimana aplikasi tersebut bejalan.\nAktivitas diatas adalah effort minimum yang setidaknya harus dilakukan ketika mengembangkan aplikasi yang ditulis menggunakan JavaScript.\nJika melihat secara garis besar, berdasarkan contoh aplikasi diatas, satu hal yang benar-benar kita butuhkan hanyalah Node.js sebagai runtime. Harusnya kita tidak perlu peduli sistem operasi dan reverse proxy apa yang digunakan, khususnya jika aplikasi kita tidak berurusan dengan sistem operasi secara langsung (misal membuat tun device) ataupun ingin melakukan hal yang biasa dilakukan oleh reverse proxy (misal melakukan kompresi ke brotli).\nDan gue rasa, kebanyakan aplikasi web pun memiliki karakteristik yang sama.\nOke kita kembali ke konteks. Perlu diketahui bahwa tidak semua aplikasi cocok menggunakan pola FaaS, atau Serverless jika lebih familiar dengan sebutan tersebut.\nFaaS lebih cocok untuk melakukan hal-hal yang bersifat on-demand yang tidak perlu berjalan selamanya.\nMisal situs ini secara keseluruhan, meskipun secara teori bisa saja dibuat menggunakan pendekatan FaaS, namun tidak efektif, seperti, bayangkan harus menjalankan dan mematikan aplikasi yang dibuat menggunakan Ruby On Rails ini setiap kali ada permintaan masuk agar mungkin dapat menghemat biaya sekian rupiah perbulan.\nUntuk aplikasi Ruby fucking On Rails.\nMungkin bisa saja gue pisahkan si fungsi komentar yang ada di aplikasi ini, membuat function untuk mengatur event mengambil data komentar dan memproses komentar baru, lalu revalidate cache, tapi nanaonan (kalau kata orang Sunda mah).\nContoh sederhana yang cocok untuk menggunakan pendekatan FaaS adalah sistem notifikasi. Umumnya sistem notifikasi berjalan sebagai worker untuk memisahkannya dari thread utama agar aplikasi utama tidak memakan terlalu banyak memori. Karena ada pemisahan ini, umumnya juga ada komponen tambahan seperti queue system yang secara garis besar bertugas sebagai \"waiting room\" untuk si worker ini untuk mengatur setiap kali ada \"event\" masuk ataupun keluar.\nBayangkan ketika pengguna melakukan registrasi ke situs ini dan harus menunggu loading karena aplikasi ini sedang mengirim surel yang dituju ke SMTP server yang digunakan untuk mengirim surel verifikasi, yang entah berhasil ataupun gagal.\nNah itu jika 1 pengguna yang dalam waktu yang sama, ya.\nDengan menerapkan queue system, kita bisa melakukan misalnya hanya mengirim 10 email per-detik setiap ada event registrasi, misal untuk menghindari rate-limit dari SMTP server.\nKuncinya ada di event. Hal yang bisa dilakukan di worker, besar kemungkinan bisa dijadikan sebagai serverless function.\nDisini gue akan menggunakan contoh untuk Webhook dari layanan Saweria yang gue rasa cocok untuk contoh ini. \nSetiap kali ada saweran masuk, sistem Saweria akan mengirim permintaan POST beserta payloadnya ke sebuah endpoint yang sudah gue tentukan.\nDan setiap kali ada permintaan POST masuk di function gue, gue mengirim permintaan POST juga ke sebuah endpoint yang sudah sistem Discord tentukan.\nJadi disini ada 3 webhook:\nWebhook Saweria (bisa DM theo di Twitter HAHAHA)\nWebhook gue (via Cloudflare Workers)\nWebhook Discord (dokumentasi)\nGue gak tau kapan si Saweria ngirim POST ke gue, yang berarti layanan gue harus terus berjalan, kan? Gue bisa spin up VM (atau menggunakan VM yang sama) tapi gue gak mau berurusan dengan Node.js (dan OS) ataupun Docker hanya untuk menjalankan layanan ini.\nJadi gue menggunakan layanan Cloudflare Workers terlebih karena situs ini juga menggunakan layanan Cloudflare.\nKodenya relatif sederhana, misal jika tidak menggunakan KV storage nya Cloudflare seperti ini:\nconst DISCORD_WEBHOOK = 'https://discord.com/api/webhooks/xxx'\n\nasync function handlePost(request) {\n  try {\n    const requestPayload = await request.json()\n\n    const { donator_name, message, amount_raw } = requestPayload\n\n    const duit = new Intl.NumberFormat('id', {\n      style: 'currency',\n      currency: 'IDR'\n    })\n\n    const body = {\n      content: `**${donator_name}** baru saja menyawer **${duit.format(\n        amount_raw\n      )}** dengan pesan **_${message}_**`\n    }\n\n    const payload = {\n      body: JSON.stringify(body),\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      }\n    }\n\n    const response = await fetch(DISCORD_WEBHOOK, payload)\n\n    return new Response(JSON.stringify({ success: true }), payload)\n  } catch {\n    return new Response('<pre>noted</pre>', {\n      headers: {\n        'content-type': 'text/html'\n      }\n    })\n  }\n}\n\nasync function handleGet() {\n  return new Response('<pre>ok</pre>', {\n    headers: {\n      'content-type': 'text/html'\n    }\n  })\n}\n\naddEventListener('fetch', event => {\n  const { request } = event\n\n  if (request.method === 'POST') {\n    return event.respondWith(handlePost(request))\n  }\n\n  return event.respondWith(handleGet())\n})\n\nGue tidak membuat validasi lebih lanjut karena kalau ada error yang disebabkan oleh orang iseng pun gue rasa gue tidak rugi apa-apa, jadi, yaudalaya.\nAnyways, jika melihat kode diatas, kunci dari function ini adalah event fetch yang pada dasarnya POST request dari sistem Saweria adalah fetch request, kan?\nDan jika melihat di dashboard, function diatas rata-rata berjalan selama ~4ms dengan penggunaan CPU rata-rata 72.8 MB per-detiknya.\nThe nice thing is, gue tidak perlu ribet-ribet ngatur reverse proxy dan web server untuk si webhook ini, cukup fokus menulis kodenya aja sudah mendapat endpoint (HTTPS) yang siap untuk digunakan. \nMungkin buat yang lebih serius, si Cloudflare Workers ini nawarin event cron juga misal kalau somehow si workers ini gagal mengirim POST request ke Discord, dengan bantuan KV Storage, mungkin bisa melakukan re-request per-sekian waktu untuk membuat queue system ala ala.\nJika ingin mencoba, silahkan kunjungi saweria.co/evilfactorylabs dan lihat di channel #wall-of-love di server Discord evilfactorylabs.\n...nah bikin URL shortener ala ala juga cocok sih pakai serverless function ini\nPerlu diketahui bahwa model biaya dari FaaS biasanya adalah:\nexecution/CPU time\negress bandwidth\nx req/mo\nYang gue rasa harganya relatif affordable.\nPerlu diketahui juga untuk cloud provider yang menawarkan FaaS biasanya menggunakan proprietary runtime dan juga tidak (atau belum) memiliki/memenuhi standar. Yang maksudnya, di Cloudflare Workers menggunakan semantik add.eventListener dengan properti event blablabla, sedangkan, misalnya, di AWS Lambda menggunakan exports.handler =  async function(event, context) yang secara teknis mungkin melakukan hal yang sama namun menggunakan pendekatan yang berbeda.\nPR dari migrasi ke cloud sekali lagi adalah kepercayaan, yang jika mengambil contoh FaaS disini, kita harus mempercayakan cloud provider yang kita pilih terlebih karena kita tidak berurusan dengan sistem operasi; reverse proxy, dan web server yang ingin digunakan.\nSalah satu tujuan dari ekosistem cloud menurut gue adalah untuk semaksimal mungkin menghindari pengembang (dan operator) berurusan dengan server yang menurunkan penghalang untuk siapapun yang ingin membuat sesuatu di internet.\nSebagai penutup, kelemahan dari serverless function ini adalah di maksimum CPU time. Misal, bila kamu membuat sebuah layanan untuk mentransformasi webm ke mp4 yang mungkin memakan waktu 20s untuk video berdurasi 30 menit dan sedangkan maksimum execution time nya adalah 10s, besar kemungkinan proses tersebut akan gagal.\nLalu bagaimana solusi untuk masalah diatas? Akan kita bahas di tulisan selanjutnya!","tags":"cloud,serverless","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-07-31T07:50:45","created_at":"2021-07-31T12:15:14.36128","updated_at":"2021-07-31T12:15:14.36128","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2847,"title":"Mengenal \"Cloud\" untuk Software Developer","url":"https://www.evilfactorylabs.org/faultable/mengenal-cloud-untuk-software-developer-p5d","body":"Kata \"Cloud\" mungkin sudah tidak asing lagi di telinga pembaca sekalian, dan, ya, frasa \"There is no cloud, it just someone else computer\" pun secara konsep tidak 100% salah untuk menggambarkan tentang Cloud.\nTapi tidak sedikit yang belum memahami sepenuhnya apa itu cloud (atau yang biasa disebut sebagai cloud computing/komputasi awan) termasuk saya. Dan karena cloud ini adalah konsep yang relatif baru, biasanya saya menggunakan pendekatan \"pembalikkan\" untuk mencoba memahaminya, alias, bagaimana bila kita mulai dengan pertanyaan apa itu yang bukan cloud?\nUntuk menjalankan aplikasi/layanan yang dibuat untuk pengguna internet, ada 2 komponen utama yang harus kita miliki sebagai operator:\nKomputer alias Server (tentu saja)\nJaringan internet (tentu saja juga)\nKita mulai dari komputer. Kita harus memiliki komputer yang lumayan tangguh khususnya untuk bisa menangani skala pengguna internet yang relatif acak, beda dengan membuat program yang bukan untuk pengguna internet yang mana bergantung dengan komputer yang digunakan pengguna, bukan malah si operator, alias, it's not my problem.\nUntuk merakit komputer yang tangguh tentu memakan biaya yang tidak sedikit, kita harus benar-benar peduli dengan CPU (dan jumlah core) yang ada; media storage yang digunakan, jumlah RAM, NIC, dsb dsb.\nLalu ke jaringan internet. Tentu tidak mungkin berlangganan paket internet rumahan yang menggunakan alamat IP publik dinamis, komputer kita harus memiliki alamat IP publik statis sehingga pengguna internet lain dapat mengakses komputer kita mengingat komputer hanya berkomunikasi dengan komputer lain menggunakan alamat IP.\nMungkin kita bisa menyewa alamat IP dengan prefix /24 ataupun /23 ke internet registry di wilayah kita, mendaftarkan ASN, dan lalu peering dengan ISP yang ada yang menawarkan BGP. Tapi ini lumayan ribet serta banyak memakan biaya & waktu.\nAtau kita bisa menggunakan layanan Colocation alih-alih mengatur jaringan sendiri, namun tetap, kita harus bertanggung jawab salahsatunya misal ketika salah satu SSD kita... corrupt. Membangun infrastruktur kita sendiri untuk dapat membuat aplikasi/layanan untuk pengguna internet terlihat seperti mimpi buruk, dan lebih brengseknya lagi sangat mahal dan ribet.\nMungkin kita butuh sebuah solusi untuk lebih mempermudah siapapun membuat aplikasi/layanan untuk pengguna internet, dan dengan biaya yang lebih terjangkau.\nSekarang kita sudah masuk ke topik cloud. Inti dari cloud sederhananya ada dua:\nKomputer orang lain\nDiakses melalui jaringan internet\nJika kamu sudah menggunakan komputer orang lain yang dapat diakses melalui jaringan internet (dan bukan melalui jalur backdoor), then, cool, you are on the cloud!\nPenyedia IaaS sudah lumayan banyak, termasuk di Indonesia. Dengan IaaS, kamu tidak perlu pusing lagi mempertimbangkan hal-hal terkait perangkat keras, karena itu tanggung jawabnya si penyedia layanan (dan termasuk dipemeliharaannya juga!).\nHal yang kamu lakukan hanyalah memilih, dari:\nJumlah CPU core yang digunakan\nJumlah kapasitas penyimpanan yang dibutuhkan\nJumlah RAM yang diinginkan\nDan umumnya jenis layanan yang ditawarkan ada 3:\nBare metal (pikirkan seperti colocation, namun bukan menggunakan server kamu sendiri)\nDedicated (di beberapa tempat maksudnya menggunakan CPU khusus untukmu)\nShared (menggunakan vCPU alias berbagi dengan pengguna lain)\nNah berdasarkan kebutuhan (dan ehm budget) kamu, kamu bisa mulai memesan server yang ingin kamu gunakan, tanpa biaya dan usaha banyak yang harus dikeluarkan.\nRekomendasi gue untuk infrastruktur di Indonesia adalah IDCloudHost dan untuk yang luar adalah DigitalOcean & Linode.\nSetiap penyedia layanan hampir menawarkan barang yang sama, pembedanya biasanya hanya di:\nInbound/outbound bandwidth transfer & throughput (10GbE? 40GbE?)\nJenis CPU yang digunakan (Intel? AMD?)\nJenis PCI yang digunakan (AHCI? NVMe?)\nDukungan sistem operasi (GNU/Linux? *BSD? Windows?)\nEkstensi tambahan seperti dukungan VM backup, floating IP, Layer 3/4 DDoS protection, dsb\nDi IaaS, ada 3 hal yang pada dasarnya sudah bukan menjadi urusanmu lagi, yakni:\nJaringan\nPenyimpanan\nKomputasi\nBerarti, sekali lagi, kamu tidak perlu memusingkan jenis Switch/Router, media penyimpanan, dan hal-hal terkait komputasi seperti CPU dan RAM yang akan digunakan, karena itu sudah bukan lagi urusanmu.\nPertanyaan paling inti adalah: Seberapa besar kamu mempercayai penyedia IaaS yang kamu pilih dalam memilih & memelihara 3 hal diatas?\nIni adalah lapisan diatas IaaS, dan jika berbicara realita, pada dasarnya sebuah aplikasi hanya terdiri dari komponen-komponen berikut:\nRuntime (biasanya sebuah web server)\nDatabase (MariaDB? Postgres? MongoDB?)\nStorage (di disk? di db? di S3?)\nKomponen lain seperti worker hanyalah tambahan dan bukan sebuah kewajiban. Oh, biasanya sebuah aplikasi/layanan bertindak sebagai IDP, jadi mungkin harus memikirkan hal-hal terkait IAM nya juga.\nAnyway, anggap kita menggunakan IaaS dan ada 7 layanan utama untuk dapat menjalankan aplikasi kita:\nReverse proxy 1 (SSL termination, i.e: Traefik)\nReverse proxy 2 (caching, compression, i.e: OpenResty)\nPersistent storage (i.e: Postgres)\nEphemeral storage (i.e: Redis)\nAnother proxy (i.e: imgproxy)\nMain application\nWorker application\nSetidaknya 7 layanan diatas yang harus berjalan untuk dapat menggunakan situs yang sedang kamu akses sekarang ini.\nYang berarti, ada 7 layanan yang harus gue pikirin & pelihara, dari backup; monitoring, keamanan, dsb.\nDan, hey! VM gue pakai FreeBSD, bisa gak nih jalanin Umami di VM ini?\nSalah satu benefit yang ditawarkan oleh cloud adalah tentang abstraksi, dan IaaS hanya meng-cover bagian infrastrukturnya saja.\nIngin membuat strategi failover di Postgres? Ingin membuat replika di Redis? Ingin dapat membuat aplikasi berjalan kembali setelah crash? Ingin menjalankan untrusted code dengan aman? Ingin naik gaji?\nItu urusan anda.\nNah, dengan PaaS, hal-hal tersebut bisa menjadi urusannya orang lain alias menjadi urusannya si penyedia layanan (oke kecuali bagian naik gaji, mungkin possible aja anyway).\nKunci dari cloud sebenarnya adalah satu: managed X. Jika IaaS berarti managed infrastructure, PaaS berarti managed platform.\nContohnya, kamu tidak perlu berurusan dengan instalasi Ruby untuk menjalankan aplikasi yang dibuat menggunakan Ruby On Rails ini, karena, ya, itu urusan si penyedia layanan.\nDan hey, sudahkah gue menyebutkan bahwa kita tidak perlu memusingkan konfigurasi firewall untuk memfilter paket masuk dan keluar? Anyway.\nGue personally belum tertarik menggunakan PaaS karena masalah biaya (alias duit gue masih lebih berharga daripada waktu hahaha) tapi kalau mau mencoba, pertimbangan gue adalah menggunakan fly.io, Cloud Run nya GCP, atau apapun itu yang bukan ehm Heroku.\nSatu hal yang dijual oleh PaaS adalah agar pengembang bisa fokus ke aplikasi yang dikembangkannya tanpa perlu memusingkan hal-hal terkait infrastruktur dari memilih sistem operasi; kernel, dan lain sebagainya terkait runtime.\nBukan tanpa alasan gue menempatkan bagian inti dari komputasi awan di bagian terakhir. Selain kemudahan, benefit yang didapat dari komputasi awan ini adalah elastisitas (is this a thing?) khususnya dalam menggunakan sumber daya untuk melakukan komputasi.\nMisal, kamu bisa menambah vCPU secara on-demand misal ketika traffic sedang naik-naiknya, dan kamu cukup membayar hanya selama vCPU tambahan tersebut digunakan. Sesuatu yang sulit didapat dari infrastruktur tradisional, bukan?\nSelain di elastisitas dalam sumber daya, ada juga di bagian lain yang akan kita bahas nanti per-kategori :))\nHal yang harus diperhatikan dalam memilih Cloud Provider adalah kepercayaan, karena dengan migarsi ke cloud, secara tidak resmi berarti kita mempercayakan si penyedia layanan dalam mengatur apapun yang terjadi di sistem yang kita buat dan miliki.\nUntuk skala yang lebih kecil, tentu ini bukanlah a very big deal terlebih mungkin dari hari pertama pun mereka sudah mengadopsi cloud. Namun untuk yang konteksnya migrasi ke cloud, I cannot speak for them, sayangnya.\nDitulisan ini kita hanya membahas tentang IaaS dan PaaS, diselanjutnya kita akan explore lebih jauh lagi yakni di Function as a Service (FaaS) alias Serverless computing berikut dengan benefit serta drawbacks nya khususnya untuk Software Developer.\nSee you very soon on the next cloud!","tags":"cloud","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-07-30T10:22:13","created_at":"2021-07-30T12:15:33.702359","updated_at":"2021-07-30T12:15:33.702359","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2845,"title":"Design Pattern: Proxy & Chain of Responsibility (Bahasa Indonesia) | CodingClass S1 ‚¶Å E7","url":"https://www.youtube.com/watch?v=HoU4MZlnYWo","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-07-30T03:14:57","created_at":"2021-07-30T06:12:03.475584","updated_at":"2021-07-30T06:12:03.475584","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2846,"title":"Tips Jadi CTO ala Rendra Toro","url":"https://anchor.fm/ceritanya-developer/episodes/Tips-Jadi-CTO-ala-Rendra-Toro-e1579bh","body":"Siapa yang punya mimpi jadi CTO? Peran ini emang sangat krusial, terutama untuk startup yang sangat bergantung di teknologi dengan tim engineer banyak (lebih dari 10 orang). Nah, Rendra Toro bagi-bagi tipsnya di episode ini. \n\n\"Kemampuan seorang CTO untuk berkomunikasi, mengerti bisnis perusahaan dan mendalami beberapa aspek diluar bidang agar ia bisa merangkai semua itu agar departemen teknologinya bisa supporting semua hal di perusahaan itu juga penting,\" ujar CTO di PT. Perintis Teknologi tersebut. \n\nDengerin tips lengkapnya dan perjalanan karir Rendra Toro di Ceritanya Developer","tags":"","media":"podcast","thumbnail":null,"owner":"Riza Fahmi","draft":false,"original_published_at":"2021-07-30T02:38:33","created_at":"2021-07-30T06:12:17.299649","updated_at":"2021-07-30T06:12:17.299649","deleted_at":null,"source_id":3,"contributor":"rizafahmi"},{"id":2836,"title":"SELinux dan Docker data-root","url":"https://www.evilfactorylabs.org/widnyana/selinux-dan-docker-data-root-35e2","body":"Kapan hari saya perlu memindahkan data-root directory docker dari kampung halamannya di /var/lib/docker ke /mnt/storage-0/docker karena persoalan ruang di partisi utama yang semakin menipis. Sebagai konteks, mesin ini menggunakan OS Centos 8 dengan SELinux: Enforcing. \nKalau melihat dokumentasi yang ada, cara mindahin data-root sebenernya ga ribet, langsung aja edit file /etc/docker/daemon.json, dan tambahin line dibawah, copy semua file dari directory lama, terus restart docker daemonnya.\n{\n...\n  \"data-root\": \"/mnt/storage-0/docker\",\n...\n}\n\nSayangnya, ternyata tidak semudah itu Fergusso. Semua emang terlihat lancar sampai ketika saya menggunakan fitur buildkit. Command docker build ... selalu gagal, dengan pesan error:\n0.479 standard_init_linux.go:228: exec user process caused: permission denied\n\n\nRefleklah ngecek audit.log, akhirnya ketahuan kalau directory /mnt/storage-0/docker belum dikasih label yang sesuai biar dikenali sama SELinux sebagai \"rumah\" nya si docker. \nIsi lognya begini:\n...\ntype=AVC msg=audit(1627476572.116:8223): avc: denied { entrypoint } for pid=277147 comm=\"runc:[2:INIT]\" path=\"/bin/busybox\" dev=\"overlay\" ino=202821668 scontext=system_u:system_r:container_t:s0:c257,c579 tcontext=system_u:object_r:unlabeled_t:s0 tclass=file permissive=0\ntype=AVC msg=audit(1627478254.522:8273): avc: denied { entrypoint } for pid=287085 comm=\"runc:[2:INIT]\" path=\"/bin/busybox\" dev=\"overlay\" ino=202821668 scontext=system_u:system_r:container_t:s0:c358,c450 tcontext=system_u:object_r:unlabeled_t:s0 tclass=file permissive=0\n...\n\nYaudah, berarti tinggal dilabelin sesuai dengan label directory lamanya, ambil contekan dulu pakai command ini:\ngrep docker /etc/selinux/targeted/contexts/files/file_contexts | grep \"/var/lib/docker\n\nCopy yang sesuai dengan kasus, terus bikin command buat ngedefinisiin context mapping directory data-root barunya si docker:\nsemanage fcontext -a -s system_u -t container_var_lib_t         \"/mnt/storage-0/docker(/.*)?\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/.*/config\\.env\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/init(/.*)?\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/overlay(/.*)?\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/overlay2(/.*)?\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/containers/.*/hosts\";\nsemanage fcontext -a -s system_u -t container_log_t             \"/mnt/storage-0/docker/containers/.*/.*\\.log\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/containers/.*/hostname\";\n\nAbis eksekusi command diatas, terus jalanin command dibawah buat melabeli ulang directory tersebut secara rekursif sesuai dengan context yang tadi udah diset:\nrestorecon -Rv /mnt/storage-0/docker\n\nUdah deh, \nsebelum negara api menyerang.","tags":"selinux,docker,sysadmin","media":"tulisan","thumbnail":null,"owner":"Wid","draft":false,"original_published_at":"2021-07-29T16:24:30","created_at":"2021-07-29T18:12:00.239836","updated_at":"2021-07-29T18:12:00.239836","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2824,"title":"Ngulik Desain API Identity Access Management (IAM) Google Cloud","url":"https://www.youtube.com/watch?v=o4g1pKA0yQY","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-07-28T03:31:20","created_at":"2021-07-27T00:34:00.208352","updated_at":"2021-07-27T00:34:00.208352","deleted_at":null,"source_id":62,"contributor":"PuloDev"}],"total":1352}