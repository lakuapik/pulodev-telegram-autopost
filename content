{"data":[{"id":2867,"title":"Netlify sebagai Pemendek Tautan","url":"https://opakholis.dev/blog/shortener","body":"Menjadikan Netlify Redirects sebagai layanan URL Shortener pribadi","tags":"netlify, shortener","media":"tulisan","thumbnail":"https://opakholis.dev/static/images/shortener/banner.jpg","owner":"Opa Kholis Majid","draft":false,"original_published_at":"2021-10-08T00:00:00","created_at":"2021-08-10T17:14:44.442527","updated_at":"2021-08-10T17:14:44.442527","deleted_at":null,"source_id":null,"contributor":"opxop"},{"id":2890,"title":"Apa Itu Google Cloud Eventarc? (Bahasa Indonesia)","url":"https://www.youtube.com/watch?v=IN0MTv4ziIM","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-18T02:40:02","created_at":"2021-08-18T09:32:40.817194","updated_at":"2021-08-18T09:32:40.817194","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2891,"title":"Connecting Monika with Prometheus","url":"https://medium.com/hyperjump-tech/collecting-monika-with-prometheus-9faa7d484a30?source=rss----fabfd42372dc---4","body":null,"tags":"devops,software-development,monitoring,prometheus,javascript","media":"tulisan","thumbnail":null,"owner":"muslim","draft":false,"original_published_at":"2021-08-18T01:57:57","created_at":"2021-08-18T09:33:07.646896","updated_at":"2021-08-18T09:33:07.646896","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2889,"title":"Pengenalan Bahasa Go","url":"https://gadiskoding.my.id/pengenalan-bahasa-go.html","body":"Go disini artinya bukan pergi, ~ Let it Go","tags":"Golang, REST API","media":"tulisan","thumbnail":"/images/og.png","owner":"Artileda","draft":false,"original_published_at":"2021-08-16T11:42:47.744","created_at":"2021-08-16T11:43:07.756873","updated_at":"2021-08-16T11:43:07.756873","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2892,"title":"Orthogonality pada Programming","url":"https://www.evilfactorylabs.org/alvnmfth/orthogonality-pada-programming-54h3","body":"Ketika mengerjakan existing project atau proyek yang sudah ada, waktu akan lebih banyak digunakan untuk memahami setiap bagian source code yang sudah ada sebelumnya. Perlu melakukan tracing code ketika mecoba build & run program, seperti kapan baris sekian dieksekusi, dimana melakukan perubahan tambahan, dan lain-lain. Kompleksitas dari proyeknya juga menambah tantangan lain ketika hendak menambah fitur yang diminta. Kalau nihil dokumentasi, maka perlu proses hand over dengan pemrogram sebelumnya. Panjang umur bagi kolega yang apabila membuat code mudah dipahami.\nSepertinya hidup sedikit lebih tenang jika tidak membuat bugs tujuh turunan (terhindar dari pertanyaan dan complain). Selain itu menyenangkan pula jika code kita mudah dipahami kolega.\nKetika fitur-fitur baru ditambahkan saat mengembangkan existing project, maka kemungkinan kompleksitas bertambah. Tapi, pengembangannya akan lebih mudah apabila tidak melibatkan atau mengubah barisan code yang sudah ada sebelumnya. Sistem atau proyek yang tidak perlu mengubah barisan code sebelumnya seperti ini dapat disebut orthogonal.\nOrthogonal\n\n\n\nSistem yang orthogonal adalah saat mengubah fitur B maka tidak akan mengganggu keadaan fitur A.\nIstilah orthogonal digunakan dalam bidang geometri untuk mendeskripsikan garis yang tidak bersinggungan atau independent dalam suatu grafik. \nBayangkan ada orang bawa motor bebek supra. Setiap menaikkan atau menurunkan kecepatan, maka perlu mengubah gigi (motor). Ketika mengubah gigi motor, gas motor harus turun. Kalau menaikkan gas saat menurunkan gigi, otomatis kecepatan motor turun drastis, efeknya kerusakan gear set. Beruntung kalau nggak jatuh atau mental. \nContoh dari masalah di atas adalah sistem yang tidak orthogonal. Karena untuk menggunakan satu fungsi, perlu untuk mengubah fungsi yang lain. \nAtau contoh lain yang sering digunakan untuk mengenalkan orthogonality ialah fungsi radio. Ketika melakukan pergantian channel maka hanya perlu menekan tombol next atau prev, tidak perlu menekan tombol pengubah suara dan lain-lain. \nPenerapan orthogonality pada frontend lebih sering diimplementasi saat memisahkan setiap komponen yang memiliki fungsi khusus, seperti event listening, styling, logic, dan request data melalui API. Penggunaan state management seperti redux atau penerapan css in js membantu kita untuk membuat proyek lebih orthogonal.\nimport { Suspense, useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport \"./styles.css\";\n\nexport default function ArticlePage() {\n  const [article, setArticle] = useState([]);\n\n  useEffect(() => {\n    // Melakukan fetch data dengan axios\n    (async function () {\n      const response = await axios.get(\n        \"https://jsonplaceholder.typicode.com/posts/1\"\n      );\n      setArticle(response.data);\n    })();\n  }, []);\n\n  // Menampilkan data saat aplikasi selesai memuat data\n  return (\n    <Suspense fallback={<div>page is loading...</div>}>\n      <h2>{article.title}</h2>\n      <p>{article.body}</p>\n    </Suspense>\n  );\n}\n\nArticlePage komponen yang me-render tampilan judul artikel dan kontennya setelah aplikasi berhasil memuat data dari API. Integrasi API memanfaatkan axios untuk memudahkan proses fetch data.\nContoh komponen React di atas ini belum orthogonal. Kenapa? Karena integrasi API masih dilakukan dalam satu komponen dengan UI logic. Saat mengganti library dari axios dengan yang lain otomatis akan mengganti logic UI-nya. Mungkin dengan cara memisahkan fungsi integrasi dengan UI akan mengurangi efek samping perubahan.\nimport { Suspense } from \"react\";\nimport \"./styles.css\";\n\nexport default function ArticlePage({ response }) {\n  // Menampilkan data saat aplikasi selesai memuat data\n  return (\n    <Suspense fallback={<div>page is loading...</div>}>\n      <ArticleContent article={response} />\n    </Suspense>\n  );\n}\n\nfunction ArticleContent({ article }) {\n  return (\n    <div>\n      <h2>{article.title}</h2>\n      <p>{article.body}</p>\n    </div>\n  );\n}\n\n\nDengan memisahkan fungsi logic dengan integrasi API, maka perubahan di masa depan akan lebih fleksibel dan adaptif. Untuk penerapan integrasi API dengan memanfaatkan state management, alur data pada aplikasi akan teratur.\nDalam kasus nyata mungkin komponen yang tetap bergantung dengan komponen lainnya akan masih terjadi. Karena komponen React masih memerlukan main component yang menghubungkan antar komponen dengan state management.\nSecara keuntungan, dengan membuat proyek yang orthogonal fungsi-fungsi dan komponen menjadi independen dan mengurangi resiko perubahan. Selain itu, keuntungan lainnya yaitu:\nCode lebih mudah dipahami\nMeningkatkan produktifitas \nMenghindari duplikasi code\n\n\n\nSekian, pembahasan tentang orthogonality dalam pemrograman. CMIIW!","tags":"pragmatic,dry","media":"tulisan","thumbnail":null,"owner":"Alvin Miftah","draft":false,"original_published_at":"2021-08-15T18:57:41","created_at":"2021-08-18T09:33:09.06449","updated_at":"2021-08-18T09:33:09.06449","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2893,"title":"Frontend development dari iPad","url":"https://www.evilfactorylabs.org/faultable/frontend-development-dari-ipad-go0","body":"Pertama dan yang paling utama adalah sebuah sangkalan: perhatikan bahwa gue menggunakan kata dari bukan di, yang berarti, iPad hanyalah sebagai jembatan untuk melakukan frontend development, oke?\nSebelum kita masuk topik pembahasan, hal wajib yang perlu dimiliki adalah sebuah devbox atau remote development server yang semoga sudah punya, ya? Jika belum, nanti suatu saat gue akan berbagi tentang mengatur devbox.\nSelain itu, disini gue menggunakan Blink sebagai SSH/Mosh client di iPad.\nWithout further ado, let’s dive.\nSemua komputer yang gue miliki (macbook, intel nuc, raspi) 80% kegunaannya hanyalah untuk SSH dan membuka peramban. Oke mungkin kadang gue buka Discord dan Apple Music/Spotify juga, but you got the point.\nLalu gue iseng membeli iPad yang gue impikan sih bisa menjadi alternatif dari penggunaan yang gue lakukan di desktop ataupun laptop gue. Sejauh ini gue yakinkan sudah 60% efektivitasnya, meskipun di weekday gue masih bergantung dengan perangkat desktop gue untuk menyelesaikan pekerjaan.\nMelakukan frontend development di iPad gue rasa masih sedikit painful, berbeda dengan backend development yang technically tidak harus bergantung dengan aplikasi yang menggunakan GUI, yang gue rasa hanya menggunakan terminal emulator pun sudah lebih dari cukup, lalu menggunakan curl ataupun httpie sebagai HTTP client.\nEsensinya untuk melakukan frontend development yang diperlukan hanyalah dua: Sebuah development environment dan peramban. Development environment disini kita menggunakan devbox dan peramban menggunakan Safari, karena semua peramban di iOS/iPad OS pada dasarnya adalah Safari.\nProgram utama yang gue gunakan di devbox hanya 3:\ntmux\nvim\nssh/mosh\nAkhir-akhir ini gue menggunakan SSH daripada mosh karena masalah Port Forward & dukungan truecolor yang somehow Blink gue tidak mendukung (padahal mosh di server gue pakai versi HEAD). Meskipun gue masih bisa hidup tanpa truecolor (dan port forward bukan jadi masalah dengan menempatkan reverse proxy), tapi gue masih nyaman dengan workflow seperti sekarang. Jika memang SSH menjadi masalah (karena fitur dari TCP) dan karena fitur dari iPad OS yang membatasi background service hanya sekian menit, mungkin koneksi SSH bisa dibungkus dengan paket UDP dengan memasang jaringan VPN via Wireguard.\n…atau bisa menyerah dengan menggunakan mosh.\nAnyway, di level peramban biasanya pengembang membutuhkan ekstensi untuk membuat proses development menjadi lebih mudah. Gue personally jarang banget menggunakan ekstensi (meskipun memasangnya) dan juga gue jarang banget menggunakan devtool selain hanya untuk inspect permintaan HTTP.\nSafari di iPad dan iOS sejauh ini belum menawarkan devtool ke penggunanya, tapi nanti akan gue jelaskan alternatifnya jika memang ekstensi dan devtools adalah sebuah keharusan.\nGue bukan penggemar berat VSCode, tapi gue rasa penyunting kode ini adalah yang paling populer digunakan oleh rekan pengembang sekalian.\nVSCode (dari Microsoft) memiliki ekstensi “remote SSH” yang sederhananya mengakses workspace yang ada di remote server melalui VSCode yang ada di local. Remote SSH ini memiliki DX yang cukup baik, namun terbatas hanya di VSCode (tidak ada di VSCodium) dan yang paling penting: tidak ada versi untuk iPad.\nJika memang menggunakan VSCode sebuah keharusan, gue rekomendasikan menggunakan code-server yang lumayan ringan untuk dijalankan. Tampilannya adalah seperti ini:\n\nTerlihat sangat familiar, bukan? Semua yang kamu butuhkan dari terminal, debug console, dsb bisa diakses disana. Instalasi code-server relatif sangat mudah, dan yang perlu diketahui adalah extension marketplace nya bukanlah yang dari official VSCode tawarkan (VS Code Marketplace) melainkan dari Open VSX Registry yang dipelihara oleh Eclipse Foundation.\nCara aksesnya relatif mudah: bisa langsung tembak dengan <ip>:<port> atau bisa berlindung dibelakang reverse proxy. Gue personally merekomendasikan untuk berlindung dibalik reverse proxy khususnya bila hanya port 80 dan 443 yang di expose ataupun kalau karena males setting VPN.\nIni adalah workflow utama gue!\nTidak ada yang spesial dari ini, tapi workflow ini yang paling nyaman gue gunakan terlepas perangkat yang gue gunakan.\n\nUntuk vim (penyunting teks) gue menggunakan Neovim karena mengapa tidak dan untuk tmux (terminal multiplexer) ini menurut gue sebuah keharusan agar gue bisa datang dan pergi sesuka hati gue ke workspace gue di devbox tanpa perlu mengkhawatirkan kehilangan state yang ada (kecuali crash ataupun rebooted)\nJika kurang suka dengan tmux in any reason, mungkin bisa menggunakan GNU Screen yang technically sama-sama terminal multiplexer juga.\nPertama dan yang paling utama, keluaran dari console.log akan tampil di terminal gue (is anyone anti console.log?).\nJika console.log tidak cukup dan menggunakan curl adalah pekerjaan yang painful, gue bisa kasih alternatif: menggunakan virtual browser.\nPernah menggunakan rabb.it? Nah, technically seperti itu, cuman untuk melakukan development bukan untuk nonton bo…\nbola!\nNah, biar lebih sederhana bisa menggunakan docker image nya jlesage/docker-firefox untuk menjalankan Firefox yang bisa diakses di peramban.\n\nWow, peramban didalam peramban!\nAlamat IP yang ada di peramban tersebut milik docker0 yang sederhananya untuk bisa mengakses port yang ada di host dari container. Jika terlihat ugly atau tidak sesuai keinginan, DNS pastilah jawabannya :)\nMengapa menggunakan Firefox? Karena gue pengguna berat Firefox. Jika tidak ingin menggunakan FF, silahkan cari alternatif yang menggunakan Chrome ataupun yang lainnya. Virtual browser ini technically menggunakan protokol VNC, tapi daripada stream keseluruhan DE, klo virtual browser ya hanya peramban saja.\nSilahkan pasang ekstensi yang kamu butuhkan disana, dan jangan lupa mengatur volume yang persistent ke si container.\nJika kurang puas dengan ukuran layar iPad, mungkin bisa pertimbangkan membeli dongle (fanboy will understand) untuk port Lightning to HDMI dan gunakan monitor eksternal favorit kalian ataupun yang ada aja (misal monitor di kamar hotel).\nUntuk keyboard gue menggunakan Smart Keyboard Folio karena iPad gue adalah yang Air. Gue ada Magic Keyboard juga yang gue pakai di desktop tapi bila menggunakan Smart Keyboard Folio ini, tidak perlu menggunakan bluetooth untuk penggunaannya.\nMouse! Ya, mouse! Gue bukan fans berat mouse tapi semua mouse yang mendukung koneksi via bluetooth gue rasa bisa berjalan juga di iPad.\nJika ada yang terlewat (tools, workflow, dsb), please let me know!\nGue menjadikan iPad sebagai alternatif aja, bukan sebagai alat utama. Di banyak kasus untuk aktivitas development, gue lebih banyak dilakuin di desktop. Biasanya iPad kepake kalau lagi diluar dan ada hal yang benar-benar urgent di kantor ataupun karena ingin mengerjakan side-project yang tidak-akan-pernah-selesai-tapi-bikin-side-project-baru-lagi~\nOverall gue belum terlalu puas dengan setup seperti ini (khususnya di penggunaan virtual browser) meskipun ada peramban alternatif di iOS/iPad OS yang khusus untuk development yakni Inspect Browser tapi poinnya peramban tersebut tetaplah WebKit :))\nUntuk workload yang gak ribet-ribet amat (seperti ngetik tulisan) kalau lagi males nyalain komputer atau buka laptop (for some reason) yaa gue menggunakan iPad ini.\nSebagai penutup, tulisan adalah sedikit gambaran terkait melakukan frontend development dari iPad. Untuk murni backend development gue rasa lumayan puas terlebih karena gak perlu berurusan dengan devtool yang biasa ditawarkan oleh peramban.\nSetiap orang memiliki workflow yang berbeda-beda, dan ini adalah yang gue gunakan. Bagaimana jika kamu membagikan workflow kamu juga?","tags":"frontend,ipad,workflow","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-08-15T10:28:59","created_at":"2021-08-18T09:33:09.06449","updated_at":"2021-08-18T09:33:09.06449","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2888,"title":"Haskell #1: Pengantar","url":"https://youtu.be/BSWoegYLC3E","body":"Haskell adalah bahasa pemrograman dengan paradigma fungsional murni, dan serba guna. Apa saja sih yang disediakan oleh Haskell ? dan bagaimana rupa sintaksis alienya?","tags":"haskell, fungsional programming, kalkulus lambda","media":"video","thumbnail":"https://i.ytimg.com/vi/BSWoegYLC3E/maxresdefault.jpg","owner":"Idiosemantik","draft":false,"original_published_at":"2021-08-15T00:00:00","created_at":"2021-08-16T10:51:27.427424","updated_at":"2021-08-16T10:51:27.427424","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2894,"title":"Making Smol Shopify App for Fun and Profits...","url":"https://www.evilfactorylabs.org/tibudiyanto/making-smol-shopify-app-for-fun-and-profits-3bm2","body":"While I was helping my wife setting up her shopify store, I notice there wasn't much shipping cost counter app to choose from. So I thought, why don't I make some quick app to do this?\nShopify has lots of ways to enhance a store capability. For this exercise, I am using their CarrierService thingy. In short, Shopify will issue a callback to an endpoint with some order informations everytime a user checks out. Our job here is to respond with shipping rate(s) information. \n\nThis is our MVP:\nUser that checks out can get a shipping cost that is added automatically to his / her total\nUse only 1 shipping carrier (J&T)\nAdd unique identifier to the amount (for manual bank transfer checking)\nLet's setup our build plan.\nPrepare all the data:\nprepare shipping cost data\nlook at shopify request and payload\nRegister our endpoint as callback\n\n\n???\n\n\nProfit.\n\n\n\n\n  \n  \n  Preparing the data\n\n\nNow, we already have an excel sheet of shipping cost from her place of business to all kecamatan across Indonesia, so everything is quite trivial to build. For this private app, I am using sqlite, and Flask.\nFirst, lets look at the shipping cost data. It looks like this after I save that excel into a CSV.\narea,asal,kecamatan,kota_tujuan,cost, estimate\nSURABAYA,SURABAYA,5 KOTO KAMPUNG DALAM,PADANG PARIAMAN,\" 78000 \", 2-4 hari \nSURABAYA,SURABAYA,5 KOTO TIMUR,PADANG PARIAMAN,\" 78000 \", 2-5 hari \nSURABAYA,SURABAYA,7 KOTO SUNGAI SARIK,PADANG PARIAMAN,\" 62000 \", 3-7 hari \nSURABAYA,SURABAYA,ABAB,PENUKAL ABAB LEMATANG ILIR,\" 61000 \", 2-7 hari \nSURABAYA,SURABAYA,ABANG,KARANG ASEM,\" 23000 \", 2-7 hari \nSURABAYA,SURABAYA,ABELI,KENDARI,\" 68000 \", 2-7 hari \nSURABAYA,SURABAYA,ABENAHO,YALIMO,\" 197000 \", 2-7 hari \n\nThat doesn't look terribly bad. Notice how the cost is a string instead of an integer. Using sqlite-utils I load that csv file into a sqlite database.\nsqlite-utils insert shiptok.sqlite shipping_cost shipping_cost.csv --csv\n\nNext, with little SQL incantation, we can change the cost column into an integer. Open the db with sqlite3 shiptok.sqlite then follow this incantation:\nCREATE TABLE shipping_cost_cleaned as\nSELECT area, asal, kecamatan, kota_tujuan, CAST(cost as decimal) cost, estimate\nFROM shipping_cost;\n\nWe gucci.\nLooking at Shopify's request, we know there are 2 major values that we need to pay attention to: destination and items. We don't really care about origin because it always points to our business location. This is where things get tricky; on their default settings, there is no kecamatan field, but our shipping_cost table only has kecamatan as an identifier. So its time to get funky.\nWe know for sure that postal code is a required field. Abusing this fact, I am adding this postal_code data and then finding the kecamatan via the postal code.\nSELECT CAST(cost as decimal), trim(estimate)\nFROM shipping_cost sc\nJOIN postal_code pc ON pc.sub_district = sc.kecamatan\n  AND kecamatan = :kecamatan \n\nAnd Bob's your uncle.\nWhen we went live, we got reports that not all postal code is bueno; there are some mismatch values on kecamatan column on postal_code github data and J&T Shipping cost data (spelling error, misnaming and etc). So we need a better (funkier) solution. I chose to use the next identifier that are province and city. My algorithm is quite simple, give me the maximum shipping cost to a given city and province. I know it is not exactly 'right' but this is not the time nor place for razor sharp accuracy. Voila:\nSELECT CAST(cost as decimal), trim(estimate)\nFROM shipping_cost s\nJOIN postal_code pc on pc.city = s.kota_tujuan \n  AND pc.city = UPPER(:city)\nJOIN provinces p on p.province_code = pc.province_code \n  AND p.code = UPPER(:province)\nORDER BY CAST(cost as decimal) DESC\nLIMIT 1\n\nNot the prettiest, but it works.\nSimple stuff really:\ndef get_shipping_straightforward(req: RateRequest):\n    destination = req.destination\n    # get postal_code\n    postal_code = destination.postal_code\n    # First Query above\n    return jnt.get_shipping_info(postal_code)\n\n\ndef get_shipping_estimate(req: RateRequest):\n    destination = req.destination\n    # get province and city\n    province = destination.province\n    city = destination.city\n    # find estimate based of max province, query above\n    return jnt.get_shipping_estimate(province, city)\n\n\n@callback.route(\"\", methods=[\"POST\"])\ndef shipping_callback():\n    req = RateRequest(**request.json[\"rate\"])\n\n    shipping_rate = get_shipping_straightforward(req) or get_shipping_estimate(req)\n\n    if not shipping_rate:\n        raise Exception(\"No shiping rate avail\")\n\n    rate_per_1_kg, estimate = shipping_rate\n\n    quantity = sum([item.quantity for item in req.items])\n    # One box can fit 3 items, and each box is 1 kg.\n    total_approximate_weight = math.ceil(quantity / 3)\n\n    randomizer = randint(10, 100)\n\n    expected_shopify_rates = [\n        Rate(\n            service_name=f\"J&T\",\n            service_code=\"J&T Regular\",\n            total_price=(rate_per_1_kg * total_approximate_weight + randomizer) * 100,\n            description=estimate,\n        )\n    ]\n\n    response = RateResponse(rates=expected_shopify_rates)\n\n    return jsonify(response.dict())\n\nRandomizer is there just for easy identifier (in the case of manual bank transfer).\nNow whats left to do is deploying and registering your callback. \nI just go to replit.com and deploy the Flask app there. \nAfter you know your replit url, register your callback to your shopify store using this API. \nSo far, this API has served more than 50 orders and up north of 50 mio IDR in value with very little to no cost (being in replit). Maybe I'll open source it after I cleaned up all that git committed environment variable. Or, maybe real API integration to other providers? I don't know.\nThat is all I wanted to share with y'all today. Hit me up on twitter @tibudiyanto\n. Stay kool guys, gals, and my non-binary pals!","tags":"shopify,flask,python,sql","media":"tulisan","thumbnail":null,"owner":"theo","draft":false,"original_published_at":"2021-08-14T14:52:24","created_at":"2021-08-18T09:33:09.06449","updated_at":"2021-08-18T09:33:09.06449","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2886,"title":"Tips Soft Skill untuk Developer ala Pria Purnama","url":"https://anchor.fm/ceritanya-developer/episodes/Tips-Soft-Skill-untuk-Developer-ala-Pria-Purnama-e15s55f","body":"Banyak orang berpikir bahwa menjadi developer itu hanya tentang kemampuan teknis. Sehingga banyak developer junior yang kurang mengasah soft skill-nya. Padahal mengabaikan soft skill bisa mengakibatkan kurangnya komunikasi yang efektif dengan tim, klien hingga mempengaruhi karir.\n\n\"Ilmu yang saya pelajari dari mentor saya dulu. Jika kita ingin menyampaikan hal yang penting, namun proses penyampaiannya kurang baik, itu kan enggak diterima. Jadi, apa yang mau disampaikan dan bagaimana cara menyampaikannya, keduanya sama penting,\" papar Pria Purnama.\n\nCTO Kata.Ai tersebut selalu menekankan pentingnya developer untuk mengasah soft skill agar memudahkan proses kerjasama, karena developer itu nggak kerja sendiri. Yuk, dengerin tips lainnya dari Pria Purnama hanya di Ceritanya Developer kali ini.","tags":"","media":"podcast","thumbnail":null,"owner":"Riza Fahmi","draft":false,"original_published_at":"2021-08-13T09:17:01","created_at":"2021-08-13T12:15:05.871891","updated_at":"2021-08-13T12:15:05.871891","deleted_at":null,"source_id":3,"contributor":"rizafahmi"},{"id":2887,"title":"Cara merubah angka menjadi teks menggunakan javascript","url":"https://rifkiaf.medium.com/cara-merubah-angka-menjadi-teks-menggunakan-javascript-4f249887d35c","body":"Membaca angka dengan javascript","tags":"javascript, number to text","media":"web","thumbnail":"","owner":"Rifki ahmad fahrezi","draft":false,"original_published_at":"2021-08-13T03:33:03.533","created_at":"2021-08-14T06:23:21.300351","updated_at":"2021-08-14T06:23:21.300351","deleted_at":null,"source_id":null,"contributor":"Rifki ahmad fahrezi"},{"id":2885,"title":"Service Object","url":"philiplambok.github.io/service-object,/rails/2021/08/12/service-object.html","body":"Hello!\nSebenernya ditulisan sebelumnya saya udah mau commit buat mau mulai nulis pake bahasa inggris di blog ini, tapi baru sadar, kalo blog ini udah saya submit di pulo.dev, yang dimana ekpektasi konten-konten disana itu berbahasa indonesia.\nDitambah gk ada alasan tertentu tulisan-tulisan saya harus berbahasa inggris karna kebanyakan terinspirasi dari tulisan-tulisan luar (inggris) 🙂, jadi saya balik lagi buat nulis pakai bahasa indo saja ya.\nOke, mari kita mulai saja.\nTulisan ini saya buat scopenya saja, agar batasannya bisa lebih jelas dan bisa membantu saya agar tidak lari kemana-mana 😂\nApa itu Service Object (SO), dan masalah apa yang ingin dicoba untuk diselesaikan?\nDesign yang seperti apa yang bagus untuk di implement?\nApakah ada solusi alternative?\nApa itu Service Object, dan masalah apa yang ingin dicoba untuk diselesaikan?\nPertama kali saya menulis kode Service Object (SO) mungkin di akhir tahun 2018, ketika saya baru pertama kali menulis kode dengan dibayar oleh uang, yups it’s my first job.\nWaktu itu saya menganggap Service Object adalah layer baru di dalam Rails, terinspirasi dari buku ini, dimana dia berada diantara Model dan Controller.\nKode-kode SO adalah plain ruby object yang digunakan untuk menghandle logic bisnis pada aplikasi, sedangkan Model digunakan oleh service untuk membuat versi SQL dari hasil logic yang dihasilkan, dan Controller untuk mem-forward hasil logic (SO) ke user.\nKita bisa contohkan penggunaannya dengan seperti ini, misalkan kita berada di perusahaan online shop, dan kita diminta untuk membuat fitur order invoice.\n\n# app/services/create_order_invoice.rb\nclass CreateOrderInvoice\n  def initialize(params); end\n\n  def perform\n    tax = calculate_tax\n    total_invoice = calculate_total_invoice(tax)\n    order_invoice = OrderInvoice.create(create_order_invoice)\n    send_email_order_invoice(order_invoice)\n  end\nend\n\n# app/controllers/order_invoice_controller.rb\nclass OrderInvoiceController < ApplicationController\n  def create\n    CreateOrderInvoice.new(params).perform\n    redirect_to invoice_path, notice: 'Your order has been successfully added'\n  end\nend\n\n# app/models/order_invoice.rb\nclass OrderInvoice < ApplicationRecord; end\n\n\nDaripada kita membuat kode perhitungan pajak, total amount dari invoice, membuat record order invoice, dan mengirim email order invoice pada controller atau model, lebih baik kita membuat object atau kelas khusus untuk menghandle hal tersebut yang membuat controller dan model kita tetep kurus.\nBenefit lain, kode jadi lebih mudah dibaca dan dipelihara, ketika model dan controller mulai berkembang, kode SO jadi lebih mudah diubah, karna perhintungan kalkulasinya hanya bisa diakses oleh SO, tidak bisa diakses di Model dan Controller sehingga kita tidak perlu khawatir dengan backward compatibility dan breaking changes, asal public methodnya #perfom tetap perform sesuai ekspektasi.\nDesign yang seperti apa yang bagus untuk di implement?\nOk, saya harap anda sudah paham benefit apa yang dapat dihasilkan dengan mengimplement SO. Sekarang mari lanjut untuk membahas bagaimana cara mendesain interfacenya, karna menurut pengalaman saya belum ada standard yang jelas tentang interfacenya.\nKhususnya pada memberikan nama public methodnya. Pertama kali saya menulis kode SO yaitu dengan memberi nama #perform mengukuti codebase yang sudah ada pada saat itu.\nMungkin make sense memberi nama #perform yang mungkin menurut saya mereka mengikuti standard yang diberikan Sidekiq, karna secara implementasi SO mirip seperti worker, karena pada sidekiq, sebuah kelas worker hanya boleh memiliki satu tujuan saja, kita tidak bisa dimungkinkan untuk memiliki sebuah kelas worker yang bisa memiliki dua tanggung jawab.\nTapi secara implementasi SO berbeda dengan worker, SO (in most cases) juga tidak akan jalan di background job, mereka memberikan hasil yang hasilnya akan diperlukan oleh client pemanggilnya, berbeda dengan worker dimana pemanggilnya tidak memerlukan hasil atau return dari worker yang ia panggil.\nInterface lain yang salah lihat adalah #execute, make sense juga, mereka mengikuti naming dari Command pattern, yang sudah populer, dimana yang mungkin saya yakini service object terinspirasi dari design pattern tersebut.\nBut, let me tell you a secret, most of the time SO not working with commands things.\nBerbeda dengan command pattern CopyCommand, CutCommand dimana antara satu object dan object lainnya sangat dimungkinkan dipanggil oleh satu client yang sama, pada SO biasanya objectnya langsung dipanggil oleh client, dalam arti lain, sangat jarang ada SO yang saling berkaitan sehingga dipanggil oleh client yang sama.\nPada SO kita bisa saja memiliki kelas dengan nama CreateOrderInvoice dan UpdateUserRole dimana keduanya sama sekali berbeda.\nInterface lainnya adalah #call. Ruby juga implement ini di core mereka yang memungkinkan term Object as Function. Salah satu term yang sangat cocok bagi service object menurut saya dibandingkan Command pattern.\nSeperti definisi yang sebelumnya kita sudah bahas, bahwa SO adalah tempat dimana business logic pada aplikasi berada, kita bisa menamainya dengan nama tiket Jira yang di assign ke kita seperti GeneratePayrollReport , ChargeInvoice, SendEmailToCustomer, dll.\nDan secara implementasi object-object tersebut sangat mirip dengan function, kita tidak memiliki property, ataupun behavior layaknya pada object pada umumnya, karena SO hanya boleh memiliki satu instance method saja yaitu #call.\nObject as Function di Ruby seperti ini:\n\nclass Hello\n  def call(name)\n    puts \"Hello, #{name}\"\n  end\nend\n\nHello.new.('kotori') #> \"Hello, kotori\"\n\n\nSekarang kelas Hello diakses layaknya function di Ruby, seperti yang kita inginkan.\nAPI Design\nSetelah membahas background tentang belum adanya standard yang jelas tentang API design, khususnya pada penamaan public API. Sekarang waktunya untuk membuat standard versi kita.\nSeperti yang sudah dibahas sebelumnya, SO hanya boleh memiliki satu public method saja, karena kita akan mengadopsi philosophy Object as Function, untuk kontraknya seperti ini:\n\n# app/services/charge_payment.rb\nclass ChargePayment < ApplicationService\n  Error = Class.new(StandardError)\n\n  def initialize(invoice); end\n  # Public: Handle charge payment to the Invoice\n  # Returns Invoice\n  def call\n    # charge invoice logic goes in here\n  end\nend\n\n# app/services/application_service.rb\nclass ApplicationService\n  def call(...)\n    new(...).call\n  end\nend\n\n# how the service object was called\nChargePayment.call(invoice)\n\n\nSetiap SO inherit ke ApplicationService dimana kelas tersebut berfungsi untuk mendelegasikan .call menjadi #call . Jadi kita bisa memanggilnya dengan lebih mudah\n\n# instead of \nChargePayment.new.call(invoice)\n# or \nChargePayment.new.(invoice)\n\n# we could call like this\nChargePayment.call(invoice)\n\n\nSetiap SO boleh mengembalikan object apapun tanpa batasan, bahkan objectnya sendiri walaupun saya belum pernah mendapat case yang seperti ini. Namun satu hal yang tidak boleh adalah memiliki method lain selain #call, maupun property baik itu dibuat oleh generator seperti attr_reader maupun attr_accessor.\nJika anda ingin mengembalikan object atau value yang lebih dari satu, saya prefer untuk menggunakan Hash, atau OpenStruct, misalnya seperti ini:\n\nclass GeneratePayrollReport\n  def call\n    OpenStruct.new(account_number: account_number, total_transfer: total_transfer)\n  end\nend\n\n# or \nclass GeneratePayrollReport\n  def call\n    { account_number; account_number, total_transfer: total_transfer }\n  end\nend\n\n\nKetika aplikasi semakin besar (fiturnya makin banyak), maka kelas service pun jadi makin banyak juga, karna setiap Jira issue yang dibuat adalah kandidat yang bagus untuk menjadi SO.\nAlangkah lebih bagus kelas-kelas ini kita organisir lagi berdasarkan scope atau domainnya agar lebih rapih, kita bisa organisir menjadi seperti ini:\n\nPayrollServices::GeneratePdfReport\nPayrollServices::TransferTheMoney\nInvoiceServices::MakeItExpired\nInoviceServices::GeneratePdfReport\n\n\nDibandingkan keempat kelas itu flat (tanpa module) lebih baik kita organisir agar lebih rapih, benefit lain, penamaan kelas juga jadi tidak bentrok untuk kelas-kelas yang memiliki tujuan yang mirip, seperti GeneratePdfReport, Karena kita menempati mereka di module yang berbeda.\nUntuk naming convention-nya anda bisa buat DomainNameServices, untuk DomainName diusahakan singular jadi dibuat seperti ini: PayrollServices bukan PayrollsService atau PayrollsServices.\nError handling\nKita tidak bisa memastikan semua SO akan berjalan mulus tanpa ada hambatan atau rintangan, contohnya pada PayrollServices::TransferTheMoney mungkin saja bisa gagal perform karena ada network error pada bank API, atau nomor rekening karwayannya salah, begitu juga dengan InvoiceServices::MakeItExpired bisa saja ada gagal ketika melakukan SQL query update ke database, dan sebagainya.\nPada handle error di SO saya merekomendasikan untuk menggunakan filosofi fail-closed design by default. Pada filosofi ini kita akan melakukan raise Exception kelas ketika kita mendapatkan bahwa kelas tidak perform dengan benar dan kita memberhentikan processnya dengan paksa.\nContohnya seperti ini:\n\nclass ChargePayment\n  Error = Class.new(StandardError)\n\n  def call\n    raise Error, 'Failed to charge please try again',  if something_wrong?\n  end\nend\n\nclass PaymentsController < ApplicationController\n  def create\n    ChargePayment.call \n    redirect_to report_path, notice: \"Charge payment was successfully\"\n  rescue ChargePayment::Error => e\n    redirect_to report_path, notice: e.message\n  end\nend\n\n\nJadi ketika kita gagal melakukan, melakukan charge stack process akan berhenti di SO dan customer akan ditampilkan pesan error “Failed to charge please try again”.\nBenefit menggunakan prinsip ini kita tidak akan memberikan miss informasi ke user, contohnya jika kita lupa melakukan rescue terhadap errornya:\n\nclass PaymentsController < ApplicationController\n  def create\n    ChargePayment.call \n    redirect_to report_path, notice: \"Charge payment was successfully\"\n  end\nend\n\n\nAplikasi kita tidak akan akan menampilkan ‘Charge payment was successfully’ namun internal server error, dan error monitoring akan memberitahukan bahwa ada Exception yang belum di handle pada aplikasi.\nDibandingkan dengan menggunakan fail-open design yang menggunakan flag pada handle errornya:\n\nclass ChargePayment\n  Error = Class.new(StandardError)\n\n  def call\n    return false if something_wrong?\n  end\nend\n\nclass PaymentsController < ApplicationController\n  def create\n    charge_payment = ChargePayment.call\n    if charge_payment.false?\n      redirect_to report_path, notice: 'Failed to charge please try again'\n    else\n      redirect_to report_path, notice: 'Charge payment was successfully'\n    end\n  end\nend\n\n\nKode diatas menggunakan fail-open design yang memungkinkan kita dapat memberikan informasi yang salah kepada user, contohnya jika kita lupa mengecek return atau flag yang diberikan oleh SO:\n\nclass PaymentsController < ApplicationController\n  def create\n    ChargePayment.call\n    redirect_to report_path, notice: 'Failed to charge please try again' \n  end\nend\n\n\nHal ini bisa saja terjadi, mungkin anda mengerjakan task ini sedang pada deadline, atau ada programmer baru yang belum familiar dengan domain aplikasinya.\nDenga kode yang seperti ini user akan mendapat informasi yang salah, dan hal tersebut tidak ada error atau tidak terditeksi, sehingga ketika user menggunakan aplikasi ini untuk menjual produknya, akan ada kemungkinan banyak produknya yang sudah terdistribusi ke customer atau clientnya tanpa adanya balance masuk ke akun user, this is so sad to the user.\nMaka daripada itu lebih baik user melihat pesan aplikasi error daripada informasi yang salah.\nHow to do validation things\nSO bisa saja menggunakan input dari JSON request body, atau dari form input yang keduanya bisa diinput oleh user. Dan kita tidak boleh mempercaya input yang diinput oleh user begitu saja, karna user bisa saja menginput sesuatu yang salah secara tidak sengaja maupun sengaja.\nMaka SO perlu adanya logic untuk memvalidasi bahwa input yang dinput sudah benar atau belum. Jika belum kita bisa memberikan pesan error untuk user membenarkannya, namun jika benar kita bisa memproses input itu lebih lanjut.\nMungkin logicnya bisa seperti ini:\n\ndef call?\n  unless valid?(params)\n    raise Error, \"The input was invalid!\"\n  end\n  # the actual process goes here.\nend\n\nprivate\n\ndef valid?(params)\n\n\nHal ini bagus, dan cukup common, beberapa komunitas yang saya respect seperti dry.rb juga menggunakan implementasi yang serupa.\nTapi issue yang terjadi pada hal ini adalah validation #valid? menjadi private method dan tidak reuseable, ketika ada params yang serupa ingin dipakai ditempat lain, anda perlu melakukan ekstraksi logic validasinya terlebih dahulu ke kelas atau object baru, atau bahkan anda melakukan duplikasi kode implementasinya.\nSolusi atas masalah ini adalah “Parse, don’t validate”, tulisan yang sangat menarik ditulis oleh Alexis King.\nDengan solusi ini kita bisa mengubah kode kita menjadi seperti ini:\n\n# app/services/charge_payment.rb\nclass ChargePayment\n  Error = Class.new(StandardError)\n\n  def initialize(charge_params)\n    charge_params = charge_params\n  end\n\n  def call\n    # do the actual process in here\n  end\nend\n\n# app/controllers/charge_controller.rb\nclass ChargeController < ApplicationService\n  def create\n    ChargePayment.call(charge_params)\n    redirect_to report_path, notice: 'Charge payment was successfully'\n  rescue ChargePayment::Error, ChargeParams::ParserError => e\n    redirect_to report_path, notice: e.message\n  end\n  \n  private\n  \n  def charge_params\n    ChargeParams.parse(form_params)\n  end\nend\n\n# app/models/charge_params.rb\nclass ChargeParams\n  ParserError = Class.new(StandardError)\n\n  def initialize(params); end\n\n  # Public: Parse and validate the params\n  # Returns ChargeParams or ParserError\n  def self.parse(); end\n  def to_hash; end\nend\n\n\nKita membuat sebuah object atau intelegent data structure yang bernama ChargeParams  setidaknya pada object ini memiliki dua tanggung jawab:\n1) Melakukan validasi, jika diinput misalnya user memasukan email, dan email tersebut tidak sesuai format pake object ini akan melakukan raise ChargeParams::ParserError dengan pesan “email is invalid format”\n2) Melakukan transformasi data structure, dari unstructured menjadi structured. Yaitu yang menjadi tujuan atau definisi dari sebuah #parse . Karna terkadang input yang diinput sama user yang bisa melalui API dan form di web tidak sama dengan input yang diperlukan oleh SO. Contohnya kita ingin membuat fitur input buku baru ke koleksi spesific user, dari API input yang diberikan client structurenya seperti ini:\n\n{ user_name: \"pquest\", book_name: \"Hello World\", status: \"read\" }\n\n\nMungkin di service kita ingin structurenya seperti ini, karna yang kita perlu adalah id user dan id book.\n\n{ user_id: 125, book_id: 125, status: \"read\" }\n\n\nJika kita implementasi dengan #valid? maka kita perlu membuatnya seperti ini:\n\nclass AddUserBookCollection\n  def initialize(params); end\n\n  def call\n    raise Error unless valid?\n\n    user_collection_params = build_user_collection_params\n    UserCollection.create!(user_collection_params)\n  end\nend\n\nAddUserBookCollection.call(params)\n\n\nNamun jika menggunakan #parse kita membuatnya seperti ini:\n\nclass AddUserBookCollection\n  def initialize(user_collection_params); end\n  def call\n    UserCollection.create!(user_collection_params.to_hash)\n  end\nend\n\nclass UserCollectionParams\n  ## \nend\n\nuser_collection_params = UserColectionParams.parse(params)\nAddUserBookCollection.call(user_collection_params)\n\n\nMembuat kode SO menjadi lebih ringan, kita hanya care dengan data structure yang sudah kita define sebelumnya. Membuat SO menjadi mudah untuk dipakai ditempat yang lain, ketika ada structure input baru, kita hanya perlu update object parser kita untuk support hal tersebut, kode SO masih tetap sama.\nValidation juga menjadi sebuah public yang dapat mudah untuk digunakan ditempat lain, plus parser dan validation juga menjadi kesatuan dimana tidak ada kata lupa melakukan validasi saat melakukan parser dimana hal ini mungkin terjadi jika kita menggunakan valid? .\nSalah satu kalimat yang menarik yang ditulis terkait hal ini oleh Alexis King adalah:\nLet your datatypes inform your code, don’t let your code control your datatypes.\nHal ini juga lebih baik lagi jika di implement pada type programming language, karna pada Ruby hal ini masih memungkinkan client tidak melakukan parser terlebih dahulu ketika menggunakan SO-nya.\nKita bisa solve masalah ini dengan menggunakan hal ini:\n\n def call\n   raise ArgumentError unless user_collection_params.is_a?(UserCollectionParams)\n\n   UserCollection.create!(user_collection_params)\n end\n\n\nBut this is too ashamed, I’m kinda against with this approach.\nBut, hey do you know ActiveRecord::Validations?\nYa, saya tau hal tersebut exist, dan saya masih menggunakannya saat ini, jika anda possible untuk menggunakan hal tersebut silahkan gunakan itu, ParserObject digunakan hanya ketika anda membuat pure validation pada SO anda, bukan pada ActiveRecordValidations.\nJadi pada contoh diatas jika ada kebutuhan baru, yaitu untuk menambah validasi user dimana user tidak boleh menambahkan koleksi lebih dari 3 buku. Anda bisa menulisnya seperti ini:\n\nclass AddUserBookCollection\n  Error = Class.new(StandardError)\n\n  def initialize(user_collection_params); end\n\n  def call\n    UserCollection.create!(user_collection_params.to_hash)\n  rescue ActiveRecord::RecordInvalid => e\n    raise Error, e.message\n  end\nend\n\nclass UserCollection < ApplicationRecord\n  validate :user_collections_maximum_three_books\nend\n\n\nValidasi Parser hanya sebatas the presence of input params, sedangkan tambahan validasi bisa ditaro di dalam modelnya.\nBahkan tidak perlu parser lagi jika memang input juga sudah sesuai structure atau validasi bisa ditaro di dalam model.\nBut i hope you got the point, the parser just needed when you write pure validation in SO, if you don’t write the validation method in SO, you probably don’t need the parser object, it means just use the Active Record Validations.\nMungkin contoh yang lebih make sense untuk penggunaan Parser adalah seperti input untuk bulk import, dimana model validation tidak dapat digunakan untuk case yang seperti ini, dan structure yang di input sama user berbeda dengan structure yang diekspektasikan oleh SO.\nApakah ada solusi alternative?\nMungkin hal yang menarik lainnya terkait pattern ini adalah banyak programmer-programmer handal yang tidak suka dengan approach ini. Seperti Avdi Grimm, Xavier Noria, even DHH was in this position 😂\nOrang-orang tersebut memiliki alasan yang sama, yaitu tidak suka dengan API yang dihasilkan oleh service object. Daripada membuat API seperti ini: InvoiceServices::Charge.call(params) lebih baik invoice.charge(params) begitu juga daripada membuat PayrollServices::GenerateReport.call lebih baik payroll.report.generate_pdf dalam hal ini invoice dan payroll adalah instance yang dibuat oleh Model.\nMereka percaya bahwa fat models sebuah term yang kita anggap sebuah masalah pada codebase, bagi mereka itu bukanlah sebuah masalah. Khususnya pada bahasa Ruby, dimana kita bisa dilihat di standard library yang ditulis oleh Ruby core team, kelas-kelasnya memiliki banyak sekali methods, even kelas-kelas primitive seperti String, Array, dan Hash juga memiliki banyak sekali methods.\nBegitu juga dengan Rails, ActiveRecord::Base, ActionController::Base dan kelas-kelas lain memiliki banyak sekali methods, dan kita tidak anggap itu sebuah kekurangan, malah bisa dibilang itu sebuah kelebihan karena dengan API tersebut kita bisa menulis kode dengan lebih sedikit dan lebih menyenangkan.\nBerbeda mungkin dengan Java dimana untuk membuat sebuah program console anda harus bekerja dengan beberapa kelas berbeda contohnya seperti Scanner, System.out, System.in atau Buffer, dll, yang dimana pada Ruby mungkin anda hanya perlu satu kelas dan semua method sudah tersedia disana.\nKode yang dihasilkanpun akan berbeda yang dimana kode di Ruby menjadi lebih sedikit dibandingkan dengan kode yang ditulis menggunakan Java in most cases. Tapi bukan berarti Ruby lebih baik dari Java atau sebaliknya, namun kembali lagi ke filosofi atau tujuan dari bahasa pemrograman masing-masing, di Java mungkin mereka lebih peduli ke performance yang dimana mereka ingin setiap object memiliki method yang sedikit agar lebih ringan ketika di load, sedangkan Ruby lebih peduli ke programmer yang mereka ingin programmer lebih mudah menulis kodenya.\nNamun secara pribadi saya tidak berangapan bahwa SO sepenuhkan salah atau bahkan Anti Pattern, karena untuk menulis kode atau mendesain API pada Model memerlukan pemahaman dengan Design Object baik secara teknikal maupun secara teori, jadi sangat-sangat memungkinkan untuk programmer dengan menulis API yang tidak ciamik.\nMaka, SO come to the rescue yang saya yakini sangat sulit untuk menulis kode yang salah karena ada standard dan API yang sangat sedikit karna hanya boleh memiliki satu public method saja, sehingga kita bisa make sure bahwa kode lebih mudah dipelihara karena object juga relative kecil-kecil.\nWalaupun memiliki kekurangan yaitu pada design API, sehingga kurang enak untuk dipakai, dan juga membuat programmer kurang creative, karna hal yang ia bisa design hanyalah nama kelas SO-nya saja, tidak ada yang lain.\nNamun mungkin terkait hal ini (alternative solution) yang membuat SO menjadi Model bisa saya bikin postingan baru agar bisa diobrolin lebih detail.\nTerima kasih, saya rasa itu sudah cukup untuk membahas tentang mendesain Service Object. Desain ini bukanlah sebuah Best Practice, namun hanyalah preferensi saja, masih banyak kekurangan dan hal-hal yang mungkin belum dicover.\nSo, happy hacking!","tags":"","media":"web","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-12T13:13:00","created_at":"2021-08-12T18:11:36.133099","updated_at":"2021-08-12T18:11:36.133099","deleted_at":null,"source_id":59,"contributor":"Philip Lambok"},{"id":2874,"title":"🌱 Ebook gratis untuk belajar bahasa-bahasa pemrograman","url":"https://github.com/fransallen/awesome.id#books","body":"Daftar ebook gratis untuk belajar bahasa-bahasa pemrograman dari Awesome Indonesia list.","tags":"ebook, belajar, gratis","media":"web","thumbnail":"https://opengraph.githubassets.com/948c776c464898ff7fe7376d829579ba6238db8cff044a4b34cb137e284c677b/fransallen/awesome.id","owner":"@fransallen","draft":false,"original_published_at":"2021-08-12T11:22:11.225","created_at":"2021-08-12T11:32:27.492735","updated_at":"2021-08-12T11:32:27.492735","deleted_at":null,"source_id":null,"contributor":"@fransallen"},{"id":2882,"title":"Node Bindings di sebuah kulit kacang (nutshell)","url":"https://www.evilfactorylabs.org/fncolon/node-bindings-di-sebuah-kulit-kacang-nutshell-32kb","body":"Perkenalan\n\n\nNampilin hello world dari C++ ke Javascript aja udah seneng = Node Bindings.\nBindings adalah proses dimana kita menggunakan library bahasa pemrograman lain di bahasa pemrograman yang kita gunakan, tujuannya supaya library yang bisa digunakan di bahasa pemrograman A bisa digunakan di bahasa pemrograman B.\nJavascript dibangun menggunakan V8 Engine, dimana V8 Engine ditulis menggunakan bahasa C++, C++ inilah yang memberi koneksi dan memberi support Event Loop yang didalamnya memiliki Asynchronous I/O untuk Javascript melalui library yang bernama libuv yang ditulis menggunakan C, selain itu fungsi filesystem seperti core module fs juga ditulis menggunakan C++ di Node.js.\nAda juga socket dan http yang sama sama dibuat menggunakan C++ di Node.js, karena Javascript by default tidak tau bagaimana menghandle filesystem, alasannya adalah tujuan awal Javascript adalah membuat website menjadi lebih interaktif (e.g menggunakan DOM) yang digunakan di browser, karena security, tidak mungkin juga browser memperbolehkan filesystem access pada setiap website menggunakan Javascript (sebelum node.js menyerang), socket maupun http, maka dari itu browser (serta node.js) menggunakan bindings yang dibuat menggunakan c++ karena dapat memberi perintah langsung kepada sistem (system call).\nSalah satu open source Javascript yang menggunakan node bindings adalah sqlite3 https://github.com/mapbox/node-sqlite3, node bindings sangat membantu sekali untuk membuat library\" yang keren dari C++ dapat digunakan di Javascript, ini adalah salah satu alasan penulis belajar node bindings, meskipun ujungnya harus belajar C++ dari awal lagi haha :').\nNode bindings memiliki build tools juga (ibaratnya seperti webpack untuk frontend assets) yaitu node-gyp, node-gyp ini berguna untuk mengcompile API native addons untuk Node.js (seperti yang saya tampilkan di video disini) seperti N-API yang sekarang berganti nama menjadi Node-API, jika kamu tidak ingin mengurus NODE_MODULE_VERSION (ABI version number dari Node.js) bisa menggunakan nan, dimana disediakan abstraksi yang sudah diisi logic untuk tidak perlu lagi mengurus NODE_MODULE_VERSION dari Node.js.\nYuk yang mau belajar c++ dan rust dengan gaya, yuk bisa dicoba node bindings ini.","tags":"nodejs,bindings,cpp,javascript","media":"tulisan","thumbnail":null,"owner":"fnc","draft":false,"original_published_at":"2021-08-12T09:10:17","created_at":"2021-08-12T12:15:46.856265","updated_at":"2021-08-12T12:15:46.856265","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2881,"title":"BELAJAR OPEN API (BAHASA INDONESIA)","url":"https://www.youtube.com/watch?v=o5b6TYSNK5c","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-12T05:00:11","created_at":"2021-08-12T12:15:41.498718","updated_at":"2021-08-12T12:15:41.498718","deleted_at":null,"source_id":61,"contributor":"pulodev"},{"id":2865,"title":"Strategi Memajukan Pendidikan ala Pahamify ft Rousyan | Podcast Ngobrolin Startup","url":"https://www.youtube.com/watch?v=3imzALyj-RE","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-11T09:00:11","created_at":"2021-08-08T18:11:17.990627","updated_at":"2021-08-08T18:11:17.990627","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2880,"title":"Unit Test di Elixir - Tutorial Singkat","url":"https://www.youtube.com/watch?v=aE9MbD6PNKE","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-11T09:00:00","created_at":"2021-08-12T12:15:33.841621","updated_at":"2021-08-12T12:15:33.841621","deleted_at":null,"source_id":72,"contributor":"Riza Fahmi"},{"id":2871,"title":"Eps. 56 - Strategi Memajukan Pendidikan ala Pahamify","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--56---Strategi-Memajukan-Pendidikan-ala-Pahamify-e15k0h9","body":"Sebenernya apa yang masih belum pas dengan pendidikan kita? Gimana pahamify bisa berperan utk menyelesaikan masalah pendidikan yg njelimet ini? Yuk simak!\n\n--- \n\nSend in a voice message: https://anchor.fm/ngobrolinstartup/message\nSupport this podcast: https://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-08-11T09:00:00","created_at":"2021-08-11T12:15:26.63008","updated_at":"2021-08-11T12:15:26.63008","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2852,"title":"Membuat Backend Sistem Notifikasi Saweria dengan Server Sent Event (SSE) dan Google Cloud Pub/Sub","url":"https://www.youtube.com/watch?v=9RMS4Y0xXa4","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-11T07:11:39","created_at":"2021-08-03T00:37:24.452288","updated_at":"2021-08-03T00:37:24.452288","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2870,"title":"How Monika Saved Me from Unnoticed Server Errors","url":"https://medium.com/hyperjump-tech/how-monika-saved-me-from-unnoticed-server-errors-243e97f35edd?source=rss----fabfd42372dc---4","body":null,"tags":"software-engineering,devops,monitoring,software,javascript","media":"tulisan","thumbnail":null,"owner":"Denny Pradipta","draft":false,"original_published_at":"2021-08-10T03:37:30","created_at":"2021-08-11T12:15:22.819478","updated_at":"2021-08-11T12:15:22.819478","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2866,"title":"Pengantar Kalkulus Lambda","url":"https://www.evilfactorylabs.org/artileda/pengantar-kalkulus-lambda-90e","body":"Kalkulus Lambda adalah model komputasi yang berlandaskan prinsip fungsi M-chan (Matematika-chan), pertama kali di kemukakan oleh Alonzo Church pada awal 1930-an yang menjadi bagian penelitian beliau dalam pembuktian formal dasar matematika.\nModel komputasi merupakan kerangka kerja yang menjelaskan apa yang  dilakukan sebuah fungsi / algoritme dalam menghasilkan nilai keluaran dari sebuah nilai masukan.\nKetika kita menerima nilai masukan 4, Bagaimana kita menghasilkan 6 ?\nlet y = (x) => x + 2\n\ny(4)\n\natau juga\nlet y = (x) => x + (x/2)\n\ny(4)\n\nFenomena banyak cara untuk memenuhi syarat nilai masukan dan keluaran ini disebut dengan undecidability.\nBagaimana bentuknya dalam kalkulus lambda ?\nλx.(+ x 2) 4 = (+ 4 2) = 6\n\nPenulisan notasi dengan operator pada awal operasi disebut notasi prefiks. \nNotasi tersebut sama saja dengan\nλx.(x + 2) 4 = (4 + 2) = 6\n\nKalkulus lambda salah satu model komputasi fungsional, fungsional berarti komputasi disusun oleh set dan fungsi matematika.\nKalkulus Lambda memiliki 3 ekspresi:\nE := x \n  | E1.E2\n  | λx.E1\n\nx , Variable\nE1.E2 , Aplikasi Fungsi\nλx.E1 , Abstraksi Fungsi\nRupa kode dalam bentuk tipe data.\ntype rec e = \n  | Variabel(int)\n  | Aplikasi(e,e) \n  | Abstraksi(int,e)\n\nVariable adalah nilai bilangan, seperti 1,2,3 dan seterusnya.\nAbstraksi fungsi adalah cara kita membuat suatu fungsi.\nλ(parameter).(badan fungsi)\n\nλx.E1\n\nλx, notasi melambangkan bagaimana kita membuat sebuah fungsi dengan parameter x.\n\n\nE1, eksprsi dari kalkulus lambda\n\n\n\nContoh\nλx. (+ (* x 2) x)\n\nλy. (- y 2)\n\nDalam bentuk kode\nlet f1 = (x) => (x * 2) + x\n\nlet f2 = (y) => y - 2\n\nAplikasi fungsi bagaimana kita menggunakan fungsi terhadap sesuatu nilai masuka atau ekspresi.\nλx. (+ (* x 2) x) 4 \n= (+ (* 4 2) 4)\n= ( + 8 4 )\n= 12\n\nFungsi λx. (+ (* x 2) x) diberikan masukan 4.\n\n\nParameter x dan variabel x pada badan fungsi di ganti dengan 4 dan λx dihapus karena x sudah terganti, sehingga menghasilkan (+ (* 4 2) 4).\n\n\nKita operasikan dari kurung terdalam yaitu (* 4 2) menjadi ( + 8 4 ) dan dilanjutkan sehingga menghasilkan 12.\n\n\n\nRupa dalam bentuk kode\nlet f = (x) => (x * 2) + x\n\nf(4) // 12\n\nλa.(* a a) . λx.(+ x 3) . 4\n\nKita punya sebuah fungsi berparameter a dengan isi (* a a) dan diaplikasikan dengan (+ x 3) dan 4 ?\nλa. (* a a) (+ x 3) 4\n= (* (λx.(+ x 3)) (λx.(+ x 3)) 4\n= (* (+ 4 3) (+ 4 3))\n= (* 12 12)\n= 144\n\nBila ditulis dalam bentuk kode\nlet fa = (a) => (a * a)\n\nlet fx = (x) => x + 3\n\nfa(fx(4)) // 144\n\nSekian dari tulisan ini semoga cukup memanaskan kepala and. Apabila penjelasan saya kurang dapat di mengerti, semoga video dibawah ini bisa membantu\n#1 Pengantar | Kalkulus Lambda, Idiosemantik\nTerima kasih.","tags":"teorikomputasi,rescript","media":"tulisan","thumbnail":null,"owner":"▲Engelstrassen","draft":false,"original_published_at":"2021-08-08T18:09:50","created_at":"2021-08-08T18:11:45.275497","updated_at":"2021-08-08T18:11:45.275497","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2863,"title":"Pengenalan Program Komputer","url":"https://gadiskoding.my.id/pengenalan-program-komputer.html","body":"Apa sih itu program dan berbagai seluk beluk lainya.","tags":"pemrograman dasar","media":"tulisan","thumbnail":"/images/og.png","owner":"Gadis Koding","draft":false,"original_published_at":"2021-08-08T12:09:12.761","created_at":"2021-08-08T12:09:33.276989","updated_at":"2021-08-08T12:09:33.276989","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2862,"title":"Belajar Test Driven Development","url":"https://anchor.fm/deep-tech/episodes/Belajar-Test-Driven-Development-e15k33f","body":"Dalam proses pengembangan software, seringkali requirements selalu berubah mengikuti kebutuhan. Hal ini menyebabkan timbulnya beberapa masalah teknis seperti bugs. Bahkan menyangkut psikologis, misalnya developer jadi nggak percaya diri untuk mengembangkan fitur karena takut aplikasi akan break.\nMakanya, developer membutuhkan automated test untuk mengecek baris kode. Namun ada cara terbaik dalam penerapan automated test ini yaitu dengan Test Driven Developmet atau biasa disingkat TDD. Yuk belajar lebih dalam mengenai TDD bersama Resi Respati, Senior Front End di Kata dot ai.","tags":"","media":"podcast","thumbnail":null,"owner":"deep tech foundation","draft":false,"original_published_at":"2021-08-08T04:54:12","created_at":"2021-08-08T06:11:31.015908","updated_at":"2021-08-08T06:11:31.015908","deleted_at":null,"source_id":4,"contributor":"hilmanski"},{"id":2861,"title":"🚀 Coming soon: BlobCDN","url":"https://upset.dev/blobcdn","body":"The CDN for beautiful SVG shapes. Dapatkan early access!","tags":"cdn, svg, blob, design","media":"web","thumbnail":"https://ph-files.imgix.net/70013e6c-c741-484f-9ffb-81be950bd278.png?auto=format","owner":"@fransallen","draft":false,"original_published_at":"2021-08-07T22:58:55.804","created_at":"2021-08-07T23:02:30.855274","updated_at":"2021-08-07T23:02:30.855274","deleted_at":null,"source_id":null,"contributor":"@fransallen"},{"id":2859,"title":"GitHub - artileda/pemrograman-fungsional: Repo berisi sumber dan referensi belajar pemrograman fungsional","url":"https://github.com/artileda/pemrograman-fungsional","body":"Repo berisi sumber dan referensi belajar pemrograman fungsional - GitHub - artileda/pemrograman-fungsional: Repo berisi sumber dan referensi belajar pemrograman fungsional","tags":"pemrograman fungsional","media":"web","thumbnail":"https://opengraph.githubassets.com/244780da8de2db5d675f2932ee5432132a1994f3b47cba4c11af885eefdc38f7/artileda/pemrograman-fungsional","owner":"@artileda","draft":false,"original_published_at":"2021-08-07T18:02:07.714","created_at":"2021-08-07T18:02:49.130657","updated_at":"2021-08-07T18:02:49.130657","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2860,"title":"Strategi Memajukan Pendidikan ala Pahamify ft. Rousyan, CEO Pahamify | Teaser Ngobrolin Startup","url":"https://www.youtube.com/watch?v=H8x0Z4uCTnY","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-07T16:49:30","created_at":"2021-08-07T18:11:04.439352","updated_at":"2021-08-07T18:11:04.439352","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2883,"title":"Frontend - Situs KPU Mahasiswa STKIP Muhammadiyah Kuningan","url":"https://rahmatagungjulians.tech//blog/frontend-kpu-stkip","body":"Apa yang harus dipakai? Javascript atau Python, disini saya akan membahas mengenai pembuatan frontend untuk situs KPU Mahasiswa STKIP Muhammadiyah Kuningan.","tags":"breakdown","media":"web","thumbnail":null,"owner":"rahmatagungj@gmail.com (Rahmat Agung Julians)","draft":false,"original_published_at":"2021-08-07T00:00:00","created_at":"2021-08-12T12:15:47.881517","updated_at":"2021-08-12T12:15:47.881517","deleted_at":null,"source_id":73,"contributor":"Rahmat Agung Julians"}],"total":1374}