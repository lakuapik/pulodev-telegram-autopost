{"data":[{"id":2867,"title":"Netlify sebagai Pemendek Tautan","url":"https://opakholis.dev/blog/shortener","body":"Menjadikan Netlify Redirects sebagai layanan URL Shortener pribadi","tags":"netlify, shortener","media":"tulisan","thumbnail":"https://opakholis.dev/static/images/shortener/banner.jpg","owner":"Opa Kholis Majid","draft":false,"original_published_at":"2021-10-08T00:00:00","created_at":"2021-08-10T17:14:44.442527","updated_at":"2021-08-10T17:14:44.442527","deleted_at":null,"source_id":null,"contributor":"opxop"},{"id":2885,"title":"Service Object","url":"philiplambok.github.io/service-object,/rails/2021/08/12/service-object.html","body":"Hello!\nSebenernya ditulisan sebelumnya saya udah mau commit buat mau mulai nulis pake bahasa inggris di blog ini, tapi baru sadar, kalo blog ini udah saya submit di pulo.dev, yang dimana ekpektasi konten-konten disana itu berbahasa indonesia.\nDitambah gk ada alasan tertentu tulisan-tulisan saya harus berbahasa inggris karna kebanyakan terinspirasi dari tulisan-tulisan luar (inggris) üôÇ, jadi saya balik lagi buat nulis pakai bahasa indo saja ya.\nOke, mari kita mulai saja.\nTulisan ini saya buat scopenya saja, agar batasannya bisa lebih jelas dan bisa membantu saya agar tidak lari kemana-mana üòÇ\nApa itu Service Object (SO), dan masalah apa yang ingin dicoba untuk diselesaikan?\nDesign yang seperti apa yang bagus untuk di implement?\nApakah ada solusi alternative?\nApa itu Service Object, dan masalah apa yang ingin dicoba untuk diselesaikan?\nPertama kali saya menulis kode Service Object¬†(SO) mungkin di akhir tahun 2018, ketika saya baru pertama kali menulis kode dengan dibayar oleh uang, yups it‚Äôs my first job.\nWaktu itu saya menganggap Service Object adalah layer baru di dalam Rails, terinspirasi dari buku ini, dimana dia berada diantara Model dan Controller.\nKode-kode SO adalah plain ruby object yang digunakan untuk menghandle logic bisnis pada aplikasi, sedangkan Model digunakan oleh service untuk membuat versi SQL dari hasil logic yang dihasilkan, dan Controller untuk mem-forward hasil logic (SO) ke user.\nKita bisa contohkan penggunaannya dengan seperti ini, misalkan kita berada di perusahaan online shop, dan kita diminta untuk membuat fitur order invoice.\n\n# app/services/create_order_invoice.rb\nclass CreateOrderInvoice\n  def initialize(params); end\n\n  def perform\n    tax = calculate_tax\n    total_invoice = calculate_total_invoice(tax)\n    order_invoice = OrderInvoice.create(create_order_invoice)\n    send_email_order_invoice(order_invoice)\n  end\nend\n\n# app/controllers/order_invoice_controller.rb\nclass OrderInvoiceController < ApplicationController\n  def create\n    CreateOrderInvoice.new(params).perform\n    redirect_to invoice_path, notice: 'Your order has been successfully added'\n  end\nend\n\n# app/models/order_invoice.rb\nclass OrderInvoice < ApplicationRecord; end\n\n\nDaripada kita membuat kode perhitungan pajak, total amount dari invoice, membuat record order invoice, dan mengirim email order invoice pada controller atau model, lebih baik kita membuat object¬†atau kelas khusus untuk menghandle hal tersebut yang membuat controller dan model kita tetep kurus.\nBenefit lain, kode jadi lebih mudah dibaca dan dipelihara, ketika model dan controller mulai berkembang, kode SO jadi lebih mudah diubah, karna perhintungan kalkulasinya hanya bisa diakses oleh SO, tidak bisa diakses di Model dan Controller sehingga kita tidak perlu khawatir dengan backward compatibility dan breaking changes, asal public methodnya #perfom tetap perform sesuai ekspektasi.\nDesign yang seperti apa yang bagus untuk di implement?\nOk, saya harap anda sudah paham benefit apa yang dapat dihasilkan dengan mengimplement SO. Sekarang mari lanjut untuk membahas bagaimana cara mendesain interfacenya, karna menurut pengalaman saya belum ada standard yang jelas tentang interfacenya.\nKhususnya pada memberikan nama public methodnya. Pertama kali saya menulis kode SO yaitu dengan memberi nama #perform mengukuti codebase yang sudah ada pada saat itu.\nMungkin make sense memberi nama #perform yang mungkin menurut saya mereka mengikuti standard yang diberikan Sidekiq, karna secara implementasi SO mirip seperti worker, karena pada sidekiq, sebuah kelas worker hanya boleh memiliki satu tujuan saja, kita tidak bisa dimungkinkan untuk memiliki sebuah kelas worker yang bisa memiliki dua tanggung jawab.\nTapi secara implementasi SO berbeda dengan worker, SO (in most cases) juga tidak akan jalan di background job, mereka memberikan hasil yang hasilnya akan diperlukan oleh client pemanggilnya, berbeda dengan worker dimana pemanggilnya tidak memerlukan hasil atau return dari worker yang ia panggil.\nInterface lain yang salah lihat adalah #execute, make sense juga, mereka mengikuti naming dari Command pattern, yang sudah populer, dimana yang mungkin saya yakini service object terinspirasi dari design pattern tersebut.\nBut, let me tell you a secret, most of the time SO not working with commands things.\nBerbeda dengan command pattern CopyCommand, CutCommand dimana antara satu object dan object lainnya sangat dimungkinkan dipanggil oleh satu client yang sama, pada SO biasanya objectnya langsung dipanggil oleh client, dalam arti lain, sangat jarang ada SO yang saling berkaitan sehingga dipanggil oleh client yang sama.\nPada SO kita bisa saja memiliki kelas dengan nama CreateOrderInvoice dan UpdateUserRole dimana keduanya sama sekali berbeda.\nInterface lainnya adalah #call. Ruby juga implement ini di core mereka yang memungkinkan term Object as Function. Salah satu term yang sangat cocok bagi service object menurut saya dibandingkan Command pattern.\nSeperti definisi yang sebelumnya kita sudah bahas, bahwa SO adalah tempat dimana business logic pada aplikasi berada, kita bisa menamainya dengan nama tiket Jira yang di assign ke kita seperti GeneratePayrollReport , ChargeInvoice, SendEmailToCustomer, dll.\nDan secara implementasi object-object tersebut sangat mirip dengan function, kita tidak memiliki property, ataupun behavior layaknya pada object pada umumnya, karena SO hanya boleh memiliki satu instance method saja yaitu #call.\nObject as Function di Ruby seperti ini:\n\nclass Hello\n  def call(name)\n    puts \"Hello, #{name}\"\n  end\nend\n\nHello.new.('kotori') #> \"Hello, kotori\"\n\n\nSekarang kelas Hello diakses layaknya function di Ruby, seperti yang kita inginkan.\nAPI Design\nSetelah membahas background tentang belum adanya standard yang jelas tentang API design, khususnya pada penamaan public API. Sekarang waktunya untuk membuat standard versi kita.\nSeperti yang sudah dibahas sebelumnya, SO hanya boleh memiliki satu public method saja, karena kita akan mengadopsi philosophy Object as Function, untuk kontraknya seperti ini:\n\n# app/services/charge_payment.rb\nclass ChargePayment < ApplicationService\n  Error = Class.new(StandardError)\n\n  def initialize(invoice); end\n  # Public: Handle charge payment to the Invoice\n  # Returns Invoice\n  def call\n    # charge invoice logic goes in here\n  end\nend\n\n# app/services/application_service.rb\nclass ApplicationService\n  def call(...)\n    new(...).call\n  end\nend\n\n# how the service object was called\nChargePayment.call(invoice)\n\n\nSetiap SO inherit ke ApplicationService dimana kelas tersebut berfungsi untuk mendelegasikan .call menjadi #call . Jadi kita bisa memanggilnya dengan lebih mudah\n\n# instead of \nChargePayment.new.call(invoice)\n# or \nChargePayment.new.(invoice)\n\n# we could call like this\nChargePayment.call(invoice)\n\n\nSetiap SO boleh mengembalikan object apapun tanpa batasan, bahkan objectnya sendiri walaupun saya belum pernah mendapat case yang seperti ini. Namun satu hal yang tidak boleh adalah memiliki method lain selain #call, maupun property baik itu dibuat oleh generator seperti attr_reader maupun attr_accessor.\nJika anda ingin mengembalikan object atau value yang lebih dari satu, saya prefer untuk menggunakan Hash, atau OpenStruct, misalnya seperti ini:\n\nclass GeneratePayrollReport\n  def call\n    OpenStruct.new(account_number: account_number, total_transfer: total_transfer)\n  end\nend\n\n# or \nclass GeneratePayrollReport\n  def call\n    { account_number; account_number, total_transfer: total_transfer }\n  end\nend\n\n\nKetika aplikasi semakin besar (fiturnya makin banyak), maka kelas service pun jadi makin banyak juga, karna setiap Jira issue yang dibuat adalah kandidat yang bagus untuk menjadi SO.\nAlangkah lebih bagus kelas-kelas ini kita organisir lagi berdasarkan scope atau domainnya agar lebih rapih, kita bisa organisir menjadi seperti ini:\n\nPayrollServices::GeneratePdfReport\nPayrollServices::TransferTheMoney\nInvoiceServices::MakeItExpired\nInoviceServices::GeneratePdfReport\n\n\nDibandingkan keempat kelas itu flat (tanpa module) lebih baik kita organisir agar lebih rapih, benefit lain, penamaan kelas juga jadi tidak bentrok untuk kelas-kelas yang memiliki tujuan yang mirip, seperti GeneratePdfReport, Karena kita menempati mereka di module yang berbeda.\nUntuk naming convention-nya anda bisa buat DomainNameServices, untuk DomainName diusahakan singular jadi dibuat seperti ini: PayrollServices bukan PayrollsService atau PayrollsServices.\nError handling\nKita tidak bisa memastikan semua SO akan berjalan mulus tanpa ada hambatan atau rintangan, contohnya pada PayrollServices::TransferTheMoney mungkin saja bisa gagal perform karena ada network error pada bank API, atau nomor rekening karwayannya salah, begitu juga dengan InvoiceServices::MakeItExpired bisa saja ada gagal ketika melakukan SQL query update ke database, dan sebagainya.\nPada handle error di SO saya merekomendasikan untuk menggunakan filosofi fail-closed design by default. Pada filosofi ini kita akan melakukan raise Exception kelas ketika kita mendapatkan bahwa kelas tidak perform dengan benar dan kita memberhentikan processnya dengan paksa.\nContohnya seperti ini:\n\nclass ChargePayment\n  Error = Class.new(StandardError)\n\n  def call\n    raise Error, 'Failed to charge please try again',  if something_wrong?\n  end\nend\n\nclass PaymentsController < ApplicationController\n  def create\n    ChargePayment.call \n    redirect_to report_path, notice: \"Charge payment was successfully\"\n  rescue ChargePayment::Error => e\n    redirect_to report_path, notice: e.message\n  end\nend\n\n\nJadi ketika kita gagal melakukan, melakukan charge stack process akan berhenti di SO dan customer akan ditampilkan pesan error ‚ÄúFailed to charge please try again‚Äù.\nBenefit menggunakan prinsip ini kita tidak akan memberikan miss informasi ke user, contohnya jika kita lupa melakukan rescue terhadap errornya:\n\nclass PaymentsController < ApplicationController\n  def create\n    ChargePayment.call \n    redirect_to report_path, notice: \"Charge payment was successfully\"\n  end\nend\n\n\nAplikasi kita tidak akan akan menampilkan ‚ÄòCharge payment was successfully‚Äô namun internal server error, dan error monitoring akan memberitahukan bahwa ada Exception yang belum di handle pada aplikasi.\nDibandingkan dengan menggunakan fail-open design yang menggunakan flag pada handle errornya:\n\nclass ChargePayment\n  Error = Class.new(StandardError)\n\n  def call\n    return false if something_wrong?\n  end\nend\n\nclass PaymentsController < ApplicationController\n  def create\n    charge_payment = ChargePayment.call\n    if charge_payment.false?\n      redirect_to report_path, notice: 'Failed to charge please try again'\n    else\n      redirect_to report_path, notice: 'Charge payment was successfully'\n    end\n  end\nend\n\n\nKode diatas menggunakan fail-open design yang memungkinkan kita dapat memberikan informasi yang salah kepada user, contohnya jika kita lupa mengecek return atau flag yang diberikan oleh SO:\n\nclass PaymentsController < ApplicationController\n  def create\n    ChargePayment.call\n    redirect_to report_path, notice: 'Failed to charge please try again' \n  end\nend\n\n\nHal ini bisa saja terjadi, mungkin anda mengerjakan task ini sedang pada deadline, atau ada programmer baru yang belum familiar dengan domain aplikasinya.\nDenga kode yang seperti ini user akan mendapat informasi yang salah, dan hal tersebut tidak ada error atau tidak terditeksi, sehingga ketika user menggunakan aplikasi ini untuk menjual produknya, akan ada kemungkinan banyak produknya yang sudah terdistribusi ke customer atau clientnya tanpa adanya balance masuk ke akun user, this is so sad to the user.\nMaka daripada itu lebih baik user melihat pesan aplikasi error daripada informasi yang salah.\nHow to do validation things\nSO bisa saja menggunakan input dari JSON request body, atau dari form input yang keduanya bisa diinput oleh user. Dan kita tidak boleh mempercaya input yang diinput oleh user begitu saja, karna user bisa saja menginput sesuatu yang salah secara tidak sengaja maupun sengaja.\nMaka SO perlu adanya logic untuk memvalidasi bahwa input yang dinput sudah benar atau belum. Jika belum kita bisa memberikan pesan error untuk user membenarkannya, namun jika benar kita bisa memproses input itu lebih lanjut.\nMungkin logicnya bisa seperti ini:\n\ndef call?\n  unless valid?(params)\n    raise Error, \"The input was invalid!\"\n  end\n  # the actual process goes here.\nend\n\nprivate\n\ndef valid?(params)\n\n\nHal ini bagus, dan cukup common, beberapa komunitas yang saya respect seperti dry.rb juga menggunakan implementasi yang serupa.\nTapi issue yang terjadi pada hal ini adalah validation #valid? menjadi private method dan tidak reuseable, ketika ada params yang serupa ingin dipakai ditempat lain, anda perlu melakukan ekstraksi logic validasinya terlebih dahulu ke kelas atau object baru, atau bahkan anda melakukan duplikasi kode implementasinya.\nSolusi atas masalah ini adalah ‚ÄúParse, don‚Äôt validate‚Äù, tulisan yang sangat menarik ditulis oleh Alexis King.\nDengan solusi ini kita bisa mengubah kode kita menjadi seperti ini:\n\n# app/services/charge_payment.rb\nclass ChargePayment\n  Error = Class.new(StandardError)\n\n  def initialize(charge_params)\n    charge_params = charge_params\n  end\n\n  def call\n    # do the actual process in here\n  end\nend\n\n# app/controllers/charge_controller.rb\nclass ChargeController < ApplicationService\n  def create\n    ChargePayment.call(charge_params)\n    redirect_to report_path, notice: 'Charge payment was successfully'\n  rescue ChargePayment::Error, ChargeParams::ParserError => e\n    redirect_to report_path, notice: e.message\n  end\n  \n  private\n  \n  def charge_params\n    ChargeParams.parse(form_params)\n  end\nend\n\n# app/models/charge_params.rb\nclass ChargeParams\n  ParserError = Class.new(StandardError)\n\n  def initialize(params); end\n\n  # Public: Parse and validate the params\n  # Returns ChargeParams or ParserError\n  def self.parse(); end\n  def to_hash; end\nend\n\n\nKita membuat sebuah object atau intelegent data structure yang bernama ChargeParams  setidaknya pada object ini memiliki dua tanggung jawab:\n1) Melakukan validasi, jika diinput misalnya user memasukan email, dan email tersebut tidak sesuai format pake object ini akan melakukan raise ChargeParams::ParserError dengan pesan ‚Äúemail is invalid format‚Äù\n2) Melakukan transformasi data structure, dari unstructured menjadi structured. Yaitu yang menjadi tujuan atau definisi dari sebuah #parse . Karna terkadang input yang diinput sama user yang bisa melalui API dan form di web tidak sama dengan input yang diperlukan oleh SO. Contohnya kita ingin membuat fitur input buku baru ke koleksi spesific user, dari API input yang diberikan client structurenya seperti ini:\n\n{ user_name: \"pquest\", book_name: \"Hello World\", status: \"read\" }\n\n\nMungkin di service kita ingin structurenya seperti ini, karna yang kita perlu adalah id user dan id book.\n\n{ user_id: 125, book_id: 125, status: \"read\" }\n\n\nJika kita implementasi dengan #valid? maka kita perlu membuatnya seperti ini:\n\nclass AddUserBookCollection\n  def initialize(params); end\n\n  def call\n    raise Error unless valid?\n\n    user_collection_params = build_user_collection_params\n    UserCollection.create!(user_collection_params)\n  end\nend\n\nAddUserBookCollection.call(params)\n\n\nNamun jika menggunakan #parse kita membuatnya seperti ini:\n\nclass AddUserBookCollection\n  def initialize(user_collection_params); end\n  def call\n    UserCollection.create!(user_collection_params.to_hash)\n  end\nend\n\nclass UserCollectionParams\n  ## \nend\n\nuser_collection_params = UserColectionParams.parse(params)\nAddUserBookCollection.call(user_collection_params)\n\n\nMembuat kode SO menjadi lebih ringan, kita hanya care dengan data structure yang sudah kita define sebelumnya. Membuat SO menjadi mudah untuk dipakai ditempat yang lain, ketika ada structure input baru, kita hanya perlu update object parser kita untuk support hal tersebut, kode SO masih tetap sama.\nValidation juga menjadi sebuah public yang dapat mudah untuk digunakan ditempat lain, plus parser dan validation juga menjadi kesatuan dimana tidak ada kata lupa melakukan validasi saat melakukan parser dimana hal ini mungkin terjadi jika kita menggunakan valid? .\nSalah satu kalimat yang menarik yang ditulis terkait hal ini oleh Alexis King adalah:\nLet your datatypes inform your code, don‚Äôt let your code control your datatypes.\nHal ini juga lebih baik lagi jika di implement pada type programming language, karna pada Ruby hal ini masih memungkinkan client tidak melakukan parser terlebih dahulu ketika menggunakan SO-nya.\nKita bisa solve masalah ini dengan menggunakan hal ini:\n\n def call\n   raise ArgumentError unless user_collection_params.is_a?(UserCollectionParams)\n\n   UserCollection.create!(user_collection_params)\n end\n\n\nBut this is too ashamed, I‚Äôm kinda against with this approach.\nBut, hey do you know ActiveRecord::Validations?\nYa, saya tau hal tersebut exist, dan saya masih menggunakannya saat ini, jika anda possible untuk menggunakan hal tersebut silahkan gunakan itu, ParserObject digunakan hanya ketika anda membuat pure validation pada SO anda, bukan pada ActiveRecordValidations.\nJadi pada contoh diatas jika ada kebutuhan baru, yaitu untuk menambah validasi user dimana user tidak boleh menambahkan koleksi lebih dari 3 buku. Anda bisa menulisnya seperti ini:\n\nclass AddUserBookCollection\n  Error = Class.new(StandardError)\n\n  def initialize(user_collection_params); end\n\n  def call\n    UserCollection.create!(user_collection_params.to_hash)\n  rescue ActiveRecord::RecordInvalid => e\n    raise Error, e.message\n  end\nend\n\nclass UserCollection < ApplicationRecord\n  validate :user_collections_maximum_three_books\nend\n\n\nValidasi Parser hanya sebatas the presence of input params, sedangkan tambahan validasi bisa ditaro di dalam modelnya.\nBahkan tidak perlu parser lagi jika memang input juga sudah sesuai structure atau validasi bisa ditaro di dalam model.\nBut i hope you got the point, the parser just needed when you write pure validation in SO, if you don‚Äôt write the validation method in SO, you probably don‚Äôt need the parser object, it means just use the Active Record Validations.\nMungkin contoh yang lebih make sense untuk penggunaan Parser adalah seperti input untuk bulk import, dimana model validation tidak dapat digunakan untuk case yang seperti ini, dan structure yang di input sama user berbeda dengan structure yang diekspektasikan oleh SO.\nApakah ada solusi alternative?\nMungkin hal yang menarik lainnya terkait pattern ini adalah banyak programmer-programmer handal yang tidak suka dengan approach ini. Seperti Avdi Grimm, Xavier Noria, even DHH was in this position üòÇ\nOrang-orang tersebut memiliki alasan yang sama, yaitu tidak suka dengan API yang dihasilkan oleh service object. Daripada membuat API seperti ini: InvoiceServices::Charge.call(params) lebih baik invoice.charge(params) begitu juga daripada membuat PayrollServices::GenerateReport.call lebih baik payroll.report.generate_pdf dalam hal ini invoice dan payroll adalah instance yang dibuat oleh Model.\nMereka percaya bahwa fat models sebuah term yang kita anggap sebuah masalah pada codebase, bagi mereka itu bukanlah sebuah masalah. Khususnya pada bahasa Ruby, dimana kita bisa dilihat di standard library yang ditulis oleh Ruby core team, kelas-kelasnya memiliki banyak sekali methods, even kelas-kelas primitive seperti String, Array, dan Hash juga memiliki banyak sekali methods.\nBegitu juga dengan Rails, ActiveRecord::Base, ActionController::Base dan kelas-kelas lain memiliki banyak sekali methods, dan kita tidak anggap itu sebuah kekurangan, malah bisa dibilang itu sebuah kelebihan karena dengan API tersebut kita bisa menulis kode dengan lebih sedikit dan lebih menyenangkan.\nBerbeda mungkin dengan Java dimana untuk membuat sebuah program console anda harus bekerja dengan beberapa kelas berbeda contohnya seperti Scanner, System.out, System.in atau Buffer, dll, yang dimana pada Ruby mungkin anda hanya perlu satu kelas dan semua method sudah tersedia disana.\nKode yang dihasilkanpun akan berbeda yang dimana kode di Ruby menjadi lebih sedikit dibandingkan dengan kode yang ditulis menggunakan Java in most cases. Tapi bukan berarti Ruby lebih baik dari Java atau sebaliknya, namun kembali lagi ke filosofi atau tujuan dari bahasa pemrograman masing-masing, di Java mungkin mereka lebih peduli ke performance yang dimana mereka ingin setiap object memiliki method yang sedikit agar lebih ringan ketika di load, sedangkan Ruby lebih peduli ke programmer yang mereka ingin programmer lebih mudah menulis kodenya.\nNamun secara pribadi saya tidak berangapan bahwa SO sepenuhkan salah atau bahkan Anti Pattern, karena untuk menulis kode atau mendesain API pada Model memerlukan pemahaman dengan Design Object baik secara teknikal maupun secara teori, jadi sangat-sangat memungkinkan untuk programmer dengan menulis API yang tidak ciamik.\nMaka, SO come to the rescue yang saya yakini sangat sulit untuk menulis kode yang salah karena ada standard dan API yang sangat sedikit karna hanya boleh memiliki satu public method saja, sehingga kita bisa make sure bahwa kode lebih mudah dipelihara karena object juga relative kecil-kecil.\nWalaupun memiliki kekurangan yaitu pada design API, sehingga kurang enak untuk dipakai, dan juga membuat programmer kurang creative, karna hal yang ia bisa design hanyalah nama kelas SO-nya saja, tidak ada yang lain.\nNamun mungkin terkait hal ini (alternative solution) yang membuat SO menjadi Model bisa saya bikin postingan baru agar bisa diobrolin lebih detail.\nTerima kasih, saya rasa itu sudah cukup untuk membahas tentang mendesain Service Object. Desain ini bukanlah sebuah Best Practice, namun hanyalah preferensi saja, masih banyak kekurangan dan hal-hal yang mungkin belum dicover.\nSo, happy hacking!","tags":"","media":"web","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-12T13:13:00","created_at":"2021-08-12T18:11:36.133099","updated_at":"2021-08-12T18:11:36.133099","deleted_at":null,"source_id":59,"contributor":"Philip Lambok"},{"id":2874,"title":"üå± Ebook gratis untuk belajar bahasa-bahasa pemrograman","url":"https://github.com/fransallen/awesome.id#books","body":"Daftar ebook gratis untuk belajar bahasa-bahasa pemrograman dari Awesome Indonesia list.","tags":"ebook, belajar, gratis","media":"web","thumbnail":"https://opengraph.githubassets.com/948c776c464898ff7fe7376d829579ba6238db8cff044a4b34cb137e284c677b/fransallen/awesome.id","owner":"@fransallen","draft":false,"original_published_at":"2021-08-12T11:22:11.225","created_at":"2021-08-12T11:32:27.492735","updated_at":"2021-08-12T11:32:27.492735","deleted_at":null,"source_id":null,"contributor":"@fransallen"},{"id":2882,"title":"Node Bindings di sebuah kulit kacang (nutshell)","url":"https://www.evilfactorylabs.org/fncolon/node-bindings-di-sebuah-kulit-kacang-nutshell-32kb","body":"Perkenalan\n\n\nNampilin hello world dari C++ ke Javascript aja udah seneng = Node Bindings.\nBindings adalah proses dimana kita menggunakan library bahasa pemrograman lain di bahasa pemrograman yang kita gunakan, tujuannya supaya library yang bisa digunakan di bahasa pemrograman A bisa digunakan di bahasa pemrograman B.\nJavascript dibangun menggunakan V8 Engine, dimana V8 Engine ditulis menggunakan bahasa C++, C++ inilah yang memberi koneksi dan memberi support Event Loop yang didalamnya memiliki Asynchronous I/O untuk Javascript melalui library yang bernama libuv yang ditulis menggunakan C, selain itu fungsi filesystem seperti core module fs juga ditulis menggunakan C++ di Node.js.\nAda juga socket dan http yang sama sama dibuat menggunakan C++ di Node.js, karena Javascript by default tidak tau bagaimana menghandle filesystem, alasannya adalah tujuan awal Javascript adalah membuat website menjadi lebih interaktif (e.g menggunakan DOM) yang digunakan di browser, karena security, tidak mungkin juga browser memperbolehkan filesystem access pada setiap website menggunakan Javascript (sebelum node.js menyerang), socket maupun http, maka dari itu browser (serta node.js) menggunakan bindings yang dibuat menggunakan c++ karena dapat memberi perintah langsung kepada sistem (system call).\nSalah satu open source Javascript yang menggunakan node bindings adalah sqlite3 https://github.com/mapbox/node-sqlite3, node bindings sangat membantu sekali untuk membuat library\" yang keren dari C++ dapat digunakan di Javascript, ini adalah salah satu alasan penulis belajar node bindings, meskipun ujungnya harus belajar C++ dari awal lagi haha :').\nNode bindings memiliki build tools juga (ibaratnya seperti webpack untuk frontend assets) yaitu node-gyp, node-gyp ini berguna untuk mengcompile API native addons untuk Node.js (seperti yang saya tampilkan di video disini) seperti N-API yang sekarang berganti nama menjadi Node-API, jika kamu tidak ingin mengurus NODE_MODULE_VERSION (ABI version number dari Node.js) bisa menggunakan nan, dimana disediakan abstraksi yang sudah diisi logic untuk tidak perlu lagi mengurus NODE_MODULE_VERSION dari Node.js.\nYuk yang mau belajar c++ dan rust dengan gaya, yuk bisa dicoba node bindings ini.","tags":"nodejs,bindings,cpp,javascript","media":"tulisan","thumbnail":null,"owner":"fnc","draft":false,"original_published_at":"2021-08-12T09:10:17","created_at":"2021-08-12T12:15:46.856265","updated_at":"2021-08-12T12:15:46.856265","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2881,"title":"BELAJAR OPEN API (BAHASA INDONESIA)","url":"https://www.youtube.com/watch?v=o5b6TYSNK5c","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-12T05:00:11","created_at":"2021-08-12T12:15:41.498718","updated_at":"2021-08-12T12:15:41.498718","deleted_at":null,"source_id":61,"contributor":"pulodev"},{"id":2865,"title":"Strategi Memajukan Pendidikan ala Pahamify ft Rousyan | Podcast Ngobrolin Startup","url":"https://www.youtube.com/watch?v=3imzALyj-RE","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-11T09:00:11","created_at":"2021-08-08T18:11:17.990627","updated_at":"2021-08-08T18:11:17.990627","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2880,"title":"Unit Test di Elixir - Tutorial Singkat","url":"https://www.youtube.com/watch?v=aE9MbD6PNKE","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-11T09:00:00","created_at":"2021-08-12T12:15:33.841621","updated_at":"2021-08-12T12:15:33.841621","deleted_at":null,"source_id":72,"contributor":"Riza Fahmi"},{"id":2871,"title":"Eps. 56 - Strategi Memajukan Pendidikan ala Pahamify","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--56---Strategi-Memajukan-Pendidikan-ala-Pahamify-e15k0h9","body":"Sebenernya apa yang masih belum pas dengan pendidikan kita? Gimana pahamify bisa berperan utk menyelesaikan masalah pendidikan yg njelimet ini? Yuk simak!\n\n--- \n\nSend in a voice message: https://anchor.fm/ngobrolinstartup/message\nSupport this podcast: https://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-08-11T09:00:00","created_at":"2021-08-11T12:15:26.63008","updated_at":"2021-08-11T12:15:26.63008","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2852,"title":"Membuat Backend Sistem Notifikasi Saweria dengan Server Sent Event (SSE) dan Google Cloud Pub/Sub","url":"https://www.youtube.com/watch?v=9RMS4Y0xXa4","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-11T07:11:39","created_at":"2021-08-03T00:37:24.452288","updated_at":"2021-08-03T00:37:24.452288","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2870,"title":"How Monika Saved Me from Unnoticed Server Errors","url":"https://medium.com/hyperjump-tech/how-monika-saved-me-from-unnoticed-server-errors-243e97f35edd?source=rss----fabfd42372dc---4","body":null,"tags":"software-engineering,devops,monitoring,software,javascript","media":"tulisan","thumbnail":null,"owner":"Denny Pradipta","draft":false,"original_published_at":"2021-08-10T03:37:30","created_at":"2021-08-11T12:15:22.819478","updated_at":"2021-08-11T12:15:22.819478","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2866,"title":"Pengantar Kalkulus Lambda","url":"https://www.evilfactorylabs.org/artileda/pengantar-kalkulus-lambda-90e","body":"Kalkulus Lambda adalah model komputasi yang berlandaskan prinsip fungsi M-chan (Matematika-chan), pertama kali di kemukakan oleh Alonzo Church pada awal 1930-an yang menjadi bagian penelitian beliau dalam pembuktian formal dasar matematika.\nModel komputasi merupakan kerangka kerja yang menjelaskan apa yang  dilakukan sebuah fungsi / algoritme dalam menghasilkan nilai keluaran dari sebuah nilai masukan.\nKetika kita menerima nilai masukan 4, Bagaimana kita menghasilkan 6 ?\nlet y = (x) => x + 2\n\ny(4)\n\natau juga\nlet y = (x) => x + (x/2)\n\ny(4)\n\nFenomena banyak cara untuk memenuhi syarat nilai masukan dan keluaran ini disebut dengan undecidability.\nBagaimana bentuknya dalam kalkulus lambda ?\nŒªx.(+ x 2) 4 = (+ 4 2) = 6\n\nPenulisan notasi dengan operator pada awal operasi disebut notasi prefiks. \nNotasi tersebut sama saja dengan\nŒªx.(x + 2) 4 = (4 + 2) = 6\n\nKalkulus lambda salah satu model komputasi fungsional, fungsional berarti komputasi disusun oleh set dan fungsi matematika.\nKalkulus Lambda memiliki 3 ekspresi:\nE := x \n  | E1.E2\n  | Œªx.E1\n\nx , Variable\nE1.E2 , Aplikasi Fungsi\nŒªx.E1 , Abstraksi Fungsi\nRupa kode dalam bentuk tipe data.\ntype rec e = \n  | Variabel(int)\n  | Aplikasi(e,e) \n  | Abstraksi(int,e)\n\nVariable adalah nilai bilangan, seperti 1,2,3 dan seterusnya.\nAbstraksi fungsi adalah cara kita membuat suatu fungsi.\nŒª(parameter).(badan fungsi)\n\nŒªx.E1\n\nŒªx, notasi melambangkan bagaimana kita membuat sebuah fungsi dengan parameter x.\n\n\nE1, eksprsi dari kalkulus lambda\n\n\n\nContoh\nŒªx. (+ (* x 2) x)\n\nŒªy. (- y 2)\n\nDalam bentuk kode\nlet f1 = (x) => (x * 2) + x\n\nlet f2 = (y) => y - 2\n\nAplikasi fungsi bagaimana kita menggunakan fungsi terhadap sesuatu nilai masuka atau ekspresi.\nŒªx. (+ (* x 2) x) 4 \n= (+ (* 4 2) 4)\n= ( + 8 4 )\n= 12\n\nFungsi Œªx. (+ (* x 2) x) diberikan masukan 4.\n\n\nParameter x dan variabel x pada badan fungsi di ganti dengan 4 dan Œªx dihapus karena x sudah terganti, sehingga menghasilkan (+ (* 4 2) 4).\n\n\nKita operasikan dari kurung terdalam yaitu (* 4 2) menjadi ( + 8 4 ) dan dilanjutkan sehingga menghasilkan 12.\n\n\n\nRupa dalam bentuk kode\nlet f = (x) => (x * 2) + x\n\nf(4) // 12\n\nŒªa.(* a a) . Œªx.(+ x 3) . 4\n\nKita punya sebuah fungsi berparameter a dengan isi (* a a) dan diaplikasikan dengan (+ x 3) dan 4 ?\nŒªa. (* a a) (+ x 3) 4\n= (* (Œªx.(+ x 3)) (Œªx.(+ x 3)) 4\n= (* (+ 4 3) (+ 4 3))\n= (* 12 12)\n= 144\n\nBila ditulis dalam bentuk kode\nlet fa = (a) => (a * a)\n\nlet fx = (x) => x + 3\n\nfa(fx(4)) // 144\n\nSekian dari tulisan ini semoga cukup memanaskan kepala and. Apabila penjelasan saya kurang dapat di mengerti, semoga video dibawah ini bisa membantu\n#1 Pengantar | Kalkulus Lambda, Idiosemantik\nTerima kasih.","tags":"teorikomputasi,rescript","media":"tulisan","thumbnail":null,"owner":"‚ñ≤Engelstrassen","draft":false,"original_published_at":"2021-08-08T18:09:50","created_at":"2021-08-08T18:11:45.275497","updated_at":"2021-08-08T18:11:45.275497","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2863,"title":"Pengenalan Program Komputer","url":"https://gadiskoding.my.id/pengenalan-program-komputer.html","body":"Apa sih itu program dan berbagai seluk beluk lainya.","tags":"pemrograman dasar","media":"tulisan","thumbnail":"/images/og.png","owner":"Gadis Koding","draft":false,"original_published_at":"2021-08-08T12:09:12.761","created_at":"2021-08-08T12:09:33.276989","updated_at":"2021-08-08T12:09:33.276989","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2862,"title":"Belajar Test Driven Development","url":"https://anchor.fm/deep-tech/episodes/Belajar-Test-Driven-Development-e15k33f","body":"Dalam proses pengembangan software, seringkali requirements selalu berubah mengikuti kebutuhan. Hal ini menyebabkan timbulnya beberapa masalah teknis seperti bugs. Bahkan menyangkut psikologis, misalnya developer jadi nggak percaya diri untuk mengembangkan fitur karena takut aplikasi akan break.\nMakanya, developer membutuhkan automated test untuk mengecek baris kode. Namun ada cara terbaik dalam penerapan automated test ini yaitu dengan Test Driven Developmet atau biasa disingkat TDD. Yuk belajar lebih dalam mengenai TDD bersama Resi Respati, Senior Front End di Kata dot ai.","tags":"","media":"podcast","thumbnail":null,"owner":"deep tech foundation","draft":false,"original_published_at":"2021-08-08T04:54:12","created_at":"2021-08-08T06:11:31.015908","updated_at":"2021-08-08T06:11:31.015908","deleted_at":null,"source_id":4,"contributor":"hilmanski"},{"id":2861,"title":"üöÄ Coming soon: BlobCDN","url":"https://upset.dev/blobcdn","body":"The CDN for beautiful SVG shapes. Dapatkan early access!","tags":"cdn, svg, blob, design","media":"web","thumbnail":"https://ph-files.imgix.net/70013e6c-c741-484f-9ffb-81be950bd278.png?auto=format","owner":"@fransallen","draft":false,"original_published_at":"2021-08-07T22:58:55.804","created_at":"2021-08-07T23:02:30.855274","updated_at":"2021-08-07T23:02:30.855274","deleted_at":null,"source_id":null,"contributor":"@fransallen"},{"id":2859,"title":"GitHub - artileda/pemrograman-fungsional: Repo berisi sumber dan referensi belajar pemrograman fungsional","url":"https://github.com/artileda/pemrograman-fungsional","body":"Repo berisi sumber dan referensi belajar pemrograman fungsional - GitHub - artileda/pemrograman-fungsional: Repo berisi sumber dan referensi belajar pemrograman fungsional","tags":"pemrograman fungsional","media":"web","thumbnail":"https://opengraph.githubassets.com/244780da8de2db5d675f2932ee5432132a1994f3b47cba4c11af885eefdc38f7/artileda/pemrograman-fungsional","owner":"@artileda","draft":false,"original_published_at":"2021-08-07T18:02:07.714","created_at":"2021-08-07T18:02:49.130657","updated_at":"2021-08-07T18:02:49.130657","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2860,"title":"Strategi Memajukan Pendidikan ala Pahamify ft. Rousyan, CEO Pahamify | Teaser Ngobrolin Startup","url":"https://www.youtube.com/watch?v=H8x0Z4uCTnY","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-07T16:49:30","created_at":"2021-08-07T18:11:04.439352","updated_at":"2021-08-07T18:11:04.439352","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2883,"title":"Frontend - Situs KPU Mahasiswa STKIP Muhammadiyah Kuningan","url":"https://rahmatagungjulians.tech//blog/frontend-kpu-stkip","body":"Apa yang harus dipakai? Javascript atau Python, disini saya akan membahas mengenai pembuatan frontend untuk situs KPU Mahasiswa STKIP Muhammadiyah Kuningan.","tags":"breakdown","media":"web","thumbnail":null,"owner":"rahmatagungj@gmail.com (Rahmat Agung Julians)","draft":false,"original_published_at":"2021-08-07T00:00:00","created_at":"2021-08-12T12:15:47.881517","updated_at":"2021-08-12T12:15:47.881517","deleted_at":null,"source_id":73,"contributor":"Rahmat Agung Julians"},{"id":2864,"title":"#1 Pengantar | Kalkulus Lambda","url":"https://www.youtube.com/watch?v=BinlkRGwf_I","body":"Halo kawan-kawan.Video kali ini saya membahas tentang apa itu kalkulus lambda dan pengoperasinya dengan aritmatika sederhana.Model komputasi merupakan gambar...","tags":"teori komputasi,bahasa pemrograman","media":"video","thumbnail":"https://i.ytimg.com/vi/BinlkRGwf_I/maxresdefault.jpg","owner":"Idiosemantik","draft":false,"original_published_at":"2021-08-07T00:00:00","created_at":"2021-08-08T12:11:07.279905","updated_at":"2021-08-08T12:11:07.279905","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2857,"title":"üòé Awesome Indonesia","url":"https://github.com/fransallen/awesome.id","body":"Daftar produk, proyek, acara dan sumber daya lainnya yang dibuat oleh developer dan founder dari Indonesia.","tags":"awesome, open source, indonesia, saas, product","media":"web","thumbnail":"https://opengraph.githubassets.com/5ae19ae4e35f05cda7234520c88f0b6c0b2b2b4b4ea0f71a4c1ee856b3953498/fransallen/awesome.id","owner":"@fransallen","draft":false,"original_published_at":"2021-08-06T07:45:37.523","created_at":"2021-08-06T07:49:07.486213","updated_at":"2021-08-06T07:49:07.486213","deleted_at":null,"source_id":null,"contributor":"@fransallen"},{"id":2884,"title":"Backend - Situs KPU Mahasiswa STKIP Muhammadiyah Kuningan","url":"https://rahmatagungjulians.tech//blog/backend-kpu-stkip","body":"Pada bulan ini yaitu Agustus 2021 akan ada pemilihan Presiden dan Wakil Presiden Badan Eksekutif Mahasiswa STKIP Muhammadiyah Kuningan 2021-2022. Dengan adanya pemilihan tersebut maka dibuatlah situs khusus untuk melakukan pemilihan dari mahasiswa secara online, disini saya akan membawa anda untuk melihat beberapa konsep dan alur kerja dari situs yang saya buat.","tags":"breakdown","media":"web","thumbnail":null,"owner":"rahmatagungj@gmail.com (Rahmat Agung Julians)","draft":false,"original_published_at":"2021-08-06T00:00:00","created_at":"2021-08-12T12:15:47.881517","updated_at":"2021-08-12T12:15:47.881517","deleted_at":null,"source_id":73,"contributor":"Rahmat Agung Julians"},{"id":2873,"title":"Backend - Situs KPU Mahasiswa STKIP Muhammadiyah Kuningan","url":"https://www.rahmatagungjulians.tech/blog/backend-kpu-stkip","body":"Pada bulan ini yaitu Agustus 2021 akan ada pemilihan Presiden dan Wakil Presiden Badan Eksekutif Mahasiswa STKIP Muhammadiyah Kuningan 2021-2022. Dengan adanya pemilihan tersebut maka dibuatlah situs khusus untuk melakukan pemilihan dari mahasiswa secara online, disini saya akan membawa anda untuk melihat beberapa konsep dan alur kerja dari situs yang saya buat.","tags":"arsitektur, devops, programming, website","media":"web","thumbnail":"https://rahmatagungjulians.tech//static/images/twitter-card.png","owner":"Rahmat Agung Julians","draft":false,"original_published_at":"2021-08-06T00:00:00","created_at":"2021-08-12T08:59:03.961357","updated_at":"2021-08-12T08:59:03.961357","deleted_at":null,"source_id":null,"contributor":"Rahmat Agung Julians"},{"id":2856,"title":"Cara Membuat JSON Web Tokens tidak Valid","url":"https://hellodit.medium.com/cara-membuat-json-web-tokens-tidak-valid-4e25615826e?source=rss-bec8db944a8e------2","body":null,"tags":"json-web-token,rest-api,jwt,programming","media":"tulisan","thumbnail":null,"owner":"Asdita Prasetya","draft":false,"original_published_at":"2021-08-04T03:29:13","created_at":"2021-08-04T06:12:47.128271","updated_at":"2021-08-04T06:12:47.128271","deleted_at":null,"source_id":51,"contributor":"hellodit"},{"id":2855,"title":"Berkenalan dengan OpenAPI 2.0/Swagger","url":"https://gadiskoding.my.id/berkenalan-dengan-openapi-2-0-swagger.html","body":"Membuat dokumentasi api sekaligus membangkitkanya.","tags":"restapi,openapi,web","media":"web","thumbnail":"/images/og.png","owner":"Gadis Koding","draft":false,"original_published_at":"2021-08-03T13:59:14.735","created_at":"2021-08-03T13:59:57.456211","updated_at":"2021-08-03T13:59:57.456211","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2854,"title":"Jatuh Bangun Menjalani Bisnis Software Consulting Firm","url":"https://www.youtube.com/watch?v=1L7_rf-at0g","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-03T12:00:02","created_at":"2021-08-03T12:15:28.329283","updated_at":"2021-08-03T12:15:28.329283","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2853,"title":"Eps. 55 - Jatuh Bangun Membangun Software Consulting Firm ","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--55---Jatuh-Bangun-Membangun-Software-Consulting-Firm-e15a194","body":"Gw banyak dapet ilmu dari obrolan bareng Sidiq & Taufan, co-founder Nusantara Beta Studio, tentang apa yang pelajaran mereka ketika ngebangung bisnis software consulting. Simak aja!\nhttps://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-08-03T01:00:00","created_at":"2021-08-03T06:12:13.725109","updated_at":"2021-08-03T06:12:13.725109","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2851,"title":"Thread twitter pelajaran dari proyek bersama WargaBantuWarga ","url":"https://twitter.com/deeptech_id/status/1422162040089575425","body":"","tags":"opensource","media":"tulisan","thumbnail":"","owner":"Twitter Deep Tech","draft":false,"original_published_at":"2021-08-02T23:43:28.697","created_at":"2021-08-02T23:44:48.698456","updated_at":"2021-08-02T23:44:48.698456","deleted_at":null,"source_id":null,"contributor":"hilmanski"}],"total":1365}