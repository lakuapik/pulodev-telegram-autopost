{"data":[{"id":2944,"title":"Komposisi Fungsi dengan Elixir Pipe Operator","url":"https://www.youtube.com/watch?v=KorX6AraK4E","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-08T09:00:08","created_at":"2021-09-08T12:25:28.505588","updated_at":"2021-09-08T12:25:28.505588","deleted_at":null,"source_id":72,"contributor":"Riza Fahmi"},{"id":2943,"title":"Generate your Monika Configuration using HTTP Archive (HAR)","url":"https://medium.com/hyperjump-tech/generate-your-monika-configuration-using-http-archive-har-764944cbb9e6?source=rss----fabfd42372dc---4","body":null,"tags":"monitoring,http-archive,open-source,monika,software-development","media":"tulisan","thumbnail":null,"owner":"Denny Pradipta","draft":false,"original_published_at":"2021-09-08T01:48:52","created_at":"2021-09-08T06:19:21.235223","updated_at":"2021-09-08T06:19:21.235223","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2942,"title":"Eps. 58 - Secuil Cerita Belasan Tahun Menjadi Technical Leaderz","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--58---Secuil-Cerita-Belasan-Tahun-Menjadi-Technical-Leaderz-e16t977","body":"Didiet Noor, Head of Engineering Bukalapak, berbagi pengalamannya tentang naik turun dalam perjalanannya sebagai tech lead. Pengen denger tentang gimana caranya belajar mendelegasi tugas? Atau ingin tau caranya mengatur komposisi tim yang paling pas untuk mencapat tujuan bisnis? yuk simak!\nhttps://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-09-06T23:00:00","created_at":"2021-09-07T00:50:48.055451","updated_at":"2021-09-07T00:50:48.055451","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2940,"title":"Isolated Development Environment di Apple Silicon","url":"https://www.evilfactorylabs.org/faultable/isolated-development-environment-di-apple-silicon-518","body":"Sebagai pembuka, ini perlu banget gue nyebutin chip Apple Silicon (M1) karena jika menggunakan chip Intel harusnya enggak bakal seribet ini.\nSudah lama gue menggunakan remote server sebagai development environment utama gue mengingat spesifikasi PC gue (Intel NUC) sedikit sampah. Sistem operasi utama gue adalah GNU/Linux untuk kebutuhan web app development dan menggunakan Ubuntu karena varian ini yang paling terkenal (dan stabil) sejauh yang gue tau.\nSeperti kebanyakan pengembang lain, diri gue sebagai seorang pengembang perangkat lunak pun tidak hanya ketika dari jam 09 sampai 17 aja, di waktu luang ataupun akhir pekan gue terkadang mengembangkan aplikasi juga entah just for fun, pembelajaran, dsb.\nGue lumayan ketat dalam memasang dan menjalankan aplikasi yang ada di komputer gue. Gue rutin memeriksa aplikasi apa saja yang sedang berjalan, apa saja yang membuka koneksi, dan apa saja yang mengirim paket. Disamping itu, kebutuhan penggunaan komputer gue tidak sebatas untuk kepentingan pribadi, melainkan kepentingan pekerjaan juga baik pekerjaan utama ataupun sampingan iseng-iseng berhadiah.\nDi tahun 2021 gue berencana melakukan upgrade terhadap mesin tempur yang gue miliki. Sebenarnya tidak terlalu banyak perubahan, hanya core CPU yang sebelumnya 4 menjadi 8, dan arstektur yang tadinya Intel-based menjadi ARM-based jika membandingkan dengan MBA 2015 gue.\nThroughput nya? Sangat terasa. I/O speed mesin ini rata-rata nya adalah 2.3 GB/s, berbeda dengan yang sebelumnya (MBA dan NUC) yang hanya ~50% dari yang sekarang. Apple menjanjikan 3.5x peningkatan dalam CPU speed, dan sejujurnya gue kurang yakin apakah benar-benar peningkatan tersebut sebesar 3.5x karena yang gue rasakan hanyalah... cepat.\nKarena pertimbangan tersebut gue merasa mubazir bila laptop gue masih dipakai sebatas sebagai SSH client aja, dan juga gue bisa terbebas dari tagihan $22/bulan hanya untuk membuat remote devbox gue berjalan demi mendapatkan mesin dengan 2 vCPU, RAM 4GB, 80GB NVMe SSD, dan alamat IP publik cantik yang beralamat 143.198.198.198.\nTapi sekali lagi, gue tidak ingin mencampur berbagai kepentingan di satu tempat. Dan tentu saja membuat VM adalah jawabannya. Sayangnya, Multipass nya Canonical belum mendukung chip si Apple Silicon ini. Dan Vagrant belum mendukung native support Hypervisor.framework (via xhyve/bhyve) ataupun menggunakan HyperKit nya Docker.\nDan yang paling penting: Gue tidak ingin memasang Docker for Desktop ataupun Virtualbox nya Oracle, no matter what. Tapi kita memiliki Qemu, salah satu swiss army knife untuk virtualization dan emulation yang dibuat oleh lord Fabrice Bellard.\nTapi pengetahuan & pengalaman gue tidak se-dewa itu untuk bisa memahami & menghafal argument-argument penting yang ada di QEMU, dan juga bagian yang paling sulitnya adalah bagaimana membuatnya berjalan dengan baik dan benar.\nLalu gue menemukan UTM versi Mac nya yang gue rasa ini adalah versi GUI dari QEMU karena si UTM ini pada dasarnya menggunakan QEMU, under the hood.\nProses instalasinya mudah, drag-and-drop seperti biasa ke direktori /Application. Dan cara memulainya pun relatif mudah, mari kita membuat VM dengan sistem operasi Ubuntu Server yang menggunakan arsitektur ARM sebagai pembuka topik dari tulisan.\nPertama tentu saja unduh berkas optical disk image nya di halaman ini. \nBrengseknya terakhir gue cek belum ada berkas checksum yang disediakan untuk versi si ARM ini, jadi kita tidak bisa memastikan bahwa berkas yang kita unduh dengan berkas yang ada disediakan Canonical adalah berkas yang sama dan tidak rusak. But YOLO, download now.\nKedua, setting VM seperti biasa.\nBagian yang paling penting menurut gue adalah jenis hardware (di bagian System) yang akan di emulasi (pastikan memilih arsitektur arm64), jumlah memory yang ingin ditawarkan (umumnya 50% dari kapasitas yang asli), dan terakhir, seperti biasa, tambahkan 2 drive yang satu sebagai drive utama dan yang dua sebagai ephemeral drive untuk installer si Ubuntu Server kita.\n\nSisanya, boot dan jalankan proses instalasi seperti biasa. Semuanya harusnya akan berjalan out of the box.\nOke gue bisa aja memasang Postgres, Redis, Traefik, Python, Flask, Node.js, npm, dkk, clone repositori-repositori yang dibutuhkan, switch branch secara manual, dan getting up and running in hard way.\nTidak lupa juga menyesuaikannya dengan lingkungan yang ada, salah satu contohnya adalah mendefinisikan environment variables yang ada.\nDan mungkin tidak masalah selagi lingkungan tersebut sudah ter-isolasi dari lingkungan utama gue. Tapi gue males, dan eventually gue harus memasang docker agar seragam dengan setup yang ada di departemen engineering.\nDi sistem operasi non-linux, Docker (docker engine) bejalan didalam VM yang disebut \"docker machine\". Dan yang paling gue males, dia memakan sumber daya yang tidak sedikit, dan gue tidak peduli sekalipun RAM gue berkapasitas 10TB dengan 69-core CPU.\nKarena bagian instalasi Docker (di guest machine) tidak penting, jadi gue skip. Yang paling penting adalah bagaimana membuatnya dapat berkomunikasi dengan host OS (Mac).\nPort forward di UTM relatif gampang, dan sejujurnya gue masih heran kenapa Docker Desktop belum menawarkan port forward dari host ke container via GUI.\nAnyway, gue akan mendemonstrasikan bagaimana mem-forward port 80 di guest machine ke port 8080 di host machine. Via utm kurang lebih seperti ini:\n\nDan gue rasa sangat intuitif sekalipun ini hari pertama gue menggunakan UTM. Markicob?\n\nDi gambar diatas terlihat bahwa gue mengakses Nginx yang ada di guest OS (Ubuntu) di port 80 via port 8080 yang ada di host OS.\nDi bagian port forwarding ini juga bisa untuk melakukan SSH ke guest OS, karena sejauh yang gue tau si UTM ini belum bisa menggunakan bridged network yang mana tidak bisa berkomunikasi dengan jaringan yang ada di si guest machine begitupula sebaliknya.\nMari kita cek performance penalty yang ada di VM menggunakan bench.sh\n\nGue rasa ada penalti sekitar -40.59% bila dibandingkan dengan benchmark yang ada di host machine:\n\nDan gue rasa it doesn't matter jika melihat keluaran htop(1) yang dilakukan di host & guest machine dengan perintah htop -p $(ps aux | grep -i qemu-aarch64 | head | awk '{print $2}' dan di guest machine tanpa eksplisit membawa pid yang ingin di monitor:\n\nLook how wild Node.js is.\nPR utamanya adalah—khususnya bila menggunakan Docker—harus memastikan bahwa Docker Image yang ingin digunakan dapat berjalan di arsitektur ARM (ARM64). Ini di pipeline CI bisa menggunakan docker/buildx ketika melakukan build, tapi besar kemungkinan aplikasi populer yang akan kita gunakan sudah mendukung untuk arsitektur arm64 ini.\nPR kedua adalah tidak (semoga setidaknya belum) bisa mengakses guest machine IP. Dan berarti mDNS pun tentu saja tidak bisa digunakan. Dan somehow ini bikin frustasi karena misalnya lebih mudah menghafal faultables-raspi.local daripada 192.168.8.69 sekalipun menggunakan static lease di dhcp.\nPR ketiga adalah port forwarding hell, thanks to PR kedua. Bayangkan jika ada 5 VM, bila setiap VM ingin meng-expose minimal 3 port, akan ada 20 port (plus SSH) yang harus gue forward dan hafal) dari guest ke host. Mungkin gue bisa setting reverse proxy untuk masalah ini, yang berarti setidaknya cuma ada 10 port (untuk 22 dan 80 di guest) yang harus gue forward, tapi tetap ini annoying & pain.\nPR terakhir adalah gue belum menemukan cara untuk menjalankan VM ini di background. Harusnya bisa dengan melakukan \"export QEMU command\" dan gue bikin simple script misal seperti vm delman start, yang mana delman adalah nama VM nya. Tapi idk, terlalu males buat nyoba.\nGue berjanji pada diri sendiri khusus untuk provision VM ini hanya untuk kasus jika development environment harus banget ada docker. Selebihnya gue akan mengusahakan dilakukannya di non-vm dan yang ada di radar gue sejak lama adalah menggunakan NixOS.\nDan juga gue akan mengusahakan untuk menggunakan OS yang mendukung arsitektur arm64 alih-alih harus meng-emulasi CPU ke x86 yang pastinya gue rasa akan memiliki penalti yang lebih besar.\nSebagai penutup, apakah gue puas dengan setup seperti ini? Tentu saja! Tidak memasang Docker Desktop dan VirtualBox adalah sebuah kemenangan untuk gue sekalipun dengan memasangnya pun tidak membunuh diri gue secara perlahan.\nJika gue sudah frustasi banget dengan membuat development environment Mac OS di proses ARM, mungkin gue akan mempertimbangkan menggunakan Asahi Linux dan mengucapkan sayonara untuk kesekian kalinya ke Mac OS (would be great kalau Pop!_OS mendukung arsitektur arm64 natively mengingat Ubuntu sudah mendukungnya juga).\nTerakhir, I'm just having fun! Tidak semua pengembang cocok membuat development environment nya ter-isolasi. Tapi jika kamu menggunakan rbenv, pyenv, venv, fnm, nodeenv, jails, lxc, dsb, harusnya kamu sudah mengetahui apakah kamu membutuhkan isolated development environment atau tidak 😉","tags":"development,setup","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-09-04T21:43:35","created_at":"2021-09-05T00:55:13.174467","updated_at":"2021-09-05T00:55:13.174467","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2937,"title":"Untuk apa developer menulis?","url":" https://sekolahkoding.com/artikel/untuk-apa-developer-menulis ","body":"Untuk apa sih seorang developer belajar menulis? bukan menulis koding, tapi menulis biasa.\"Hmmm.. selama bisa menulis program.. untuk apa lagi belajar...","tags":"\n                menulis\n            ,\n                dokumentasi\n            ","media":"tulisan","thumbnail":null,"owner":" hilmanski ","draft":false,"original_published_at":"2021-09-04T16:46:18","created_at":"2021-09-04T12:24:07.91864","updated_at":"2021-09-04T12:24:07.91864","deleted_at":null,"source_id":49,"contributor":"sekolahkoding"},{"id":2939,"title":"Mengenal Continuous Integration (CI) untuk pengembang","url":"https://www.evilfactorylabs.org/faultable/mengenal-continuous-integration-ci-untuk-pengembang-4lg3","body":"Sebagai seorang pengembang, pekerjaan utama kita besar kemungkinan adalah menulis kode, yang mana akan menghasilkan sebuah aplikasi. Aktivitas penulisan kode tersebut tidak jarang dilakukan bersama dalam bentuk tim yang terdiri dari berbagai sub-grup dan atau anggota yang ahli dalam bidangnya masing-masing.\nUntuk membuat kode yang ditulis oleh pengembang \"berguna\", maka kode tersebut harus dapat berjalan. Namun ada yang lebih penting daripada hanya membuatnya berjalan saja, yakni membuatnya berjalan dan sesuai fungsi juga.\nYang menarik dari aktivitas pengembangan aplikasi ini adalah kode yang ditulis bisa dilakukan bersama, secara paralel. Mungkin bisa bayangkan seperti membuat sebuah novel yang mana setiap bab nya ditulis oleh penulis yang berbeda, secara paralel.\nYang menjadi pertanyaan adalah: bagaimana memastikan bahwa \"plot\" yang ditulis sesuai dengan keseluruhan \"cerita\" yang diharapkan?\nPertanyaan yang tidak kalah penting lagi adalah: bagaimana memastikan bahwa keseluruhan cerita ditulis seperti oleh satu orang?\nDan yang paling penting: bagaimana plot yang ditulis tidak merusak plot lain yang ditulis oleh penulis berbeda?\nSilahkan ganti kata \"plot\" diatas dengan \"fitur\".\nProses Code review ini sudah umum dilakukan di organisasi pengembang. Jika belum familiar dengan code review, mungkin memiliki pertanyaan seperti: Mengapa kode yang gue tulis ditinjau lagi, sedangkan gue pastinya menulis kode yang berjalan?.\nKarena code review, sekali lagi, adalah tentang code review. Ini bukan hanya tentang memastikan kode yang ditulis berjalan, melainkan untuk memastikan bahwa kode yang ditulis sesuai dengan pedoman; konvensi, dan kualitas yang dimiliki organisasi tersebut.\nDan yang tidak kalah penting adalah tentang pemindahan informasi. Tentang membuat tim yang terlibat tetap singkron dengan perubahan yang terjadi. Juga tentang saling belajar cara berpikir dari pengembang yang berbeda-beda.\nUmumnya untuk memastikan bahwa kode yang ditulis berjalan adalah dengan melakukan proses \"build\", jika melewati fase ini, bisa dipastikan kode yang ditulis memang berjalan dan tidak memiliki kesalahan yang membuat aplikasi tersebut gagal dibuat.\nSetelah itu, proses yang dilakukan adalah \"test\". Di fase ini, kita memastikan bahwa kode berjalan sesuai harapan yang mana salah satu harapannya adalah tidak merusak fungsi lain yang sudah/ditulis oleh pengembang lain.\nApa saja yang diuji? Tergantung. Bisa menguji fungsionalitas per-unit, menguji ketika unit-unit tersebut \"berkomunikasi\" dengan unit lain ataupun berbeda, sampai ke pengujian ketika unit-unit tersebut digabungkan menjadi satu-kesatuan. Misal, seperti cerita \"Mengirim surel konfirmasi kata sandi ketika pengguna lupa kata sandinya\". Yang pertama kita uji tentu adalah fungsi mengirim surel beserta konten yang ada, yang dilanjutkan dengan kondisi ketika menggunakan komponen eksternal (seperti protokol SMTP misalnya), yang diakhiri misal dengan alur dari klik tombol \"Forgot password\", mengisi alamat surel, dan mendapatkan surel yang diharapkan.\nTapi mengembangkan aplikasi tidak hanya tentang memedulikan siapa yang menggunakannya saja. Memedulikan pengembangnya juga tidak kalah penting selain demi menjaga kewarasan juga bisa membantu untuk membuat pengembang tersebut menjadi lebih produktif dan bergerak cepat. Seperti, keluhan-keluhan tentang \"legacy code\" sudah menjadi rahasia umum di kalangan pengembang, terlepas berada di organisasi manapun itu.\nLegacy code ini sebenarnya tidak selalu buruk, dan menariknya keluhan tentang legacy code ini memiliki pola. Pengembang relatif akan mengeluhkan legacy code, jika mereka menemukan kode yang sudah ada ditulis:\nRibet/sulit dipahami\nTidak konsisten\nTidak rapih/berpola\nTidak singkron dengan kondisi pada saat ini\nDan hampir jarang—atau mungkin main gue kurang jauh—pengembang mengeluhkan \"legacy code\" bila kode yang sudah ada:\nMudah dipahami\nKonsisten\nRapih & berpola\nSingkron dengan kondisi pada saat ini\nSetuju?\nNah, untuk dapat membuat kode yang ada memenuhi poin-poin diatas, organisasi setidaknya harus memiliki pedoman; konvensi, dan kualitas terkait kode yang harus ditulis oleh pengembang.\nNamun yang paling berat bukanlah di pembuatan & penentuan standar terkait pedoman; konvensi, dan kualitas kode tersebut, melainkan di bagaimana memastikan pengembang mengikuti standar tersebut..\nDan proses pemastiannya, selain bukan tanggung jawab utama dari seorang pengembang juga adalah pekerjaan yang sangat membosankan.\n...kecuali?\nKebanyakan para pengembang adalah pribadi yang malas dan (tidak jarang) mudah bosan juga, mereka akan mencari cara untuk mengatasi kemalasan dan kebosanan mereka tanpa mengorbankan esensi utama yang ada.\nJika tidak setuju, silahkan jawab mengapa kamu menulis test alih-alih mengujinya dengan tangan sendiri untuk memastikan kode yang kamu tulis berjalan dan juga tidak merusak kode yang lain?\nSadar-tidak sadar, pengembang berusaha sekeras mungkin untuk menggunakan solusi yang \"otomatis\" daripada \"dengan tangan\". Dari sesederhana menggunakan package manager daripada mengunduh berkas arsip dan mengekstraksinya sendiri sampai ke pembuatan \"jalan pintas\" untuk membuat Makefile dan mengetik make daripada gcc -std=gnu99 -Wall -O2 -I\"./include\" build/x86/obj/*.o build/x86/obj/entry/main.o -o build/x86/bin/app -lpthread untuk membuat kode yang ditulis menjadi sebuah aplikasi.\nJika otomatisasi ini bisa membantu membuat pekerjaan pengembang per-individu menjadi lebih mudah, bukankah seharusnya bisa membuat pekerjaan pengembang dalam konteks kelompok menjadi lebih mudah juga?\nDan ditulisan ini, kita akan membahas itu.\nTentang Continuous Integration.\nTentang menemukan bug lebih cepat, meningkatkan kualitas program, dan tentang mengurangi waktu dalam memvalidasi dan merilis pembaruan.\nSecara otomatis.\nKomponen utama dari praktik CI ini adalah CI Platform itu sendiri. Karena, pada dasarnya, CI hanyalah sebuah proses yang biasa pengembang lakukan, di mesinnya, secara manual.\nDalam praktik CI, umumnya ada 2 fase yang harus dilewati untuk mewujudkan tujuan yang ingin dicapai:\nBuild\nTest\nAlurnya, sederhananya adalah seperti ini:\nPengembang membuat perubahan\nPerubahan tersebut diunggah ke repository bersama\nCI Platform akan melakukan \"build\" dan \"test\"\nJika 2 fase diatas berhasil dilewati, maka perubahan siap untuk digabungkan ke kode utama\nYang berarti, jika menerapkan praktik CI, setiap perubahan yang dibuat seharusnya hanya boleh digabungkan ke kode utama jika semua fase yang ada di platform CI sudah terlewati.\nApa yang dilakukan ketika build? Apa yang dilakukan ketika test? Sekali lagi, tergantung. Jika untuk menjalankan aplikasi tersebut pengembang harus:\nMenggunakan sistem operasi GNU/Linux, Windows dan *BSD.\nMemasang sqlite3, Node.js LTS, dan npm\nMemasang dependensi yang dibutuhkan dengan npm install\nMemastikan ukuran direktori dist kurang dari 10 MB\nMaka pengembang harus menjelaskan langkah-langkah diatas ke platform CI untuk fase \"build\" tersebut.\nBagaimana cara pengembang menjelaskannya ke platform CI? Biasanya setiap platform CI memiliki sebuah berkas khusus yang ditulis menggunakan format tertentu yang mana berkas tersebut bisa dianggap sebagai \"berkas konfigurasi pipeline\".\n...pipeline sederhananya hanyalah kumpulan langkah-langkah yang mana sebelumnya gue sebut sebagai \"fase\". Jika gue berbicara tentang pipeline, bisa diasumsikan gue sedang membicarakan tentang proses dari build-test.\nAnggap aplikasimu ingin berjalan di 2 sistem operasi: GNU/Linux dan Windows.\nSelain itu, aplikasimu bergantung dengan 2 program yang berada di level OS, yakni: imagemagick dan ffmpeg.\nDan persyaratan utama untuk bisa menjalankan programmu adalah:\nMenggunakan Node.js versi LTS\nMenggunakan arsitektur x86\nKapasitas RAM setidaknya 4GB\nDengan sudah mendefinisikan 3 hal diatas, setidaknya pengembang dan atau operator sudah mengetahui limitasi ada dan bisa mengurangi kemungkinan masalah unknown-unknown yang akan terjadi.\nSebagai contoh, disini kita akan menggunakan platform CI dari Gitlab yang bernama Gitlab CI. Dan berdasarkan kondisi diatas, fase build yang akan kita miliki kurang lebih seperti ini:\nstages:\n  - build\n\n.build:\n  script:\n    - npm ci\n    - npm run build\n\nbuild:windows:\n  stage: build\n  extends:\n    - .build\n  tags:\n    - windows\n  before_script:\n    - # download & install imagemagick\n    - # download & install ffmpeg\n    - # download & install node.js lts & npm\n\nbuild:linux:\n  image: ubuntu:focal\n  stage: build\n  extends:\n    - .build\n  before_script:\n    - # download & install imagemagick\n    - # download & install ffmpeg\n    - # download & install node.js lts & npm\n\nNah kunci utama dari fase dianggap sukses atau gagal adalah di exit code. Setiap program pasti memiliki exit code setiap kali dijalankan, misal, ketika kita (atau CI server) menjalankan npm run build, jika program npm berhasil menyelesaikan tugasnya, (run build) maka exit code nya 0, jika gagal, exit code nya pasti bukan 0 tergantung alasan error nya.\nMengapa fase \"build\" ini penting? Bayangkan jika pengembang harus melakukan build manual di mesinnya sendiri setiap kali pengembang lain membuat perubahan ketika melakukan code review, malesin banget gak, sih?\nSelain itu juga, fase ini bisa menghindari masalah klasik \"It works on my machine\" karena pengembang harus mendefinisikan secara eksplisit apa saja yang dibutuhkan dan apa saja yang harus dilakukan.\nDi fase ini semakin menarik. Terlebih platform CI terkadang bukan hanya menguji kode yang pengembang tulis, melainkan menguji kewarasan kita sebagai pengembang juga, iykyk.\nJenis test yang ada pun cukup beragam, tergantung seberapa luas cakupan yang ingin kita uji. Umumnya ada 3 jenis test yang biasa ditulis oleh pengembang:\nUnit test\nIntegration testing\nEnd-to-end test\nUntuk pertanyaan \"Test apa yang harus ditulis, dan kapan harus menulis Unit/Integration/E2E test?\" jawabannya ada di manager kalian atau siapapun itu yang bertanggung jawab.\nDi fase test ini tidak hanya sebatas menguji fungsionalitas dari kode yang ada, melainkan bisa juga melakukan pengujian-pengujian lain seperti:\nKonvensi\nKualitas\nKeamanan\nLisensi\nDsb\nDan akan lebih menarik lagi jika si \"penguji\" tersebut bisa membetulkan sendiri apa yang dia anggap salah, secara otomatis. Bukan hanya sebatas memberikan informasi lalu membuat pipeline tersebut gagal :))\nDengan sudah mendefinisikan jenis test berikut dengan skenarionya, setidaknya pengembang dapat memastikan bahwa perubahan yang dia buat dapat berjalan sehingga salah satunya bisa tidak membuat hidup operator menjadi lebih sulit dalam menentukan letak keberadaan kesalahan yang ada.\nSebagai contoh, disini kita akan menggunakan Gitlab CI lagi. Dan kurang lebih seperti ini untuk mendefinisikan fase test untuk aplikasi kita:\nstages:\n  - test\n\n.test:\n  script:\n    - npm run lint\n    - npm run check-deps\n    - npm run test\n\ntest:windows:\n  stage: test\n  extends:\n    - .build\n    - .test\n  tags:\n    - windows\n\ntest:linux:\n  image: ubuntu:focal\n  stage: test\n  extends:\n    - .build\n    - .test\n\nYang perlu dicatat juga bahwa kita harusnya menguji kode dari hasil build yang kita lakukan di fase sebelumnya. Untuk mencapainya, kita bisa melakukan build lagi (yang tentu saja tidak efektif) lalu test, atau bisa menggunakan pendekatan \"menggunakan artifact\" yang salah satu contohnya berarti di fase test ini, untuk kasus yang menggunakan Node.js, node_modules dan direktori dist diambil dari fase build sebelumnya.\nMengapa fase \"test\" ini penting? Karena sekali lagi, bayangkan jika pengembang harus menjalankan test manual apalagi harus melakukan test manual di mesinnya sendiri setiap kali pengembang lain membuat perubahan ketika melakukan code review, mending resign gak, sih?\nTujuan menulis test pada umumnya untuk membuat pengembang lebih percaya diri ketika membuat perubahan. Meskipun terkadang gue berpikir bahwa menulis test adalah aktivitas yang membuang-buang waktu, jika mengambil sisi positifnya ini membantu:\nAnggota baru untuk mempelajari & memahami aplikasi\nMengetahui known-issue yang ada\nMemprediksi kemungkinan edge cases\nDan yang paling penting: memastikan bahwa perubahan yang dibuat tidak merusak fungsionalitas yang sudah ada, which is nice, right?\nJika fase build & test berhasil, apa lagi yang bisa membuat ragu bahwa perubahan yang kita—sebagai pengembang—buat itu sudah berjalan dan sesuai fungsi sehingga perubahan bisa menjadi lebih cepat dapat digabungkan ke kode utama?\nBerbicara tentang Continuous Integration tentu terasa kurang bila tidak menyinggung tentang Continuous Delivery juga. Continuous Delivery ini sederhanannya adalah jawab akan \"What's next?\" setelah perubahan berhasil digabungkan ke kode utama.\nSetiap organisasi memiliki pendekatan yang beragam dalam mendistribusikan \"artifact\" atau hasil proses build tersebut. Umumnya artifact tersebut berbentuk:\nBerkas arsip, seperti .tar, .zip ataupun sebuah docker image\nBerkas paket, seperti .apk, .deb, dsb.\nJika kita mengambil konteks aplikasi untuk front-end web, besar kemungkinan artifact tersebut adalah sebuah berkas arsip yang berisi direktori node_modules dan dist.\nDan, ya, OCI compliant image seperti Docker Image pun pada dasarnya adalah sebuah berkas arsip.\nHal yang dilakukan di fase release ini pada dasarnya hanya satu: melakukan rilis, dan hal paling sederhana yang dilakukan adalah melakukan \"tagging\" dan menyimpan sesuatu yang sudah di tag tersebut ke sesuatu bernama \"package registry\" ataupun \"artifact repository\" tergantung buzzword mana yang ingin kamu gunakan.\nTagging di versi rilis ini umumnya berisi kumpulan-kumpulan perubahan yang besar pada sebuah aplikasi, bukan hanya sebatas 1 perubahan besar. Dan biasanya digambarkan dengan pemilihan nomor versi.\nAlurnya biasanya seperti ini:\nPengembang menentukan versi X ingin berisi perubahan apa saja yang dilanjutkan dengan membuat Pull/Merge Request\nPull/Merge Request tersebut menggambarkan versi yang akan dirilis, baik menggunakan nama cabang ataupun tag\nPipeline berjalan seperti biasa untuk (P/M)R tersebut.\nJika pipeline berhasil, lakukan tagging dan unggah artifact yang ada ke somewhere\n...yang tentu saja langkah nomor 4 berjalan secara otomatis :))\nMisal, artifact untuk aplikasi kita adalah sebuah Docker image. Kurang lebih kita bisa menggunakan pendekatan seperti ini misalnya:\nstages:\n  - release\n\nrelease:\n  stage: release\n  only:\n    refs:\n      - /^release\\/.*/\n  script:\n    - docker build -f ./release.dockerfile -t $BASE_IMAGE:$CURRENT_TAG .\n    - docker push $BASE_IMAGE:$CURRENT_TAG\n\nMengapa fase \"release\" ini penting? Entahlah, karena males?\nBayangkan harus menjalankan 2 perintah diatas yang besar kemungkinan memakan waktu & sumber daya yang tidak sedikit bila menggunakan mesin sendiri dan secara manual.\nDi tulisan ini gue mencoba untuk berbagi seputar Continuous Integration (CI) dari sudut pandang pengembang. Tantangan dari praktik CI ini sejauh yang gue tahu adalah kurangnya pemahaman terkait apa yang ingin didefinisikan di setiap fase yang ada.\nYang mana jawaban singkatnya adalah: Hal-hal yang kamu lakukan di mesinmu sendiri untuk menjalankan tugas X, itulah yang dilakukan di CI pipeline juga. Bedanya, tugas-tugas tersebut didefinisikan secara deklaratif.\nGue tidak bisa berbicara benefit praktik CI ini dari perspektif bisnis, tapi kalau dari sisi pengembang, jika lo males:\nMemastikan perubahan terkait kode yang ditulis memenuhi standar penulisan\nMemastikan bahwa perubahan tersebut berjalan sesuai kebutuhan, spesifikasi, dan kasus\nMemastikan bahwa perubahan tersebut tidak merusak fungsi yang sudah ada\nMelakukan rilis\n...secara manual, besar kemungkinan organisasi lo harus menggunakan sistem CI!\nSebagai penutup, otomatisasi bukanlah solusi untuk setiap masalah, pasti masih harus ada sentuhan tangan manusia, karena benefitnya adalah untuk membantu dan bukan untuk mengganti. \nJika organisasimu belum menerapkan sistem CI dan kamu belum terlalu berani untuk mengusulkannya, mungkin bisa mempertimbangkan untuk membagikan tulisan ini ke organisasimu?\nSemoga tulisan ini mencerahkan & berguna, jika terdapat salah paham; konsep, penulisan atau apapun itu, tolong bisa diutarakan di kolom komentar dibawah.\nThank you!","tags":"devops","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-09-04T14:26:26","created_at":"2021-09-04T18:18:22.871978","updated_at":"2021-09-04T18:18:22.871978","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2920,"title":"Design Pattern: Strategy Pattern (Bahasa Indonesia) | CodingClass S1 ⦁ E9","url":"https://www.youtube.com/watch?v=-H74s-aTMrU","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-04T03:33:39","created_at":"2021-09-02T12:25:10.385763","updated_at":"2021-09-02T12:25:10.385763","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2922,"title":"Eps. 57 - Empowering Youth Through Informal Education","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--57---Empowering-Youth-Through-Informal-Education-e16r6jo","body":"CEO Global Millennial Group, Fikri, kali ini ngobrol tentang bagaimana dia berkontribusi untuk ikut ikut mengembangkan para pemuda melalui pendidikan formal. Yuk simak!\nhttps://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-09-03T06:59:27","created_at":"2021-09-03T12:25:51.319821","updated_at":"2021-09-03T12:25:51.319821","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2921,"title":"Evan Purnama, Jatuh Bangun Bersama Qiscus","url":"https://anchor.fm/ceritanya-developer/episodes/Evan-Purnama--Jatuh-Bangun-Bersama-Qiscus-e16rhd3","body":"Sebagai co-founder, kita dituntut untuk bisa mengembangkan startup yang kita bangun agar bisa terus tumbuh dan mendapatkan revenue. Hal ini membutuhkan kemampuan leadership yang harus terus dilatih.\n\n\"Untuk mengasah kemampuan ini kita harus melatih zoom in dan zoom out. Kita harus melihat secara luas sebetulnya produk kita itu bagaimana dan arahnya mau kemana. Tapi di sisi lain kita harus bisa zoom in sampai bisa melacak errornya di mana dan nyambung di servis apa,\" ujar Co-founder sekaligus CTO Qiscus.\n\nPenasaran mengenai jatuh bangunnya Evan Purnama dalam membangun Qiscus. Dengerin ceritanya developer sampai tuntas karena akan ada info hiring di akhir episode.","tags":"","media":"podcast","thumbnail":null,"owner":"Riza Fahmi","draft":false,"original_published_at":"2021-09-03T03:14:36","created_at":"2021-09-03T06:19:20.929112","updated_at":"2021-09-03T06:19:20.929112","deleted_at":null,"source_id":3,"contributor":"rizafahmi"},{"id":2941,"title":"Cara Saya Belajar Pemrograman","url":"https://rahmatagungjulians.tech//blog/cara-saya-belajar-pemrograman","body":"Saya ingin membagikan metode belajar pemrograman yang Saya gunakan untuk mempelajari hal baru dan menambah pengetahuan.","tags":"sharing","media":"web","thumbnail":null,"owner":"rahmatagungj@gmail.com (Rahmat Agung Julians)","draft":false,"original_published_at":"2021-09-03T00:00:00","created_at":"2021-09-06T18:18:44.654348","updated_at":"2021-09-06T18:18:44.654348","deleted_at":null,"source_id":73,"contributor":"Rahmat Agung Julians"},{"id":2919,"title":"Cara membuat dependency dropdown wilayah Indonesia dengan Laravel, jQuery, Laravolt","url":"https://syofyanzuhad.medium.com/cara-membuat-select-wilayah-indonesia-dengan-ketergantungan-laravel-jquery-laravolt-96524cce3d81?source=rss-d7cef7a111e9------2","body":null,"tags":"laravolt,laravolt-indonesia,laravel,wilayah-indonesia,select","media":"tulisan","thumbnail":null,"owner":"Syofyan Zuhad","draft":false,"original_published_at":"2021-09-02T07:54:57","created_at":"2021-09-02T12:25:08.976577","updated_at":"2021-09-02T12:25:08.976577","deleted_at":null,"source_id":74,"contributor":"Syofyan Zuhad"},{"id":2916,"title":"Deploy Website dengan AWS Amplify #CloudJam","url":"https://www.youtube.com/watch?v=eQ6PoJtivZw","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-01T03:53:40","created_at":"2021-08-31T12:25:19.482755","updated_at":"2021-08-31T12:25:19.482755","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2917,"title":"Use Existing Postman Collections with Monika: An Alternative Solution to Postman Monitoring","url":"https://medium.com/hyperjump-tech/use-existing-postman-collections-with-monika-an-alternative-solution-to-postman-monitoring-770572eedb2c?source=rss----fabfd42372dc---4","body":null,"tags":"monitoring,postman-collections,postman,monika,synthetic-monitoring","media":"tulisan","thumbnail":null,"owner":"Denny Pradipta","draft":false,"original_published_at":"2021-08-31T11:06:39","created_at":"2021-08-31T12:25:46.919367","updated_at":"2021-08-31T12:25:46.919367","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2911,"title":"[mks.py] Python Continuous Integration With Github Action","url":"https://www.youtube.com/watch?v=D2da7lMS7wE","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-28T18:31:44","created_at":"2021-08-28T06:18:38.794842","updated_at":"2021-08-28T06:18:38.794842","deleted_at":null,"source_id":28,"contributor":"oon"},{"id":2914,"title":"Automate Resizing Bulk Images Using Libvips","url":"https://www.evilfactorylabs.org/fahmifan/automate-resizing-bulk-images-using-libvips-54a5","body":"Original post: fahmifan.id/blog/automate-resizing-bulk-images-using-libvips\nWith the growing popularity of ShopeeFood, many restaurants were applying for partnership with them, included my relative's Padang restaurant. But, their registration was not easy. They need a photo for each menu to be in a format of 720x720 px. For a Padang restaurant with over 50 menus and unfortunately the restaurant's menu photos were in different sizes.  \nI was too lazy to resized them manually. At first, I search for a service that could resize an image. But they weren't able to resize so many images at once. So I thought to write a program to automate this.\nbimg.\nThe code was pretty simple, we only need to iterate all of the photos in a directory. Then, for each of photo, resize it into 720x720 px. But, because the photos are not all squares, we can't use the Resize method instead, we use ResizeAndCrop that will resize the photos into 720x720 px and crop it fill to center\nimport (\n    \"fmt\"\n    \"path\"\n\n    \"github.com/h2non/bimg\"\n)\n\nvar root = \"/menu-photos\"\nvar outdir = \"/menu-photos/720x720\"\n\nfunc resize(filepath, filename string) error {\n    buf, err := bimg.Read(filepath)\n    if err != nil {\n        return err\n    }\n\n    img := bimg.NewImage(buf)\n    size, err := img.Size()\n    if err != nil {\n        return err\n    }\n\n    newImage, err := img.ResizeAndCrop(720, 720)\n    if err != nil {\n        return err\n    }\n\n    size, err = bimg.NewImage(newImage).Size()\n    if err != nil {\n        return err\n    }\n\n    if size.Width != 720 || size.Height != 720 {\n        fmt.Printf(\"wrong size: '%s' %vx%v\\n\", filename, size.Width, size.Height)\n    }\n\n    fmt.Printf(\"resize & crop: %s\\n\", filename)\n    return bimg.Write(path.Join(outdir, filename), newImage)\n}\n\nTo make the code faster, we can utilized goroutine. Here i spawned 4 goroutine that resize the images concurently.\ntype resizeJob struct {\n    FilePath string\n    FileName string\n}\n\nfunc main() {\n    jobChan := make(chan resizeJob, 4)\n\n    wg := &sync.WaitGroup{}\n    nworker := 4\n    // spawn workers\n    for i := 0; i < nworker; i++ {\n        wg.Add(1)\n        go worker(wg, jobChan)\n    }\n\n    err := filepath.Walk(root, func(path string, info fs.FileInfo, err error) error {\n        if info.IsDir() {\n            return nil\n        }\n        // enqueue jobs\n        jobChan <- resizeJob{FilePath: path, FileName: info.Name()}\n        return nil\n    })\n    close(jobChan)\n    if err != nil {\n        fmt.Fprintln(os.Stderr, err.Error())\n        return\n    }\n\n    // wait for workers to finished\n    wg.Wait()\n    fmt.Println(\"done\")\n}\n\nfunc worker(wg *sync.WaitGroup, jobChan chan resizeJob) {\n    defer wg.Done()\n    for file := range jobChan {\n        err := resize(file.FilePath, file.FileName)\n        if err != nil {\n            fmt.Fprintln(os.Stderr, err.Error())\n        }\n    }\n}\n\nCredits\nAngèle Kamp on Unsplash","tags":"livips,go,resize,image","media":"tulisan","thumbnail":null,"owner":"Fahmi Irfan","draft":false,"original_published_at":"2021-08-28T13:44:56","created_at":"2021-08-28T18:18:15.990317","updated_at":"2021-08-28T18:18:15.990317","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2912,"title":"#14: Ahmad Riza - Berkenalan Dengan Pemrogram Di Industri Minyak Bumi","url":"https://ujung.ee/eps-14-ahmad-riza-pemrogram-industri-perminyakan/","body":"Di episode ke-14, kali ini kami akan membahas soal pekerjaan pemrogram di industri yang nampak membosankan: industri perminyakan. Eits, tapi jangan salah, walaupun kesannya membosankan tapi ternyata pekerjaan pemrogram di sana seru lho. Tamu kami kali ini namanya Ahmad Riza, berkarir sebagai pemrogram di industri perminyakan sepanjang hidupnya. Semoga membuka wawasan baru untuk para pendengar Ujung ke Ujung.","tags":"","media":"podcast","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-28T10:00:00","created_at":"2021-08-28T06:18:45.194466","updated_at":"2021-08-28T06:18:45.194466","deleted_at":null,"source_id":24,"contributor":"naufaldi"},{"id":2910,"title":"Troubleshooting Framework","url":"https://anchor.fm/deep-tech/episodes/Troubleshooting-Framework-e16eei2","body":"Setelah aplikasi live di production, maka cepat atau lambat developer pasti akan menemui production issues. Misalnya bug atau outage yang sangat mempengaruhi pelanggan, sehingga menyebabkan kerugiaan jutaan rupiah bagi perusahaan. \nMakanya penting banget bagi semua developer untuk memiliki kemampuan troubleshooting agar permasalahan di production bisa segera diatasi. Untuk itu, kita akan ngobrol-ngobrol dengan Giri Kuncoro, Senior System Engineer di Gojek agar kita bisa lebih paham nih tentang troubleshooting ini.","tags":"","media":"podcast","thumbnail":null,"owner":"deep tech foundation","draft":false,"original_published_at":"2021-08-27T08:02:06","created_at":"2021-08-27T12:25:34.528379","updated_at":"2021-08-27T12:25:34.528379","deleted_at":null,"source_id":4,"contributor":"hilmanski"},{"id":2913,"title":"2. Konversi Alpa dan Reduksi Beta | Kalkulus Lambda","url":"https://www.youtube.com/watch?v=ZIXy14Ym7k0","body":"Halo semua.Pada video kali ini menyampikan tentang konversi alpa dan reduksi beda dari ekspresi lambda.Konversi alpa melakukan perubahaan simbol variabel tan...","tags":"fungsional programming, kalkulus lambda","media":"video","thumbnail":"https://i.ytimg.com/vi/ZIXy14Ym7k0/maxresdefault.jpg","owner":"Idiosemantik","draft":false,"original_published_at":"2021-08-27T00:00:00","created_at":"2021-08-28T06:49:04.602377","updated_at":"2021-08-28T06:49:04.602377","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2801,"title":"Belajar Html #1.Struktur Html","url":"https://tntteknologi.blogspot.com/2021/05/belajar-html-1struktur-html.html","body":"Belajar Html #1.Struktur dasar Html\n  \n\n\n  Assalamualaikum wr wb\n  Kembali lagi di tutorial Html untuk pemula, kali ini kita akan membahas   mengenai struktur dari Html, apa saja yang akan kita bahas, mari kita simak   berikut ini. \n\n\nStruktur dasar Html\n     Pada dasarnya struktur dasar html itu terdiri dari dua bagian   yakni bagian head dan body yg dibungkus antara tag html. \n  \n\n\nStruktur dasar html\n\n\n\n\n    Seperti gambar diatas. Bagian tag pada html mirip seperti sandwich dan   tag penutup pada html biasa ditandai dgn tanda slash \"/\" pada akhir tag nya..   lantas apa saja fungsi dari si tag head dan body ini? Untuk itu mari kita   simak uraian berikut ini. \nFungsi tag head\n  Secara umum tag <head> berfungsi untuk menampung metadata atau deskripsi   dari sebuah data, dan tag ini ditempatkan diantara tag <html> dan   <body> \n  Metadata ini bisa berupa data dari sebuah dokumen html yang berupa deskripsi   dokumen, definisi judul, karakter set, style halaman, keyword dan sebagainya. \n  Tag yang bisa menjadi element pada tag head\n\n  \n<title> wajib untuk setiap file html\n  \n<Style>\n  \n<base>\n  \n<link>\n  \n<meta>\n  \n<script>\n  \n<noscript>\n\nDefinisi tag title\n  Tag ini umumnya digunakan untuk memberi nama sebuah halaman pada tab di web   browser kalian, tag title hanya bisa diisi oleh teks saja tanpa disertai   gambar atau link didalamnya, tag ini diperlukan pada setiap file Html. \n  Element dari title ini sangat diperlukan untuk SEO (search engine   optimisation) karena digunakan dalam algoritma search engine. \n\n  Hal yang perlu diperhatikan dalam penulisan title\n  \n\n  Jangan membuat judul terlalu panjang lebih dari 60 karakter\n  \n                    \nseperti pada gambar di atas, judul yang terlalu panjang tidak baik untuk   sebuah tampilan web karena tidak semua isi judul tersebut ditampilkan dalam   tab browser anda maka dari itu usahakan lah membuat judul sesederhana mungkin   yang tidak terlalu panjang dan terlalu pendek. \n\n\n  Buatlah judul seakurat mungkin dengan isi web\n  \n                \n  Hal ini juga perlu diperhatikan apabila ingin membuat sebuah website. Pasalnya   tak sedikit user yang meninggalkan suatu website dikarenakan konten yang   kurang relevan dengan kebutuhan pembaca, so pastikan agar judul halaman mu   sesuai ya.. \n\n\n  Catatan :Tag title tidak bisa dibuat lebih dari satu tag dalam satu   dokumen. \n\n\nFungsi tag body\n   Fungsi dari tag <body> adalah untuk menampilkan isi   dari dokumen Html pada browser. Jika isi dari tag   <head> tidak ditampilkan. Maka tag body adalah kebalikannya. \n\n\n   Tag ini bisa menampung seluruh elemen yg ditampilkan pada browser   seperti paragraf, teks, gambar, link, list, tabel, dan lain-lain, perlu   diingat juga bahwa tag <body> hanya boleh ada satu disetiap file   Html. \n\n\n  \nArtikel terkait\n  \n    \n      \n        Html #0. pengenalan apa itu HTML      \n      \n        Belajar Css untuk pemula #0. pengenalan\n      \n    \n  \n\n\n  Nah mungkin itu saja pembahasan kita mengenai Struktur Html, mudah mudahan   bermanfaat untuk kalian yang lagi belajar tentang pemrograman web. Kami akan   terus update lagi perkembangan artikel ini jadi mohon maaf jika ada yang   kurang, Sekian, Wassalamu'alaikum wr wb.","tags":"[object Object],[object Object]","media":"web","thumbnail":null,"owner":"noreply@blogger.com (Cloudys Dev)","draft":false,"original_published_at":"2021-08-25T15:46:00","created_at":"2021-07-17T00:32:13.971247","updated_at":"2021-07-17T00:32:13.971247","deleted_at":null,"source_id":68,"contributor":"Cloudys dev"},{"id":2908,"title":"Konsep Pemrograman Fungsional dengan Elixir","url":"https://www.youtube.com/watch?v=xfveTGjyXFw","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-25T09:00:32","created_at":"2021-08-25T12:25:28.637268","updated_at":"2021-08-25T12:25:28.637268","deleted_at":null,"source_id":72,"contributor":"Riza Fahmi"},{"id":2907,"title":"Sinkronisasi VSCode biar bisa dipakai di mana aja. ","url":"https://www.evilfactorylabs.org/petruknisme/sinkronisasi-vscode-biar-bisa-dipakai-di-mana-aja-2enf","body":"Jadi gini, dulu sempet kepikiran apa vscode ini bisa dicopy ya ekstensinya atau dibackup gitu loh biar kalau pindah perangkat nggak diatur ulang. Nah, abis searching-searching nemu deh kalau ternyata vscode itu bisa sinkronisasi pengaturan, ekstensi dan sebagainya. \nBegini caranya, yang pertama klik Code -> Prefence -> Turn on Setting Sync\nTulisan ini pakai osx, jadi disesuaikan sama platform masing-masing ya untuk menu Sync Settings nya. Setau saya kalau di windows/linux itu File -> Preference.\n\nSehabis itu akan muncul welcome message dan pilihan-pilihan. Klik Sign in & turn on\n\nPilih metode sign in, kalau saya menggunakan github.\n\nVscode akan membuka jendela browser, ikuti perintah yang diberikan untuk authorize. \n\nKalau prosesnya berhasil dia bakal ada popup open link nya via vscode.\n\n\nNah, vscode udah tersinkronisasi nih. Keren kan!\n\n\nDengan gini, jadi mudah banget kalau pindah perangkat semuanya terhubung dengan baik. Yey!","tags":"development,vscode","media":"tulisan","thumbnail":null,"owner":"petruknisme","draft":false,"original_published_at":"2021-08-24T07:05:41","created_at":"2021-08-24T12:25:13.595302","updated_at":"2021-08-24T12:25:13.595302","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2905,"title":"Visualizing Monika Data with Prometheus and Grafana","url":"https://medium.com/hyperjump-tech/visualizing-monika-data-with-prometheus-and-grafana-bee8c6feb9d3?source=rss----fabfd42372dc---4","body":null,"tags":"monika,open-source,grafana,monitoring,prometheus","media":"tulisan","thumbnail":null,"owner":"Denny Pradipta","draft":false,"original_published_at":"2021-08-24T04:28:08","created_at":"2021-08-24T06:19:35.976941","updated_at":"2021-08-24T06:19:35.976941","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2906,"title":"Terima Kasih Tahun 2021","url":"https://rahmatagungjulians.tech//blog/terima-kasih-tahun-2021","body":"Semua hal mengenai apa yang saya pelajari dan saya dapatkan pada tahun 2021. Banyak sekali Teknonologi baru, tempat kursus dan saluran Youtube yang saya gunakan untuk belajar.","tags":"story","media":"web","thumbnail":null,"owner":"rahmatagungj@gmail.com (Rahmat Agung Julians)","draft":false,"original_published_at":"2021-08-24T00:00:00","created_at":"2021-08-24T12:25:13.059588","updated_at":"2021-08-24T12:25:13.059588","deleted_at":null,"source_id":73,"contributor":"Rahmat Agung Julians"},{"id":2904,"title":"The Fediverse Experience","url":"https://www.evilfactorylabs.org/sandycorzeta/the-fediverse-experience-5d9o","body":"Disclaimer\nTulisan ini sebelumnya aku tulis pada akun pribadi facebook sendiri beberapa bulan lalu. Berhubung aku sudah tidak lagi menggunakan facebook dan menghapus akunnya sejak Juni kemarin, jadi aku tulis ulang di platform ini.\nSebenarnya aku menulis ini sedang dalam keadaan mengantuk namun ingin kepala dan hati berbagi secara pribadi tentang pengalamanku menggunakan media sosial yang terdesentralisasi. Benar sekali, media sosial tersebut merupakan Fediverse. Apa itu Fediverse? Aku menyebutnya sebagai \"Dunia Federasi\". Wow, keren... seperti istilah yang ada di cerita-cerita sci-fi. Bukan begitu bodoh, itu aku menerjemahkan secara literal aja. Selengkapnya nanti aku jelaskan deh. Tapi, yang pertama aku ceritakan dulu bagaimana awal perkenalanku dengan fediverse.\nPada tahun sekitaran 2016 aku dulu sempat mencari media sosial alternatif yang memiliki kemiripan seperti twitter dan facebook. Disaat itu aku menemukan sebuah website yang memiliki domain bernama shitposter.club. Berhubung di tahun 2016-an tersebut aku sangat aktif sekali dan menggemari hal yang terkait shitposting dan meme, dari nama domain tersebut aku tertarik dan mencoba mendaftar. Sayangnya, disaat itu aku tidak aktif di situs tersebut dan mengabaikan akunku. Hingga pada akhirnya di akhir tahun 2020, aku mulai melirik kembali media sosial yang terdesentralisasi dan mulai sadar mengenai privasi digital. Sekitar Oktober 2020 aku mendaftar di mastodon.social untuk mengawali kembali dan mencoba mencari relasi baru selagi berhenti aktivitas dari facebook. Dalam satu bulan aku cukup mulai terbiasa dan mendapatkan relasi baru. Tapi aku di mastodon.social tidaklah begitu lama dan menghapus akunku sampai aku menemukan misskey.io dan berakhir menjadi pengguna disana hingga saat ini.\nTerima kasih sudah mendengarkan perkenalanku dengan fediverse. Jadi, sebenarnya Fediverse itu apa sih? Fediverse merupakan gabungan dua kata dari Federation dan Universe yang dapat diartikan sebagai semesta dari kumpulan berbagai federasi. Umumnya banyak pengguna dari fediverse menyebutnya sebagai fedi. Fediverse sendiri dibangun dari konsep desentralisasi dimana sebuah layanan itu tidak terpusat ke dalam satu tempat/pemilik/platform (seperti Facebook, Twitter, Google, etc) dan setiap orang memiliki hak serta kemampuan untuk menyediakan, memiliki ataupun berkontribusi pada layanan tersebut.\nKarena tidak berpusat di dalam satu tempat ini, fediverse memiliki banyak ribuan server tersedia yang umumnya disebut instance dan itu terhubung semuanya bersama dalam satu standar protokol resmi dari W3C yang dinamakan ActivityPub. Keunggulan lain dari fediverse sendiri ialah tidak rentan terhadap sensor karena apabila kamu diblokir atau di*ban* dari satu instance, kamu cukup pindah ke instance lain. Selain itu, keuntungan dari desentralisasi kamu dapat memilih lingkungan instance yang ingin kamu ikuti. Setiap instance memiliki peraturan berbeda, ada yang mempromosikan bebas bicara tanpa rasa baper ataupun memilih untuk membatasi yang membentuk lingkungan safe-space.\nBerkomunikasi di fediverse tidaklah berbeda seperti berkomunikasi di media sosial pada umumnya, malahan memiliki keuntungan yang tidak dimiliki media sosial yang tersentralisasi. Apakah kamu pernah membayangkan jika postingan Facebook kamu dikomentari oleh seseorang dari Twitter melalui situs Twitter langsung tanpa harus dia mendaftar ke Facebook?. Dalam fediverse, kita bisa melakukan itu dan semua berkat standar protokol ActivityPub. Aku akan sedikit memberi penjelasannya menggunakan analogi dimana protokol ActivityPub adalah seperti email. Sebuah email umumnya disediakan oleh banyak penyedia layanan seperti Gmail, Yahoo, Protonmail, Tutanota, dll. Dari banyaknya penyedia layanan tersebut kita bisa berkomunikasi apabila kita mengetahui domain beserta username yang terdaftar.\nSebagai contoh, A memiliki email beralamat aku@gmail.com dan B memiliki email beralamat dia@yahoo.com. Keduanya dapat berkomunikasi mengirim surat satu sama lain selama mengetahui domain beserta username mereka masing-masing. Pada fediverse, ActivityPub-lah yang menggantikan peran email ini. Gmail, Yahoo, dan Protonmail dalam fediverse diibaratkan sebagai layanan server/platform yang mendukung protokol ActivityPub. Platform tersebut diantaranya seperti Mastodon, Pleroma, Misskey, Pixelfed, dll. Sama seperti email, berkat ActivityPub meskipun kita berbeda instance maupun platform, kita masih tetap dapat berkomunikasi seperti di media sosial umumnya, baik itu membaca status, follow, mention, direct messages dll. Semisal, bila aku yang terdaftar di instance misskey.io dengan username sandycorzeta, orang lain dapat mencari, mention atau melihat profilku di instance mereka sendiri dengan mengetikkan @sandycorzeta@misskey.io di pencarian atau beranda mereka tanpa harus repot-repot pergi dan mendaftar ke website instance dimana aku terdaftar.\nSekarang, kalian sudah tahu apa itu fediverse dan bagaimana cara bekerjanya. Lalu, apa yang menarik dan bisa diambil dari pengalamanku berkelana di fediverse ini?. Dapat kukatakan kalau di fediverse, semua hal yang terjadi sangatlah begitu personal dan lebih terfokus kepada komunitas dimana kita terdaftarkan. Sempat aku mengibaratkan bahwa instance kecil seperti misskey.io yang menampungi 5000 user sendiri adalah sebuah kota kecil. Sedangkan instance besar seperti mastodon.social yang menampung 500rb lebih user adalah sebuah negara. Bagusnya dengan fediverse ini bagiku adalah aku dapat berkomunikasi dengan orang di luar instance tanpa harus keluar dari instanceku sendiri. Selain itu, tidak adanya algoritma highlight ataupun yg memanipulasi linimasa di beranda juga merupakan kelegaan tersendiri. Karena dengan begitu aku tidak perlu lagi capek memikirkan hal yang sudah terlewat dan belum tentu ada benefitnya bagiku.\nHal lain yang memberikanku pengalaman di fediverse ialah konsep \"dimana bumi dipijak disitu langit dijunjung\" yang cukup jelas dapat dilihat di berbagai instance yang ada. Adapun instance yang menampung pengguna dengan kebebasan berpendapat tanpa batas asal kamu mampu mempertanggung jawabkan pendapatmu. Beberapa seperti contohnya neckberd.xyz, poa.st, dan shitposter.club. Atau yang berbanding terbalik dimana instance yang menampung dan memberikan safe-space sembari memblokir sebagian instance tadi dengan membuat sebuah daftar yg disebut FediBlock. Selain itu, terdapat instance yang menyediakan topik tematik terbatas pada kegiatan, seperti mastodon.art (seni), mastodon.technology (teknologi), scholar.social (akademisi/riset), atau ihatebeinga.live (sadposting). Semuanya tersedia dan aku tinggal memilih mana yang diinginkan. Untungnya aku lebih memilih kepada instance yang umum dan dominan lebih banyak kepada pengguna orang jepangnya yaitu misskey.io. Alasan mengapa aku memilih karena aku menyukai layar antarmukanya yang modern dan kamu bisa memberi custom emoji react ke status orang lain (hanya Pleroma dan Misskey saja yg support fitur ini sekarang). Selain itu juga beberapa hari lalu aku menyempatkan untuk menerjemahkan antarmuka Misskey ke Bahasa Indonesia melalui repo Crowdin mereka. Jadi, ya setidaknya itu saja kontribusi yang bisa aku berikan.\nWaduh malah kemana mana ini ceritanya. Tapi tetep anyway, aku bakal menetap di fediverse untuk waktu kedepannya dan memungkinkan untuk membuat akun facebook-ku disini jadi zombie (now its dead, lmao). Dilain hal, semenjak banyak kejadian pencurian data dan kebijakan privasi yang makin menguntungkan korporat, aku makin meyakinkan diri untuk tidak lagi sembarangan menggunakan layanan yang proprietary. Karena itu juga, secara perlahan aku mulai menggunakan layanan ataupun aplikasi yang sebisa mungkin bebas (free as in freedom) bukan gratis (free as in beer). Karena gratis belum tentu bebas.\nYah, begitulah pengalamanku dengan fediverse selama kurang lebih hampir setengah tahun ini. Jikalau kalian punya pertanyaan silahkan komentar, atau bila berkenan kalian bagikan postingan ini untuk menambahkan awareness bagi yang tertarik untuk menyusuri fediverse. Aku juga bakal kasih tautan-tautan yang menarik dibaca tentang fediverse pada berakhirnya postingan ini.\nOh ya lupa... mungkin kalo aku ada biaya dan waktu lebih nantinya, aku bakal buka instance Misskey (atau mungkin Pleroma) lokal khusus Indonesia. Berhubung warga Indonesia masih banyak terpencar di fediverse (baru nemu beberapa pengguna yang bisa diitung jari) dan belum ada instance lokal sama sekali, jadi aku berinisiatif untuk melakukan itu.\nTerima kasih sudah membaca tulisanku, kawan. Mungkin di tulisan berikutnya akan aku kasih kurasi instance fediverse yg menarik untuk diikuti ya atau pengenalan beberapa plaform Fediverse dan fitur-fiturnya seperti Mastodon, Pleroma atau Misskey. Berhubung sudah gak kuat ngelanjutin nulisnya, sampai disini dulu ya. Sampai ketemu di fediverse ya!! ❤️😘\n👋\nTautan menarik :\nhttps://fediverse.party/en/fediverse (Tentang Fediverse)\nhttps://fediverse.party/en/portal/servers (Daftar kurasi instance server fediverse)\nhttps://blog.soykaf.com/post/how-federation-works/ (Cara kerja federasi di Fediverse)\nhttps://www.youtube.com/watch?v=S57uhCQBEk0 (Mastodon & Fediverse Explained)\nhttps://www.youtube.com/watch?v=yZoASOyfvGQ (Decentralized Social Networks vs Trolls)","tags":"indieweb,fediverse,socialmedia","media":"tulisan","thumbnail":null,"owner":"Sandy Corzeta","draft":false,"original_published_at":"2021-08-23T12:48:08","created_at":"2021-08-23T18:20:47.264463","updated_at":"2021-08-23T18:20:47.264463","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2903,"title":"Tentang Saya 1 Tahun Bersama Progate","url":"https://rahmatagungjulians.tech//blog/progate","body":"Kemarilah, saya ceritakan bagaimana cara saya belajar cepat hingga menjadi mahir dalam programming.","tags":"review","media":"web","thumbnail":null,"owner":"rahmatagungj@gmail.com (Rahmat Agung Julians)","draft":false,"original_published_at":"2021-08-23T00:00:00","created_at":"2021-08-23T18:20:42.335451","updated_at":"2021-08-23T18:20:42.335451","deleted_at":null,"source_id":73,"contributor":"Rahmat Agung Julians"},{"id":2901,"title":"Lesson Learned Menulis Websocket dengan Gorilla dan Go #Techtalk","url":"https://www.youtube.com/watch?v=MjvaWbwsN0Y","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-22T04:16:29","created_at":"2021-08-20T18:19:26.444787","updated_at":"2021-08-20T18:19:26.444787","deleted_at":null,"source_id":62,"contributor":"PuloDev"}],"total":1415}