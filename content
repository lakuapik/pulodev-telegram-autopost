{"data":[{"id":2857,"title":"😎 Awesome Indonesia","url":"https://github.com/fransallen/awesome.id","body":"Daftar produk, proyek, acara dan sumber daya lainnya yang dibuat oleh developer dan founder dari Indonesia.","tags":"awesome, open source, indonesia, saas, product","media":"web","thumbnail":"https://opengraph.githubassets.com/5ae19ae4e35f05cda7234520c88f0b6c0b2b2b4b4ea0f71a4c1ee856b3953498/fransallen/awesome.id","owner":"@fransallen","draft":false,"original_published_at":"2021-08-06T07:45:37.523","created_at":"2021-08-06T07:49:07.486213","updated_at":"2021-08-06T07:49:07.486213","deleted_at":null,"source_id":null,"contributor":"@fransallen"},{"id":2856,"title":"Cara Membuat JSON Web Tokens tidak Valid","url":"https://hellodit.medium.com/cara-membuat-json-web-tokens-tidak-valid-4e25615826e?source=rss-bec8db944a8e------2","body":null,"tags":"json-web-token,rest-api,jwt,programming","media":"tulisan","thumbnail":null,"owner":"Asdita Prasetya","draft":false,"original_published_at":"2021-08-04T03:29:13","created_at":"2021-08-04T06:12:47.128271","updated_at":"2021-08-04T06:12:47.128271","deleted_at":null,"source_id":51,"contributor":"hellodit"},{"id":2855,"title":"Berkenalan dengan OpenAPI 2.0/Swagger","url":"https://gadiskoding.my.id/berkenalan-dengan-openapi-2-0-swagger.html","body":"Membuat dokumentasi api sekaligus membangkitkanya.","tags":"restapi,openapi,web","media":"web","thumbnail":"/images/og.png","owner":"Gadis Koding","draft":false,"original_published_at":"2021-08-03T13:59:14.735","created_at":"2021-08-03T13:59:57.456211","updated_at":"2021-08-03T13:59:57.456211","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2854,"title":"Jatuh Bangun Menjalani Bisnis Software Consulting Firm","url":"https://www.youtube.com/watch?v=1L7_rf-at0g","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-03T12:00:02","created_at":"2021-08-03T12:15:28.329283","updated_at":"2021-08-03T12:15:28.329283","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2853,"title":"Eps. 55 - Jatuh Bangun Membangun Software Consulting Firm ","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--55---Jatuh-Bangun-Membangun-Software-Consulting-Firm-e15a194","body":"Gw banyak dapet ilmu dari obrolan bareng Sidiq & Taufan, co-founder Nusantara Beta Studio, tentang apa yang pelajaran mereka ketika ngebangung bisnis software consulting. Simak aja!\nhttps://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-08-03T01:00:00","created_at":"2021-08-03T06:12:13.725109","updated_at":"2021-08-03T06:12:13.725109","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2852,"title":"Membuat Backend Sistem Notifikasi Saweria dengan Server Side Event (SSE) dan Google Cloud Pub/Sub","url":"https://www.youtube.com/watch?v=9RMS4Y0xXa4","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-03T00:34:40","created_at":"2021-08-03T00:37:24.452288","updated_at":"2021-08-03T00:37:24.452288","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2851,"title":"Thread twitter pelajaran dari proyek bersama WargaBantuWarga ","url":"https://twitter.com/deeptech_id/status/1422162040089575425","body":"","tags":"opensource","media":"tulisan","thumbnail":"","owner":"Twitter Deep Tech","draft":false,"original_published_at":"2021-08-02T23:43:28.697","created_at":"2021-08-02T23:44:48.698456","updated_at":"2021-08-02T23:44:48.698456","deleted_at":null,"source_id":null,"contributor":"hilmanski"},{"id":2850,"title":"Bermain - main dengan awk, tail, dan head","url":"https://www.evilfactorylabs.org/adiatma/bermain-main-dengan-awk-tail-dan-head-3l6n","body":"Oke jadi kali ini gw mau share dikit soal, awk, tail dan head di bash, dan yang paling penting awk sih, karena awk mendukung operasi logic, beda dengan tail, dan head yang hanya sekedar filter biasa doankkkkkkhhh.\nBiasanya enaknya ngabahas sesuatu itu diiringi dengan contoh, biar gak bosan dan tau implementasinya kayak gimana.\nSetelah beberapa menit mikir sambil seruput kopi hangat, rasanya cocok untuk bahas soal nge cetak local ip di antarmuka terminal tercintaahh kalian, dengan menggunakan ifconfig di mac os, dan ip di linux.\nOke contoh yang pertama.\n$ ifconfig\n\nOutputnya kayak dibawah ini nih\n\nNah kesel banget kan liat outputnya yang sebanyak itu.\nOke sekarang biar gak kesel kita akan kombinasikan perintah ifconfig dengan kawan - kawan filternya.\n\nNah sekarang gimana udah lumayan kan?, oke kita lanjut lagi buat nge filter biar terlihat lebih oke dan maknyus.\n\nNah, sekarang udah keren, nah selanjutnya jika butuh untuk nge filter baris kalian butuh tail atau head. karna gw mau tampilin local ip yang paling bawah maka gw pake tail, contohnya kayak gini.\nifconfig | grep inet | awk '{print $2}' | awk '$0 ~ /^[1-9]/{print $0}' | tail -n 1\n\nHasilnya kayak gini.\n172.16.10.4\n\nNah sekarang udah oke, selanjutnya kita akan coba dengan perintah ip di mesin linux. \nOke bentar gw coba untuk ssh dulu ke mesin raspberry gw.\n\nYup, udah berhasil masuk, sekarang coba lagi buat masukin perintah ip a.\n\nOops... gimana kesel kan?\nOke sekarang kita filter lagi, kita coba untuk pakai grep dulu buat nge filter text dengan tulisan global, contohnya kayak gini.\n\nOh iya, yang karakter ini | artinya pipe, artinya akan di proses dari kiri ke kanan, jadinya kiri dulu baru ke kanan, yang ip a dulu hasilnya keluar baru lanjut ke perintah selanjutnya.\nOke kita lanjut lagi ya filternya, selanjutnya adalah bermain dengan awk lagi nih, buat ngambil kolom ke dua, di awk bisa pakai kayak gini awk '{print $2}' nah yang symbol dollar dua itu artinya kolom ke dua.\n\nNah, jadinya kayak gini, gimana mudah kan? \nSelanjutnya cukup pakai head atau tail aja, karena tadi udah pake tail skarang kita pakai head buat ngambil list ip di awal, dannnnn....\n\ntaraaaaa...., mantap!","tags":"bash,jaringan,scripting,cli","media":"tulisan","thumbnail":null,"owner":"Adiatma Kamarudin","draft":false,"original_published_at":"2021-08-02T14:08:08","created_at":"2021-08-02T18:11:47.098321","updated_at":"2021-08-02T18:11:47.098321","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2849,"title":"Reverse Bitwise - Gemastik14 CTF","url":"https://www.evilfactorylabs.org/recursive/reverse-bitwise-gemastik14-ctf-3625","body":"Kemarin pas pemanasan gemastik14 kebagian soal reverse engineering, langsung aja bedah\nSoal :\nimport java.util.*;\n\npublic class KodeBit {\n  public static void main(String[] args) {\n    System.out.print(\"Enter Password: \");\n    Scanner s = new Scanner(System.in);\n    String user_key = s.next();\n    if (user_key.length() != 16) {\n      System.out.println(\"Wrong\");\n      return;\n    }\n\n    char[] verify_arr = {131,195,194,67,1,225,66,2,73,233,0,35,33,9,193,192};\n\n    ArrayList<Character> user_arr = new ArrayList<Character>();\n    char[] user_submitted_arr = user_key.toCharArray();\n\n    for (char ch : user_submitted_arr) {\n      user_arr.add((char)((((ch << 5) | (ch >> 3)) ^ 111) & 255));\n    }\n\n    int i;\n    for(i = 0; i < 16; i++) {\n      if (!user_arr.get(i).equals((char)verify_arr[i])) {\n        System.out.println(\"Wrong\");\n        return;\n      }\n    }\n    System.out.println(\"Success\");\n  }\n}\n\nthe key is here :\n for (char ch : user_submitted_arr) {\n      user_arr.add((char)((((ch << 5) | (ch >> 3)) ^ 111) & 255));\n    }\n\nBuat solving pake python :\nverify_arr = [131,195,194,67,1,225,66,2,73,233,0,35,33,9,193,192]\nkey = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\nfor i in range(16):\n    for k in range(128):\n        if verify_arr[i] == (((k << 5) | (k >> 3)) ^ 111) & 255:\n            key[i] = chr(k)\n\nflag = ''\nfor i in key:\n    flag += i\n\nprint(flag)\n\n\n\n\n\n\n\n  \n  \n  Flag : gemastik14{br3u}","tags":"ctf,reverseengineering","media":"tulisan","thumbnail":null,"owner":"Purgatorio","draft":false,"original_published_at":"2021-08-01T03:28:30","created_at":"2021-08-01T06:12:35.007347","updated_at":"2021-08-01T06:12:35.007347","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2848,"title":"Mengenal dan mengapa menggunakan Function as a Service (FaaS)","url":"https://www.evilfactorylabs.org/faultable/mengenal-dan-mengapa-menggunakan-function-as-a-service-faas-1c4c","body":"Ini adalah bagian dari topik cloud, jika kamu belum terlalu familiar dengan konsep komputasi awan, mungkin bisa mempertimbangkan untuk membaca tulisan berjudul Mengenal \"Cloud\" untuk Software Developer terlebih dahulu.\nDewasa ini (anjay dewasa) proses deployment sebuah layanan ataupun aplikasi sudah semakin beragam khususnya untuk platform web yang melakukan komputasi dibagian server. Dari yang sebelumnya mungkin mendistribusikannya sebagai CGI script, dilanjutkan dengan sebuah berkas be-ekstensi php, lalu sampai ke sebuah berkas arsip yang biasa disebut dengan docker image yang sekarang umum digunakan.\nApapun pendekatan yang dipilih, tujuan utamanya adalah satu: agar dapat memproses sesuatu, dibagian server. Entah untuk alasan keamanan, privasi, ataupun karena pengguna akhir tidak layak untuk melakukan proses tersebut.\nSalah satu keunggulan komputer yang disebut dengan server adalah umumnya dia berjalan secara terus menerus, mungkin sebagaimana arti secara harfiahnya. Beda dengan personal computer (PC) yang memang tugasnya untuk melakukan kegiatan-kegiatan pribadi seperti menonton film ataupun memainkan permainan.\nServer pada dasarnya adalah sebuah komputer, yang berarti memiliki perangkat keras (pastinya) dan perangkat lunak termasuk sistem operasi. Dan jika ingin membuat program untuk pengguna internet, pastinya ada sebuah program berjenis web server yang bertugas untuk melayani permintaan masuk dan keluar.\nTidak sampai situ, ada satu lapisan lagi yang harus dimiliki oleh server: runtime program. Jika kamu ingin menjalankan aplikasi/layanan yang ditulis menggunakan PHP, mungkin kamu membutuhkan php-fpm. Jika itu JavaScript, mungkin itu Node.js. Jika itu C, mungkin libc ataupun musl.\nApakah sudah cukup sampai situ? Tentu tidak. Kamu pasti butuh Reverse proxy karena seharusnya pekerjaan-pekerjaan seperti SSL termination, compression, caching, dsb bukanlah tanggung jawab aplikasi/layanan yang kamu kembangkan.\nSebagai rekap, untuk membuat sebuah program yang menampilkan Hello World menggunakan JavaScript (Node.js), setidaknya komputer (server) kamu harus memiliki komponen berikut:\nSistem operasi (e.g: Ubuntu)\nReverse proxy (e.g: Caddy)\nRuntime program (e.g: Node.js)\nTidak menutup kemungkinan kamu harus tau juga tentang supervisor sehingga program-program yang kamu butuhkan bisa berjalan kembali secara otomatis baik setelah reboot ataupun setelah crash.\nBaiklah, mari kita coba menggunakan pendekatan tradisional terlebih dahulu. Anggap gue menggunakan Ubuntu dan sudah memasang Caddy dan Node.js di server gue, ya.\nPertama kita buat program sederhananya dulu menggunakan JavaScript, berikut kodenya:\n// server.js\nconst http = require('http')\n\nconst server = http.createServer(({ headers, socket }, res) => {\n  const ip = headers['x-forwarded-for'] || socket['remoteAddress']\n\n  res.statusCode = 200\n  res.setHeader('Content-Type', 'text/plain')\n  res.end(`Hello ${ip}\\n`)\n})\n\nserver.listen(8080, '127.0.0.1', () => {\n  console.log('server run at http://127.0.0.1:8080')\n})\n\nDengan menjalankan node server.js, program sederhana kita sudah bisa diakses melalui localhost:8080 yang mana setiap kali ada permintaan masuk ke path / dengan method GET (ataupun POST, DELETE, dsb) akan memberikan Hello {alamat ip} sebagai respon.\nKita ingin membuat program tersebut dapat diakses oleh pengguna internet, dan tidak lucu bila program kita tersebut diakses menggunakan kombinasi alamat ip + port secara langsung.\nDisini kita butuh Caddy sebagai Reverse Proxy. Dan sebagaimana reverse proxy pada umumnya, kita menggunakan SNI (think like virtual host) untuk melakukan service discovery atau menentukan upstream backend sederhananya.\n# Caddyfile\n\nfake.evilfactorylabs.org {\n  reverse_proxy * 127.0.0.1:8080\n}\n\nReverse proxy umumnya berjalan di port 80 (HTTP) dan 443 (HTTPS), setiap ada permintaan masuk ke fake.evilfactorylabs.org yang mana mengarah ke ip server tersebut, Caddy akan meneruskan permintaannya ke 127.0.0.1:8080 tempat dimana aplikasi tersebut bejalan.\nAktivitas diatas adalah effort minimum yang setidaknya harus dilakukan ketika mengembangkan aplikasi yang ditulis menggunakan JavaScript.\nJika melihat secara garis besar, berdasarkan contoh aplikasi diatas, satu hal yang benar-benar kita butuhkan hanyalah Node.js sebagai runtime. Harusnya kita tidak perlu peduli sistem operasi dan reverse proxy apa yang digunakan, khususnya jika aplikasi kita tidak berurusan dengan sistem operasi secara langsung (misal membuat tun device) ataupun ingin melakukan hal yang biasa dilakukan oleh reverse proxy (misal melakukan kompresi ke brotli).\nDan gue rasa, kebanyakan aplikasi web pun memiliki karakteristik yang sama.\nOke kita kembali ke konteks. Perlu diketahui bahwa tidak semua aplikasi cocok menggunakan pola FaaS, atau Serverless jika lebih familiar dengan sebutan tersebut.\nFaaS lebih cocok untuk melakukan hal-hal yang bersifat on-demand yang tidak perlu berjalan selamanya.\nMisal situs ini secara keseluruhan, meskipun secara teori bisa saja dibuat menggunakan pendekatan FaaS, namun tidak efektif, seperti, bayangkan harus menjalankan dan mematikan aplikasi yang dibuat menggunakan Ruby On Rails ini setiap kali ada permintaan masuk agar mungkin dapat menghemat biaya sekian rupiah perbulan.\nUntuk aplikasi Ruby fucking On Rails.\nMungkin bisa saja gue pisahkan si fungsi komentar yang ada di aplikasi ini, membuat function untuk mengatur event mengambil data komentar dan memproses komentar baru, lalu revalidate cache, tapi nanaonan (kalau kata orang Sunda mah).\nContoh sederhana yang cocok untuk menggunakan pendekatan FaaS adalah sistem notifikasi. Umumnya sistem notifikasi berjalan sebagai worker untuk memisahkannya dari thread utama agar aplikasi utama tidak memakan terlalu banyak memori. Karena ada pemisahan ini, umumnya juga ada komponen tambahan seperti queue system yang secara garis besar bertugas sebagai \"waiting room\" untuk si worker ini untuk mengatur setiap kali ada \"event\" masuk ataupun keluar.\nBayangkan ketika pengguna melakukan registrasi ke situs ini dan harus menunggu loading karena aplikasi ini sedang mengirim surel yang dituju ke SMTP server yang digunakan untuk mengirim surel verifikasi, yang entah berhasil ataupun gagal.\nNah itu jika 1 pengguna yang dalam waktu yang sama, ya.\nDengan menerapkan queue system, kita bisa melakukan misalnya hanya mengirim 10 email per-detik setiap ada event registrasi, misal untuk menghindari rate-limit dari SMTP server.\nKuncinya ada di event. Hal yang bisa dilakukan di worker, besar kemungkinan bisa dijadikan sebagai serverless function.\nDisini gue akan menggunakan contoh untuk Webhook dari layanan Saweria yang gue rasa cocok untuk contoh ini. \nSetiap kali ada saweran masuk, sistem Saweria akan mengirim permintaan POST beserta payloadnya ke sebuah endpoint yang sudah gue tentukan.\nDan setiap kali ada permintaan POST masuk di function gue, gue mengirim permintaan POST juga ke sebuah endpoint yang sudah sistem Discord tentukan.\nJadi disini ada 3 webhook:\nWebhook Saweria (bisa DM theo di Twitter HAHAHA)\nWebhook gue (via Cloudflare Workers)\nWebhook Discord (dokumentasi)\nGue gak tau kapan si Saweria ngirim POST ke gue, yang berarti layanan gue harus terus berjalan, kan? Gue bisa spin up VM (atau menggunakan VM yang sama) tapi gue gak mau berurusan dengan Node.js (dan OS) ataupun Docker hanya untuk menjalankan layanan ini.\nJadi gue menggunakan layanan Cloudflare Workers terlebih karena situs ini juga menggunakan layanan Cloudflare.\nKodenya relatif sederhana, misal jika tidak menggunakan KV storage nya Cloudflare seperti ini:\nconst DISCORD_WEBHOOK = 'https://discord.com/api/webhooks/xxx'\n\nasync function handlePost(request) {\n  try {\n    const requestPayload = await request.json()\n\n    const { donator_name, message, amount_raw } = requestPayload\n\n    const duit = new Intl.NumberFormat('id', {\n      style: 'currency',\n      currency: 'IDR'\n    })\n\n    const body = {\n      content: `**${donator_name}** baru saja menyawer **${duit.format(\n        amount_raw\n      )}** dengan pesan **_${message}_**`\n    }\n\n    const payload = {\n      body: JSON.stringify(body),\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      }\n    }\n\n    const response = await fetch(DISCORD_WEBHOOK, payload)\n\n    return new Response(JSON.stringify({ success: true }), payload)\n  } catch {\n    return new Response('<pre>noted</pre>', {\n      headers: {\n        'content-type': 'text/html'\n      }\n    })\n  }\n}\n\nasync function handleGet() {\n  return new Response('<pre>ok</pre>', {\n    headers: {\n      'content-type': 'text/html'\n    }\n  })\n}\n\naddEventListener('fetch', event => {\n  const { request } = event\n\n  if (request.method === 'POST') {\n    return event.respondWith(handlePost(request))\n  }\n\n  return event.respondWith(handleGet())\n})\n\nGue tidak membuat validasi lebih lanjut karena kalau ada error yang disebabkan oleh orang iseng pun gue rasa gue tidak rugi apa-apa, jadi, yaudalaya.\nAnyways, jika melihat kode diatas, kunci dari function ini adalah event fetch yang pada dasarnya POST request dari sistem Saweria adalah fetch request, kan?\nDan jika melihat di dashboard, function diatas rata-rata berjalan selama ~4ms dengan penggunaan CPU rata-rata 72.8 MB per-detiknya.\nThe nice thing is, gue tidak perlu ribet-ribet ngatur reverse proxy dan web server untuk si webhook ini, cukup fokus menulis kodenya aja sudah mendapat endpoint (HTTPS) yang siap untuk digunakan. \nMungkin buat yang lebih serius, si Cloudflare Workers ini nawarin event cron juga misal kalau somehow si workers ini gagal mengirim POST request ke Discord, dengan bantuan KV Storage, mungkin bisa melakukan re-request per-sekian waktu untuk membuat queue system ala ala.\nJika ingin mencoba, silahkan kunjungi saweria.co/evilfactorylabs dan lihat di channel #wall-of-love di server Discord evilfactorylabs.\n...nah bikin URL shortener ala ala juga cocok sih pakai serverless function ini\nPerlu diketahui bahwa model biaya dari FaaS biasanya adalah:\nexecution/CPU time\negress bandwidth\nx req/mo\nYang gue rasa harganya relatif affordable.\nPerlu diketahui juga untuk cloud provider yang menawarkan FaaS biasanya menggunakan proprietary runtime dan juga tidak (atau belum) memiliki/memenuhi standar. Yang maksudnya, di Cloudflare Workers menggunakan semantik add.eventListener dengan properti event blablabla, sedangkan, misalnya, di AWS Lambda menggunakan exports.handler =  async function(event, context) yang secara teknis mungkin melakukan hal yang sama namun menggunakan pendekatan yang berbeda.\nPR dari migrasi ke cloud sekali lagi adalah kepercayaan, yang jika mengambil contoh FaaS disini, kita harus mempercayakan cloud provider yang kita pilih terlebih karena kita tidak berurusan dengan sistem operasi; reverse proxy, dan web server yang ingin digunakan.\nSalah satu tujuan dari ekosistem cloud menurut gue adalah untuk semaksimal mungkin menghindari pengembang (dan operator) berurusan dengan server yang menurunkan penghalang untuk siapapun yang ingin membuat sesuatu di internet.\nSebagai penutup, kelemahan dari serverless function ini adalah di maksimum CPU time. Misal, bila kamu membuat sebuah layanan untuk mentransformasi webm ke mp4 yang mungkin memakan waktu 20s untuk video berdurasi 30 menit dan sedangkan maksimum execution time nya adalah 10s, besar kemungkinan proses tersebut akan gagal.\nLalu bagaimana solusi untuk masalah diatas? Akan kita bahas di tulisan selanjutnya!","tags":"cloud,serverless","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-07-31T07:50:45","created_at":"2021-07-31T12:15:14.36128","updated_at":"2021-07-31T12:15:14.36128","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2847,"title":"Mengenal \"Cloud\" untuk Software Developer","url":"https://www.evilfactorylabs.org/faultable/mengenal-cloud-untuk-software-developer-p5d","body":"Kata \"Cloud\" mungkin sudah tidak asing lagi di telinga pembaca sekalian, dan, ya, frasa \"There is no cloud, it just someone else computer\" pun secara konsep tidak 100% salah untuk menggambarkan tentang Cloud.\nTapi tidak sedikit yang belum memahami sepenuhnya apa itu cloud (atau yang biasa disebut sebagai cloud computing/komputasi awan) termasuk saya. Dan karena cloud ini adalah konsep yang relatif baru, biasanya saya menggunakan pendekatan \"pembalikkan\" untuk mencoba memahaminya, alias, bagaimana bila kita mulai dengan pertanyaan apa itu yang bukan cloud?\nUntuk menjalankan aplikasi/layanan yang dibuat untuk pengguna internet, ada 2 komponen utama yang harus kita miliki sebagai operator:\nKomputer alias Server (tentu saja)\nJaringan internet (tentu saja juga)\nKita mulai dari komputer. Kita harus memiliki komputer yang lumayan tangguh khususnya untuk bisa menangani skala pengguna internet yang relatif acak, beda dengan membuat program yang bukan untuk pengguna internet yang mana bergantung dengan komputer yang digunakan pengguna, bukan malah si operator, alias, it's not my problem.\nUntuk merakit komputer yang tangguh tentu memakan biaya yang tidak sedikit, kita harus benar-benar peduli dengan CPU (dan jumlah core) yang ada; media storage yang digunakan, jumlah RAM, NIC, dsb dsb.\nLalu ke jaringan internet. Tentu tidak mungkin berlangganan paket internet rumahan yang menggunakan alamat IP publik dinamis, komputer kita harus memiliki alamat IP publik statis sehingga pengguna internet lain dapat mengakses komputer kita mengingat komputer hanya berkomunikasi dengan komputer lain menggunakan alamat IP.\nMungkin kita bisa menyewa alamat IP dengan prefix /24 ataupun /23 ke internet registry di wilayah kita, mendaftarkan ASN, dan lalu peering dengan ISP yang ada yang menawarkan BGP. Tapi ini lumayan ribet serta banyak memakan biaya & waktu.\nAtau kita bisa menggunakan layanan Colocation alih-alih mengatur jaringan sendiri, namun tetap, kita harus bertanggung jawab salahsatunya misal ketika salah satu SSD kita... corrupt. Membangun infrastruktur kita sendiri untuk dapat membuat aplikasi/layanan untuk pengguna internet terlihat seperti mimpi buruk, dan lebih brengseknya lagi sangat mahal dan ribet.\nMungkin kita butuh sebuah solusi untuk lebih mempermudah siapapun membuat aplikasi/layanan untuk pengguna internet, dan dengan biaya yang lebih terjangkau.\nSekarang kita sudah masuk ke topik cloud. Inti dari cloud sederhananya ada dua:\nKomputer orang lain\nDiakses melalui jaringan internet\nJika kamu sudah menggunakan komputer orang lain yang dapat diakses melalui jaringan internet (dan bukan melalui jalur backdoor), then, cool, you are on the cloud!\nPenyedia IaaS sudah lumayan banyak, termasuk di Indonesia. Dengan IaaS, kamu tidak perlu pusing lagi mempertimbangkan hal-hal terkait perangkat keras, karena itu tanggung jawabnya si penyedia layanan (dan termasuk dipemeliharaannya juga!).\nHal yang kamu lakukan hanyalah memilih, dari:\nJumlah CPU core yang digunakan\nJumlah kapasitas penyimpanan yang dibutuhkan\nJumlah RAM yang diinginkan\nDan umumnya jenis layanan yang ditawarkan ada 3:\nBare metal (pikirkan seperti colocation, namun bukan menggunakan server kamu sendiri)\nDedicated (di beberapa tempat maksudnya menggunakan CPU khusus untukmu)\nShared (menggunakan vCPU alias berbagi dengan pengguna lain)\nNah berdasarkan kebutuhan (dan ehm budget) kamu, kamu bisa mulai memesan server yang ingin kamu gunakan, tanpa biaya dan usaha banyak yang harus dikeluarkan.\nRekomendasi gue untuk infrastruktur di Indonesia adalah IDCloudHost dan untuk yang luar adalah DigitalOcean & Linode.\nSetiap penyedia layanan hampir menawarkan barang yang sama, pembedanya biasanya hanya di:\nInbound/outbound bandwidth transfer & throughput (10GbE? 40GbE?)\nJenis CPU yang digunakan (Intel? AMD?)\nJenis PCI yang digunakan (AHCI? NVMe?)\nDukungan sistem operasi (GNU/Linux? *BSD? Windows?)\nEkstensi tambahan seperti dukungan VM backup, floating IP, Layer 3/4 DDoS protection, dsb\nDi IaaS, ada 3 hal yang pada dasarnya sudah bukan menjadi urusanmu lagi, yakni:\nJaringan\nPenyimpanan\nKomputasi\nBerarti, sekali lagi, kamu tidak perlu memusingkan jenis Switch/Router, media penyimpanan, dan hal-hal terkait komputasi seperti CPU dan RAM yang akan digunakan, karena itu sudah bukan lagi urusanmu.\nPertanyaan paling inti adalah: Seberapa besar kamu mempercayai penyedia IaaS yang kamu pilih dalam memilih & memelihara 3 hal diatas?\nIni adalah lapisan diatas IaaS, dan jika berbicara realita, pada dasarnya sebuah aplikasi hanya terdiri dari komponen-komponen berikut:\nRuntime (biasanya sebuah web server)\nDatabase (MariaDB? Postgres? MongoDB?)\nStorage (di disk? di db? di S3?)\nKomponen lain seperti worker hanyalah tambahan dan bukan sebuah kewajiban. Oh, biasanya sebuah aplikasi/layanan bertindak sebagai IDP, jadi mungkin harus memikirkan hal-hal terkait IAM nya juga.\nAnyway, anggap kita menggunakan IaaS dan ada 7 layanan utama untuk dapat menjalankan aplikasi kita:\nReverse proxy 1 (SSL termination, i.e: Traefik)\nReverse proxy 2 (caching, compression, i.e: OpenResty)\nPersistent storage (i.e: Postgres)\nEphemeral storage (i.e: Redis)\nAnother proxy (i.e: imgproxy)\nMain application\nWorker application\nSetidaknya 7 layanan diatas yang harus berjalan untuk dapat menggunakan situs yang sedang kamu akses sekarang ini.\nYang berarti, ada 7 layanan yang harus gue pikirin & pelihara, dari backup; monitoring, keamanan, dsb.\nDan, hey! VM gue pakai FreeBSD, bisa gak nih jalanin Umami di VM ini?\nSalah satu benefit yang ditawarkan oleh cloud adalah tentang abstraksi, dan IaaS hanya meng-cover bagian infrastrukturnya saja.\nIngin membuat strategi failover di Postgres? Ingin membuat replika di Redis? Ingin dapat membuat aplikasi berjalan kembali setelah crash? Ingin menjalankan untrusted code dengan aman? Ingin naik gaji?\nItu urusan anda.\nNah, dengan PaaS, hal-hal tersebut bisa menjadi urusannya orang lain alias menjadi urusannya si penyedia layanan (oke kecuali bagian naik gaji, mungkin possible aja anyway).\nKunci dari cloud sebenarnya adalah satu: managed X. Jika IaaS berarti managed infrastructure, PaaS berarti managed platform.\nContohnya, kamu tidak perlu berurusan dengan instalasi Ruby untuk menjalankan aplikasi yang dibuat menggunakan Ruby On Rails ini, karena, ya, itu urusan si penyedia layanan.\nDan hey, sudahkah gue menyebutkan bahwa kita tidak perlu memusingkan konfigurasi firewall untuk memfilter paket masuk dan keluar? Anyway.\nGue personally belum tertarik menggunakan PaaS karena masalah biaya (alias duit gue masih lebih berharga daripada waktu hahaha) tapi kalau mau mencoba, pertimbangan gue adalah menggunakan fly.io, Cloud Run nya GCP, atau apapun itu yang bukan ehm Heroku.\nSatu hal yang dijual oleh PaaS adalah agar pengembang bisa fokus ke aplikasi yang dikembangkannya tanpa perlu memusingkan hal-hal terkait infrastruktur dari memilih sistem operasi; kernel, dan lain sebagainya terkait runtime.\nBukan tanpa alasan gue menempatkan bagian inti dari komputasi awan di bagian terakhir. Selain kemudahan, benefit yang didapat dari komputasi awan ini adalah elastisitas (is this a thing?) khususnya dalam menggunakan sumber daya untuk melakukan komputasi.\nMisal, kamu bisa menambah vCPU secara on-demand misal ketika traffic sedang naik-naiknya, dan kamu cukup membayar hanya selama vCPU tambahan tersebut digunakan. Sesuatu yang sulit didapat dari infrastruktur tradisional, bukan?\nSelain di elastisitas dalam sumber daya, ada juga di bagian lain yang akan kita bahas nanti per-kategori :))\nHal yang harus diperhatikan dalam memilih Cloud Provider adalah kepercayaan, karena dengan migarsi ke cloud, secara tidak resmi berarti kita mempercayakan si penyedia layanan dalam mengatur apapun yang terjadi di sistem yang kita buat dan miliki.\nUntuk skala yang lebih kecil, tentu ini bukanlah a very big deal terlebih mungkin dari hari pertama pun mereka sudah mengadopsi cloud. Namun untuk yang konteksnya migrasi ke cloud, I cannot speak for them, sayangnya.\nDitulisan ini kita hanya membahas tentang IaaS dan PaaS, diselanjutnya kita akan explore lebih jauh lagi yakni di Function as a Service (FaaS) alias Serverless computing berikut dengan benefit serta drawbacks nya khususnya untuk Software Developer.\nSee you very soon on the next cloud!","tags":"cloud","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-07-30T10:22:13","created_at":"2021-07-30T12:15:33.702359","updated_at":"2021-07-30T12:15:33.702359","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2845,"title":"Design Pattern: Proxy & Chain of Responsibility (Bahasa Indonesia) | CodingClass S1 ⦁ E7","url":"https://www.youtube.com/watch?v=HoU4MZlnYWo","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-07-30T03:14:57","created_at":"2021-07-30T06:12:03.475584","updated_at":"2021-07-30T06:12:03.475584","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2846,"title":"Tips Jadi CTO ala Rendra Toro","url":"https://anchor.fm/ceritanya-developer/episodes/Tips-Jadi-CTO-ala-Rendra-Toro-e1579bh","body":"Siapa yang punya mimpi jadi CTO? Peran ini emang sangat krusial, terutama untuk startup yang sangat bergantung di teknologi dengan tim engineer banyak (lebih dari 10 orang). Nah, Rendra Toro bagi-bagi tipsnya di episode ini. \n\n\"Kemampuan seorang CTO untuk berkomunikasi, mengerti bisnis perusahaan dan mendalami beberapa aspek diluar bidang agar ia bisa merangkai semua itu agar departemen teknologinya bisa supporting semua hal di perusahaan itu juga penting,\" ujar CTO di PT. Perintis Teknologi tersebut. \n\nDengerin tips lengkapnya dan perjalanan karir Rendra Toro di Ceritanya Developer","tags":"","media":"podcast","thumbnail":null,"owner":"Riza Fahmi","draft":false,"original_published_at":"2021-07-30T02:38:33","created_at":"2021-07-30T06:12:17.299649","updated_at":"2021-07-30T06:12:17.299649","deleted_at":null,"source_id":3,"contributor":"rizafahmi"},{"id":2836,"title":"SELinux dan Docker data-root","url":"https://www.evilfactorylabs.org/widnyana/selinux-dan-docker-data-root-35e2","body":"Kapan hari saya perlu memindahkan data-root directory docker dari kampung halamannya di /var/lib/docker ke /mnt/storage-0/docker karena persoalan ruang di partisi utama yang semakin menipis. Sebagai konteks, mesin ini menggunakan OS Centos 8 dengan SELinux: Enforcing. \nKalau melihat dokumentasi yang ada, cara mindahin data-root sebenernya ga ribet, langsung aja edit file /etc/docker/daemon.json, dan tambahin line dibawah, copy semua file dari directory lama, terus restart docker daemonnya.\n{\n...\n  \"data-root\": \"/mnt/storage-0/docker\",\n...\n}\n\nSayangnya, ternyata tidak semudah itu Fergusso. Semua emang terlihat lancar sampai ketika saya menggunakan fitur buildkit. Command docker build ... selalu gagal, dengan pesan error:\n0.479 standard_init_linux.go:228: exec user process caused: permission denied\n\n\nRefleklah ngecek audit.log, akhirnya ketahuan kalau directory /mnt/storage-0/docker belum dikasih label yang sesuai biar dikenali sama SELinux sebagai \"rumah\" nya si docker. \nIsi lognya begini:\n...\ntype=AVC msg=audit(1627476572.116:8223): avc: denied { entrypoint } for pid=277147 comm=\"runc:[2:INIT]\" path=\"/bin/busybox\" dev=\"overlay\" ino=202821668 scontext=system_u:system_r:container_t:s0:c257,c579 tcontext=system_u:object_r:unlabeled_t:s0 tclass=file permissive=0\ntype=AVC msg=audit(1627478254.522:8273): avc: denied { entrypoint } for pid=287085 comm=\"runc:[2:INIT]\" path=\"/bin/busybox\" dev=\"overlay\" ino=202821668 scontext=system_u:system_r:container_t:s0:c358,c450 tcontext=system_u:object_r:unlabeled_t:s0 tclass=file permissive=0\n...\n\nYaudah, berarti tinggal dilabelin sesuai dengan label directory lamanya, ambil contekan dulu pakai command ini:\ngrep docker /etc/selinux/targeted/contexts/files/file_contexts | grep \"/var/lib/docker\n\nCopy yang sesuai dengan kasus, terus bikin command buat ngedefinisiin context mapping directory data-root barunya si docker:\nsemanage fcontext -a -s system_u -t container_var_lib_t         \"/mnt/storage-0/docker(/.*)?\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/.*/config\\.env\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/init(/.*)?\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/overlay(/.*)?\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/overlay2(/.*)?\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/containers/.*/hosts\";\nsemanage fcontext -a -s system_u -t container_log_t             \"/mnt/storage-0/docker/containers/.*/.*\\.log\";\nsemanage fcontext -a -s system_u -t container_ro_file_t         \"/mnt/storage-0/docker/containers/.*/hostname\";\n\nAbis eksekusi command diatas, terus jalanin command dibawah buat melabeli ulang directory tersebut secara rekursif sesuai dengan context yang tadi udah diset:\nrestorecon -Rv /mnt/storage-0/docker\n\nUdah deh, \nsebelum negara api menyerang.","tags":"selinux,docker,sysadmin","media":"tulisan","thumbnail":null,"owner":"Wid","draft":false,"original_published_at":"2021-07-29T16:24:30","created_at":"2021-07-29T18:12:00.239836","updated_at":"2021-07-29T18:12:00.239836","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2824,"title":"Ngulik Desain API Identity Access Management (IAM) Google Cloud","url":"https://www.youtube.com/watch?v=o4g1pKA0yQY","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-07-28T03:31:20","created_at":"2021-07-27T00:34:00.208352","updated_at":"2021-07-27T00:34:00.208352","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2826,"title":"Hukum Asosiatif","url":"https://www.evilfactorylabs.org/ri7nz/hukum-asosiatif-39en","body":"Apa ini ? kenapa bawah2 hukum segala!\nDengan adanya hukum maka sesuatu menjadi ketat, \"teratur\" secara paksa, dan tunduk sebagaimana seorang warga negara yang berada pada sebuah sistem. Meskipun, pada dasarnya manusia adalah makhluk yang \"bebas\" dan dikarunia \"kebebasan\" untuk menjadi apa dan untuk apa.\nKembali ke Topik utama, yakni tentang \"Functional Programming\" atau pemrograman fungsional. Membahas topik ini, menurut penulis begitu banyak hal yang bisa dibahas, sehingga sulit untuk berhenti untuk membahasnya (seperti prinsip Evilfactorylabs, belajar itu bukan destinasi atau tujuan tetapi sebuah perjalanan mulia yang tak pernah berhenti). Pada tulisan ini, membahas salah satu dan bagian kecil dari konsep, teori, dan hukum yang ada pada pemrograman fungsional. Yakni, Hukum Asosiatif atau the law of associativity. \nSebelum membahas soal Asosiatif, kita harus mempelajari dulu tentang \"compose\", dalam\nDalam matematika, sifat asosiatif[1] adalah sifat dari beberapa operasi biner, yang berarti bahwa mengatur ulang tanda kurung dalam ekspresi yang tidak mengubah hasilnya. Dalam logika proposisional, asosiativitas adalah valid kaidah penggantian untuk ekspresi dalam bukti logika.\n\nContohnya,\n(2 + 3) + 4 = 2 + (3 + 4) = 9\n\nDari contoh diatas, ada 2 hal yang berbeda tetapi sama, yang berbeda adalah urutan operasi (lihat buka dan tutup kurungnya), yang sama adalah hasilnya meskipun urutan (buka dan tutup kurungnya) berbeda. \nNamun, contoh diatas dibuat dalam bentuk operasi Matematika, bagaimana jika kita membuatnya menjadi fungsi dalam pemrograman, berikut contohnya (yah, ditulis pakai JavaScript biar terlihat trendi dan menaikkan strata sosial).\nlet compose = (f, g) => x => f(g(x))\nlet add = (a, b) => a + b\n\nlet addTwo = b => add(2, b)\nlet addFour = b => add(4, b)\n\nlet assocX = compose(addTwo, addFour)\nlet assocY = compose(addFour, addTwo)\n\n// identifikasi bahwa {assocX} dan {assocY} \n// ketika diberi nilai {3} \n// maka menghasilkan hal yang sama atau {true}\nassocX(3) === assocY(3)\n// 9 === 9\n// contoh lain \n\nlet exclaim = str => `${str} !`\nlet toLowerCase = str => str.toLowerCase()\n\nlet assocA = compose(toLowerCase, exclaim)\nlet assocB = compose(exclaim, toLowerCase)\n\nassocA(\"HEY\") === assocB(\"HEY\")\n// \"hey !\" === \"hey !\"\n\nContoh diatas, terdapat sebuah fungsi yang bernama {compose}, fungsi tersebut untuk menyusun operasi atau peng-aplikasi-an dari beberapa fungsi yang dimana memiliki parameter yang sama (Nanti, kita bahas lebih detail untuk Compose).\nTidak susah sebenarnya, untuk memahami apa itu Asosiatif, intinya Asosiatif digunakan untuk mengetahui hasil akhir dari beberapa fungsi yang dioperasikan selalu sama, Meskipun urutan dari fungsinya berbeda. Namun, ada beberapa hal yang sangat penting tetapi tidak dimuat dalam tulisan kali ini, Hal tersebut yakni Pure-Function (fungsi tanpa efek samping, atau selalu menghasilkan hal yang sama), Hal tersebut sangat penting sebelum kamu membaca tulisan ini atau sedang mempelajari lebih lanjut paradigma pemrograman fungsional. Jika kamu sangat tertarik, kamu bisa Kesini...","tags":"fp,functional,programming,sd","media":"tulisan","thumbnail":null,"owner":"RiN","draft":false,"original_published_at":"2021-07-27T13:47:06","created_at":"2021-07-28T06:13:01.584549","updated_at":"2021-07-28T06:13:01.584549","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2827,"title":"Membuat Discord Webhooks Untuk Menangkap Notifikasi Github Repository ","url":"https://www.evilfactorylabs.org/fncolon/membuat-discord-webhooks-untuk-notifikasi-github-repository-42a4","body":"Kadang untuk mencari tahu update di github repository dari issue, pull request, dan push ataupun security, kita harus bulak balik buka github repositorynya di website, dan menurut gw itu akan menjadi sangat tidak efisien kalau sudah jadi habit.\nUntuk memecahkan masalah itu, gw coba explore dan ketemu yang namanya webhooks, kebetulan discord memberi support untuk webhooks pada server-server discord, tentu saja kamu harus punya privilege administrator atau founder untuk menggunakan webhooks pada server tersebut.\nDi artikel ini, gw pengen panduin kalian untuk bagaimana sih memasang webhooks ini dari discord ke github repository? tentu saja tanpa terlalu banyak basa-basi seperti pada hal-nya artikel yang sebelumnya gw buat dan langsung penjelasan ke-inti-nya.\nLangsung saja #markicob!\nPertama, kalian harus mempersiapkan discord dan belajar bagaimana menggunakan discord terlebih dahulu.\nsedikit joke\nWebhook adalah sebuah konsep API, dimana dia menyediakan informasi untuk aplikasi lain secara realtime, webhook sering disebut juga sebagai Reverse API karena harus dirancang supaya bisa digunakan oleh provider webhook, webhook memiliki dua bentuk response yaitu JSON dan XML atau sebagai data form yaitu x-www-form-urlencoded atau multipart/form-data.\nBerikut langkah-langkah mempersiapkan discord webhooks pada github repository kamu!\nBuka Discord dan persiapkan server dengan membuat server atau gunakan server yang sudah ada untuk membuat webhooks (pastikan disini kamu memiliki role Administrator ataupun Server Founder yang ditandai dengan mahkota).\n\n\nBuka server tersebut lalu tekan bagian pada bagian yang ditunjuk pada gambar dibawah ini, lalu klik pilihan Server Settings.\n\n\n\n\nSetelah membuka Server Settings kemudian klik pada bagian Integrations.\n\nSetelah membuka Integrations kemudian klik pada bagian Create Webhooks (jika kamu/bot (secara otomatis) sudah membuat webhooks sebelumnya untuk keperluan lain maka tulisannya menjadi View Webhooks).\n\nSetelah itu, klik tombol Create Webhook (jika kamu/bot (secara otomatis) sudah membuat webhooks sebelumnya untuk keperluan lain maka klik pada tombol New Webhook).\n\nSetelah klik tombol tersebut kamu akan mengisi informasi terkait Webhook tersebut, lalu klik pada tombol Copy Webhook URL, disini saya merekomendasikan untuk membuat text channel masing-masing untuk setiap repository, supaya lebih rapih dan ter-manage dengan mudah. \n\nJika kamu mengalami kesulitan dalam membuat text channel, ikuti langkah dibawah ini\nKembali ke halaman server kalian, lalu klik tombol + seperti yang ditunjukkan oleh gambar dibawah ini.\n\nSetelah muncul modal popup Create Text Channel, silahkan isi nama channel, lalu klik Create Channel\n\n\n\n\nSetelah membuat webhook kita akan lanjut ke langkah berikutnya yaitu mempersiapkan github repository untuk menggunakan webhook dari Discord yang sebelumnya sudah kita buat dan copy URLnya.\nBerikut langkah-langkah mempersiapkan github repository untuk menggunakan discord webhooks yang sudah kamu buat!\nBuka github repository yang sudah kamu persiapkan lalu klik pada bagian Settings\n\n\n\n\nSetelah membuka Settings lalu klik pada bagian Webhooks\n\n\n\n\nSetelah itu, klik pada tombol Add webhook.\n\nSetelah itu kamu akan mendapatkan tampilan seperti dibawah lalu isi dengan contoh input yang diperlukan seperti dibawah ini.\n\n1). Isi Payload URL dengan URL yang sudah kamu copy melalui tombol Copy Webhook URL pada Discord sebelumnya lalu tambahkan prefix /github di URL tersebut. (contoh https://discord.com/api/webhooks/{RANDOM_CHARACTER}/github\napplication/json pada pilihan Content type\nJust the push event. jika kamu hanya ingin menerima notifikasi push dari aktifitas branch, pilih Send me everything. untuk menerima segala notifikasi dari aktifitas pada github repository tersebut, dan pilih Let me select individual events. untuk menerima notifikasi dari beberapa aktifitas saja. Aktifitas di github repository ini disebut sebagai event pada Github.\nSetelah mengisi input yang diperlukan lalu klik pada tombol Add webhook\n\n\n\n\nSetelah menambah webhook, kamu akan dialihkan ke halaman sebelumnya dan pastikan webhook sudah ceklis untuk memastikan bahwa konfigurasi kamu benar.\n\nDan selesai sudah perjalanan kita untuk menambahkan Discord webhook di github 😄, selanjutnya kita harus memastikan bahwa setiap event pada github repository sudah ditangkap oleh webhook dari Discord tersebut.\nMari kita coba push sesuatu pada github repository tersebut! \nDisini saya menambahkan file README di branch bernama main.\n\nMari kita cek dan lihat ada keajaiban apa yang terjadi, dan voila! event push pada github repository tersebut sudah masuk ke text channel dari Discord webhook yang dibuat sebelumnya! 🎉\n\nSekian artikel yang bisa saya bagikan, semoga bermanfaat 😃","tags":"discord,webhooks,github,serverless","media":"tulisan","thumbnail":null,"owner":"fnc","draft":false,"original_published_at":"2021-07-27T05:54:02","created_at":"2021-07-28T06:13:01.584549","updated_at":"2021-07-28T06:13:01.584549","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2828,"title":"Gue Bosen Sama VS Code, dan Ini yang Gue Lakuin! 😤","url":"https://www.evilfactorylabs.org/nyancodeid/gue-bosen-sama-vs-code-dan-ini-yang-gue-lakuin-en","body":"Pernah nggak sih kalian bosen sama Visual Studio Code atau VS Code? atau editor lain kesayangan kalian deh. Mau Sublime Text, Atom, Jetbrain Product, MS. Word 🙄 atau yang lain. Gue? iya gue udah bosen. Kenapa? ya karena cuma benda itu yang gue lihat dan pakai tiap kali ngoding. Ngoding bertahun-tahun dan cuma benda itu aja yang gue liat, come on? masak kalian nggak bosen sih. \n\nUdah ngelakuin beberapa hal buat menyingkirkan kebosenan yang selalu muncul tiap harinya. Sampai pada suatu titik gue install VS Code, Sublime Text, Webstorm, PHPStorm, dan IntelliJ IDEA buat dipakai gantian buat nyari suasana baru tiap kali rasa bosen itu balik lagi. Berhasil? ya, tapi setiap editor pasti punya pros dan cons (Pro dan Kontra). Nah buat gue yang menyebut dirinya sendiri sebagai Javascript Developer, VS Code emang yang paling canggih sih. Extensions yang beragam, Autocomplete yang ajib, Intellisense yang behhh. Dan yang baru baru ini nih, Github Copilot udah jangan ditanya gimana rasanya, mending lu coba sendiri aja sana.\nOke, kita fokusin masalah ini ke si VS Code. Buat ngatasin rasa bosen gue sama tampilan VS Code yang gitu gitu aja, gue coba gonta-ganti dan cari kombinasi yang pas antara Font, Color Theme, dan Theme. Cara ini terbukti efektif sih karena udah setahunan gue nerapin hal ini dan works. But, gue selalu merasa bahwa VS Code ini kayaknya kurang lega tampilannya. Berasa sempit gitu. Nah saat gue lagi browsing di Facebook, nemu postingan show off tampilan Code Editor. Gue kaget dong, kok familar gitu tampilannya. Dan ternyata VS Code anjir. Tapi keren banget, berubah 180 derajat. Gue cari-cari gimana cara bikin tampilan kayak gitu dan akhirnya gue nemu artikel ini. Dan penulisnya siapa? gue sendiri. Lah plot twist 😵.\nAnyway, sekarang kalian paham kan kenapa gue bikin tulisan ini, gue mau berbagi gimana caranya biar VS Code kalian tidak terlihat gitu gitu aja. Bukan cuma ganti Font, Color Theme, dan Theme doang. Markicobbb!!\nSebelum kalian ngikutin step-by-step selanjutnya, kalian harus punya hal-hal yang dibutuhkan berikut:\nVisual Studio Code\nFont Hasklig - Download Disini https://github.com/i-tu/Hasklig/releases\n\nFont Fira Code - Download Disini https://github.com/tonsky/FiraCode/releases\n\nKoneksi Internet (Buat Download Extension dan Theme)\nSetelah semua sudah siap, kalian bisa lanjut step selanjutnya.\nPertama, kita install Theme yang mendukung buat design ini, disini gue pakai Github Theme. Buat install theme nya pilih menu View > Extensions atau pakai shortcut Ctrl+Shift+X. Kita cari Github Theme, pilih yang atas sendiri lalu install. \n\nSetelah instalasinya selesai, kita bisa langsung pilih Color Theme. Kita pilih yang Github Dark Default karena backgroundnya hitam pekat, gila feel dark nya dapet banget.\n\nGue udah coba pakai color theme atau theme yang Dracula tapi hitamnya kurang nendang. Masih abu abu tua gitu. Tapi bisa kalian coba sendiri kombinasikan theme apa yang cocok menurut kalian pribadi. Buat yang pakai Light Mode semoga kalian mendapat pencerahan dari light theme kalian bahwa kodrat programmer itu pakai Dark Mode 😳✌️.\nKedua, setelah theme kita lanjut setting fontnya. Buka halaman settings di menu File > Prefereces > Settings atau pakai shortcut Ctrl+Comma. Cari Editor: Font Family, disini kita setting font family buat Editor Area-nya ya, karena kita nanti juga bakalan setting buat font yang lain. Disini gue pakai Hasklig Mono kalau kalian pengen yang lain, rekomendasi gue sih Dank Mono tapi berbayar ya guys. Kalau Hasklig mah gratis dan bentuk fontnya hampir sama kayak Fira Code, tapi menurut gue masih lebih bagus Hasklig sih. \n\nOptional aja sih ini, tergantung selara kalian. Disini gue set nilai Editor: Line Height-nya jadi 1.5 biar space antar line jadi lebih lega dan nggak begitu mempet kayak dia sama temenmu. Lanjut.\nKetiga, nah ini nih pemeran utamanya. Yang bikin VS Code jadi beda dan makin keren. Nama Extensionya Customize UI. Kalian bisa search di menu View > Extensions atau pakai shortcut Ctrl+Shift+X lalu cari Customize UI. Lalu install extension-nya. \n\nSetelah berhasil terinstall kita bakalan lihat alert disuruh buat enable Monkey Patch, agar extension bisa bekerja sesuai harapan. Tapi kalau kalian nggak sengaja nutup alertnya kalian masih bisa enable via Command Palette Ctrl+Shift+P lalu cari Enable Monkey Patch dan enter, nanti bakalan disuruh restart VS Code tinggal klik restart aja. \n\nNah belum selesai sampai situ, baru kita lanjut konfigurasi extensionnya. Eits, perlu kalian ketahui nih jadi tiap perubahan pengaturan di extension ini butuh restart VS Code, gue rekomendasiin kalian selesaiin dulu settingnya sampai selesai, baru restart diakhir. Nanti bakalan ada popup buat restart VS Codenya dipojok kanan bawah.\nUntuk buka pengaturan extension Customize UI, kita klik gambar gear/pengaturan lalu pilih Extension Settings. Baru deh kita bisa custom lebih lanjut. \n\nSetalah itu bakalan kebuka halaman buat setting extensionnya seperti dibawah ini.\n\nNah untuk pengaturan Customize UI: Activity Bar ini buat milih posisi activity bar nya mau diletakkan disebalah mana, kalau gue sih pilih bottom. Biar dia kebawah biar space disamping jadi lebih lebar. Oh iya perlu kalian tau kalau kalian mindah activity bar nya kebawah kalian nggak bisa buka/tutup sidebarnya pakai icon itu lagi. Misalnya kita buka file Explorer, untuk buka/tutup Explorer biasanya kalian kan bisa klik iconnya lagi (toggle). Nah kalau ditaruh bawah kita nggak bisa pakai cara itu. Kita harus pakai shortcut Ctrl+B buat buka/tutup (toggle) sidebarnya.\n\nAda 2 pengaturan untuk font disini, yaitu Monospace dan Regular. Ini untuk memilih font family yang nantinya dijadikan font utama di VS Code nya, eits bukan untuk Editor Area ya, tapi buat aplikasi VS Codenya. Disini gue milih font Hasklig Mono (lagi) untuk Customize UI > Font: Monospace dan Fira Code untuk yang Customize UI > Font: Regular.\n\nUntuk Statusbar nya kita pindah dibawah panel. Jadi pengaturan Customize UI > Move Statusbar ini dicentang aja. Biar statusbar nggak banyak makan tempat. Karena kita mao semuanya minimalis dan berbeda.\n\nNah sampai tahap ini kalian bisa klik Restart VS Code nya biar konfigurasinya ke-reload. \n\nAnd voila seharusnya kamu sudah bisa lihat perubahan dari VS Code kamu. 😍\n\nTapi ada satu lagi konfigurasi yg bikin makin kece lagi. \n\nKita buka lagi halaman Settings lewat menu  File > Prefereces > Settings atau pakai shortcut Ctrl+Comma, lalu cari Window: Title Bar. Nah biar tampilan judul VS Code gabung jadi satu sama Menu atau Toolbar maka kita ubah yang awalnya Native jadi Custom. Setelah itu bakalan ada popup buat restart VS Code-nya. Kita restart langsung. Boom!!! 🤯\n\nHasil akhirnya bakalan seperti ini, mirip nggak sama tampilan kalian? kalau nggak mirip atau bahkan jauh lebih bagus bisa dong tulis di kolom komentar dibawah ya.\n\nSekian. Semoga bermanfaat dan bikin makin produktif. Tetap jaga kesehatan, and see you leter. 🥳","tags":"vscode,texteditor,productivity","media":"tulisan","thumbnail":null,"owner":"Ryan Aunur Rassyid","draft":false,"original_published_at":"2021-07-26T17:09:31","created_at":"2021-07-28T06:13:01.584549","updated_at":"2021-07-28T06:13:01.584549","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2829,"title":"Membuat VSCode ala ala wibu untuk meningkatkan produktifitas","url":"https://www.evilfactorylabs.org/fncolon/membuat-vscode-ala-ala-wibu-untuk-meningkatkan-produktifitas-1433","body":"I would rather die of passion than of boredom.\nPemrograman seringkali menjadi aktifitas yang membosankan jika tidak ada hal menarik yang mengelilingi aktifitas pemrograman anda, diantaranya itu ilmu yang menarik, setup yang memadahi, dan tools yang menambah dopamin pemrograman.\nSebelum memulai tutorial ini pastikan untuk menginstall VSCode terlebih dahulu.\nLangsung Saja Kita Mulai!!\nBerikut adalah hal-hal yang akan anda tambahkan ke VSCode anda.\n\nCode with your waifu! adalah tagline yang digunakan oleh The Doki Theme, dimana ini adalah sebuah tema vscode yang menampilkan tema dengan waifu-waifu yang mungkin anda suka sebagai wallpaper di VSCode, selain itu juga tema ini memiliki fitur glass pane dimana VSCode anda akan terlihat transparan dengan wallpaper tersebut.\nInstalasinya cukup mudah.\nBuka VSCode anda.\nCTRL + Shift + X\nKetik The Doki Theme\n\nKlik The Doki Theme\n\nInstall The Doki Theme\n\nSelesai!!\nAnda bisa mengganti tema melalui View > Command Palette > Doki-Theme. \nSaya merekomendasikan color theme Steins-Gate Kurisu saja dari The Doki Theme, karena warna font tidak terlalu menyatu dengan warna tema, atau jika anda hanya tertarik dengan background waifu dan fitur glass panenya dan ingin menggunakan color theme bawaan vscode/tema lain, cukup disable ekstensinya.\nBerikut contoh tampilan VSCode saya ketika menggunakan tema ini :\n\n#LohKokWhiteTheme\nhanya contoh! tapi jangan dicontoh ya!\nDaftar Wallpaper : https://marketplace.visualstudio.com/items?itemName=unthrottled.doki-theme#about\nhttps://github.com/doki-theme/doki-theme-vscode\n\nNgoding adalah jalan ninjaku\nInstalasinya cukup mudah.\nDownload ninja_naruto dan konfigurasi fontnya.\n\n\nTambahkan line dibawah ini didalam object pada settings.json:\n\n\n\n  \"editor.fontFamily\": \"'Ninja Naruto'\"\n\nlokasi untuk Windows %APPDATA%\\Code\\User\\settings.json\n\nlokasi untuk Mac $HOME/Library/Application Support/Code/User/settings.json\n\nlokasi untuk Linux $HOME/.config/Code/User/settings.json\n\n\n\n\n3. Reload VSCode dan Selesai! (maaf di quote karena ke reset jadi satu lmao)\nSelain Ninja Naruto Font, anda juga bisa menggunakan Death Note \n dengan step instalasi yang tidak jauh berbeda.\n\"editor.fontFamily\": \"'Death Note Font'\"\n\n\nSekian, terima kasih.\nNB: Artikel ini hanya untuk referensi yang menghibur saja, tidak harus juga jika anda wibu menggunakan hal-hal seperti ini, cukup menonton anime yang ada isi waifu anda.","tags":"meme,vscode,productivity,anime","media":"tulisan","thumbnail":null,"owner":"fnc","draft":false,"original_published_at":"2021-07-26T01:06:54","created_at":"2021-07-28T06:13:01.584549","updated_at":"2021-07-28T06:13:01.584549","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2830,"title":"Tehnik subnetting untuk mencari range ip pada sebuah network","url":"https://www.evilfactorylabs.org/adiatma/tehnik-subnetting-untuk-mencari-range-ip-pada-sebuah-network-14e3","body":"Tulisan tentang networking kedua ini adalah dasar atau fundamental di dunia networing.\nArtikel ini adalah lanjutan dari artikel sebelumnya yaitu tentang dasar network dan ip address.\nOh iya subnetting adalah cara efektif untuk menentukan total ip di dalam sebuah network. di artikel ini kita akan belajar berdasarkan contoh kasus nyata.\nMisalnya di sebuah kantor ada sekitar 50 devices yang akan di hubungkan dalam sebuah koneksi yang bernama LAN (Local Area Network).\nUntuk itu perlu untuk menentukan IPv4 private yang akan digunakan. di kasus ini saya akan pakai 172.16.10.0 selanjutnya, perlu untuk mencari berdasarkan rumus yang ada gambar bawah ini.\n\nJadinya prefix yang kita bisa pakai berdasarkan hasil hitungan diatas adalah 26, yang memiliki kapasitas sekitar 64 ip address.\nSelanjutnya adalah menentukan subnetmask, rumus untuk mencari subnetmask adalah 256 - total ip = <subnetmask> jadinya 256 - 64 = 192, nah jika di implementasikan dalam sebuah subnetmask jadinya 255.255.255.192, angka hasilnya dimasukan di akhir byte, karena default angka subnetmask adalah 255.255.255.x x nya adalah angka yang kita dapat dari penjumlahan sebelumnya.\nSetelah menemukan angkanya hal selanjutnya adalah mencari ip network dan ip broadcast, ip network akan selalu di awali dengan angka 0, dan ip broadcast adalah angka ip terakhir, kemudian menentukan block subnet seperti contoh pada gambar di bawah ini.\n\nBerdasarkan perhitungan diatas, jadinya ip network = 0 dan ip broadcast = 63, pada block subnet 1, pada block subnet ke 2, akan di awali dengan ip network = 64 dan ip broadcast = 127 hasil pengurangan dari ip network di block ke 3, yaitu 128.\nip network | 0 | 64 | 128 \nip broadcast | 63 | 127 | .. (sampai batas 256)\n\nKemudian setelah itu kita putuskan ingin pakai block yang mana misalnya kalau pakai block ke 2, jadinya ip network akan diawali dengan 64, dan ip broadcast adalah 127, kemudian mencari ip range, rumusnya adalah ip network di tambah 1, dan ip broadcast di kurang 1, jadinya ip range nya adalah 127.16.10.65 - 127.16.10.126.\nDetailnya seperti ini.\ntotal ip = 64\nsubnetmask = 255.255.255.192\nip network = 172.16.10.64\nip broadcast = 172.16.10.127\nip range = 172.16.10.65 - 172.16.10.126\n\nOke, demikian cara sederhana untuk menentukan total ip address dengan efektif, atau biasa disingkat dengan istilah subnetting.\nSalam olahraga! dan juga lpg!","tags":"jaringan","media":"tulisan","thumbnail":null,"owner":"Adiatma Kamarudin","draft":false,"original_published_at":"2021-07-25T14:46:38","created_at":"2021-07-28T06:13:01.584549","updated_at":"2021-07-28T06:13:01.584549","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2831,"title":"Sedikit tentang network dan ip address ","url":"https://www.evilfactorylabs.org/adiatma/sedikit-tentang-network-dan-ip-address-1lo4","body":"Oh iya tulisan ini akan membahas hal yang fundamental, atau basic di dunia network\nNetwork dalam bahasa Indonesia adalah jaringan, network di dalam dunia komputer bisa diartikan sebagai komputer - komputer yang saling terhubung dan berkomunikasi, berkirim data dari komputer satu ke komputer yang lainnya.\nDi dunia nyata manusia berkomunikasi, tentunya untuk bisa berkomunikasi butuh untuk tau dulu siapa lawan komunikasinya, biar komunikasinya tersambung, kalau gak tau lawan komunikasinya siapa, maka gak akan bisa komunikasi.\nSama seperti komputer yang butuh tanda pengenal untuk bisa berkomunikasi, nah tanda pengenal komputer di dunia network adalah ip address, nah ip address itu terdiri dari 32 bit angka biner yang dibagi dalam 4 byte, dan setiap byte terdiri dari 8 bit, dan setiap bitnya merepresentasikan bilangan desimal mulai dari 0 sampai 255.\nUmumnya kelompok ip address dibagi menjadi 2 bagian, ip private dan public. private biasanya terdapat di dalam sebuah kelompok kecil yang di sebut LAN (Local Area Network), dan ip public biasanya terdapat di dalam kelompok yang lebih besar atau global yang kita kenal sebagai internet.\nDi bahasan kali ini, kita hanya akan membahas lingkup LAN, yaitu sebuah kelompok local dalam area network, LAN adalah kelompok komputer yang berkomunikasi terbatas hanya diruang lingkupnya saja, dengan menggunakan ip private.\nNah ip private pada penggunaannya diatur oleh IANA (Internet Assigned Numbers Authority) sebuah organisasi yang mengatur penggunaan dan pengalokasian ip address di seluruh dunia, dalam sebuah dokumen RFC 1918, alokasi IPv4 (ip address versi 4) private diatur dengan angka desimal yang ada di bawah ini.\n# ip private\n10.0.0.0 - 10.255.255.255\n172.16.0.0 - 172.16.255.255\n192.168.0.0 - 192.168.255.255\n\nDiluar dari range angka diatas, bisa dikatakan sebagai ip public. aturan angka ip private diatas adalah absolute atau pasti dan perlu untuk di ingat biar mudah buat bedain dengan ip public.\nOk, selanjutnya kita akan bahas tentang prefix, pada bahasan sebelumnya harusnya kita sudah paham perbedaan IPv4 public dan private, sekarang kita akan bahas tentang prefix di dalam IPv4.\nPrefix adalah angka yang terdapat di depan alamat ip contohnya seperti ini, 192.168.1.1/24, nah yang ini /24 disebut sebagai prefix, prefix menjelaskan berapa banyak sebuah ip dalam sebuah network, jika bentuknya seperti ini 192.168.1.0/24 artinya ada sekitar 256 total ip, di dalam sebuah network tersebut. \n\nLoh angkanya darimana? kok bisa tau ada 256 ip, oke jadi ada hitungan dan rumusnya, rumusanya adalah 2 pangkat 32 - 24, hasilnya adalah 2 pangkat 8, yang jika dikalkulasikan akan menghasilkan angka 256. Oh iya angka 32 itu menggambarkan bit dari IPv4, dan 24 adalah prefixnya. \nPada penggunaannya sebenarnya hanya ada 254 komputer yang dapat menggunakan alamat ip tersebut, karena angka 256 akan dikurangi 2, yaitu ip network dan ip broadcast, sehingga menjadi 254, ip network adalah first ip, atau angka awal, dan ip broadcast adalah last ip atau angka akhir, dan keduanya tidak bisa digunakan oleh komputer yang terhubung dalam sebuah LAN (Local Area Network).\nSelanjutnya ip yang bisa digunakan disebut sebagai ip range, untuk menentukan ip range cukup ambil angka setelah ip network, dan sebelum ip broadcast, ditengah - tengah keduanya, contohnya 192.168.1.0/24 ip networknya adalah 192.168.1.0/24 dan ip broadcastnya adalah 192.168.1.255/24 dan ip range nya adalah 192.168.1.1/24 - 192.168.1.254/24.\nOke sampai disini kita sudah sedikit mengenal tentang ip address dan kawan - kawannya, untuk selanjutnya silahkan belajar lebih lanjut tentang subnetmask, block subnet, subnetting, switch dan router.\nTerimakasih semoga bermanfaat buat teman - teman yang lagi belajar tentang network.\nSalam olahraga!","tags":"ip,lan,jaringan","media":"tulisan","thumbnail":null,"owner":"Adiatma Kamarudin","draft":false,"original_published_at":"2021-07-25T10:48:21","created_at":"2021-07-28T06:13:01.584549","updated_at":"2021-07-28T06:13:01.584549","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2832,"title":"Menjadikan Raspberry Pi sebagai router","url":"https://www.evilfactorylabs.org/faultable/menjadikan-raspberry-pi-sebagai-router-1j7c","body":"Tulisan ini aslinya diterbitkan di blog pribadi gue dengan judul yang sama yang bisa diakses disini.\nDan disini gue cuma ingin menguji pengalaman ketika melakukan cross-posting dari sumber luar ke situs ini.\nPada 15 Juni 2021 kemarin gue membeli router yang oke banget, doi menggunakan sistem operasi OpenWRT dan juga \"menjadikan\" privasi dan keamanan sebagai fitur utama (built-in support VPN & DNS encryption).\nPada dasarnya router hanyalah sesuatu yang bertugas untuk meneruskan & merutekan paket, dan sudah gue bahas sedikit di edgy's frontline newsletter yang di isu paling pertama. Lalu gue kepikiran gimana kalau Raspberry Pi gue dijadiin router? Spesifikasi Raspberry Pi gue gak terlalu sampah banget: armv7, 4 core CPU dan RAM 4G, dan gue ingin ber-eksplorasi lebih dalam ke network engineering.\nPercobaan pertama adalah dengan menjadikan Raspberry Pi (yang akan gue singkat menjadi raspi) bekerja sebagaimana router pada umumnya, yang berarti menjadi:\nDHCP server untuk memberikan alamat IP secara dinamis ke klien\nDNS (stub) resolver untuk menjawab DNS query oleh klien\nPenerus paket ke gateway (raspi gue terhubung ke WAN dan ada 2 router dibelakangnya)\nBerdasarkan 3 poin diatas, minimalnya ada 3 program yang harus berjalan di raspi gue:\nhostapd(8) untuk membuat Access Point (AP) biar devices gue bisa terhubung secara wireless\n\n\ndnsmasq(8) untuk memberikan alamat IP ke klien sekaligus untuk menjawab DNS queries juga\niptables(8) untuk mengatur paket yang masuk dan keluar. Biasanya ini sudah terpasang di sistem operasi\nDan seperti biasa, berikut ilustrasinya:\n Dibelakang 192.168.88.0/24 masih ada 1 router lagi sebelum nyambung langsung ke ISP, cuman yaudalaya\nSubnet yang gue pilih adalah 10.3.141.0/24 karena kenapa tidak dan gue tidak menggunakan dnsmasq(8) melainkan AdGuardHome karena dia juga bisa bertindak sebagai DHCP server. Serta, kalau gue pakai dnsmasq, dns queries diforward dari router ke... router. Jadi, kalau si 10.3.141.6 pakai nameserver router, si AdGuardHome taunya kalau yang melakukan query itu adalah si router itu sendiri bukan dari klien.\nNah, karena gue ingin tau juga siapa melakukan query kemana, jadi gue jadikan AdGuardHome sebagai DHCP server.\n Setting DHCP server gue\nOh iya, si raspi gue untuk yang ini menggunakan sistem operasi Raspian karena FreeBSD 13.0 untuk di armv7 tidak mendukung driver Wi-Fi yang digunakan di raspi gue.\nDriver untuk Wi-Fi gue adalah wlan0 dan punya static ip 10.3.141.1.\nGue kurang yakin apakah set gateway IP diatas menjadi 10.3.141.1 adalah hal yang benar atau salah, tapi bagaimanapun gue pakai iptables(8) juga untuk meneruskan paket dari wlan0 ke eth0.\nUntuk memulai, silahkan pasang AdGuardHome di raspi anda, kalau cara gue biasanya gini:\ncurl -JOL <link>\ntar -xzvf <nama>\nsudo mv AdGuardHome/AdGuardHome /usr/local/bin\nsudo /usr/local/bin/AdGuardHome -s install\nLalu akses port 3000, dan jalankan setup seperti biasa(next next next next).\nSekarang kita ke bagian setting AP menggunakan hostapd(8). Berkas konfigurasinya berada di /etc/hostapd/hostapd.conf dan konfigurasi minimalnya seperti ini:\nauth_algs=1\nwpa_key_mgmt=WPA-PSK\nbeacon_int=100\nssid=<nama_wifi>\nchannel=1\nhw_mode=g\nieee80211n=0\nwpa_passphrase=<password_wifi>\ninterface=wlan0\nwpa=2\nwpa_pairwise=CCMP\ncountry_code=ID\nignore_broadcast_ssid=0\n\nApakah gue tau semua maksud dari konfigurasi diatas? Tentu tidak, tapi bukankah kita memiliki mesin pencari? Anyway, intinya konfigurasi diatas untuk setting biar si raspi kita brodcast sinyal Wi-Fi yang menggunakan autentikasi via WPA-PSK.\nDan berikut tampilannya ketika sudah tersambung:\n Tentu saja signal stength excellent karena router gue disamping pisan\nKarena gue pakai AdGuardHome sebagai DHCP server, kita bisa tau perangkat apa aja yang tersambung berikut dengan MAC Address dan alamat IP nya:\n Daftar klien yang tersambung ke raspi gue\nGue pakai DHCP static lease karena 2 alasan:\nPengguna router ini umumnya cuma gue\nFitur \"Private Address\" nya iOS/iPadOS somehow ngeganggu, yang mana enggak expose hostname dan MAC Address asli perangkat gue (which is good) sedangkan gue butuh itu for the sake of a e s t h e t i c ✨ di dasbor AdGuardHome gue\nSetelah si raspi sudah bisa ngasih alamat IP & melakukan DNS query, sekarang waktunya membuatnya bisa meneruskan paket. Seharusnya ini udah berjalan out of the box but just in case enggak berjalan, bisa cek peraturan di Firewall ataupun memastikan bahwa nilai net.ipv4.ip_forward adalah 1 di /etc/sysctl.conf.\nMeskipun untuk mengetahui \"siapa mengontak siapa\" secara teknis sudah bisa dilakukan di level DNS, tapi gue butuh informasi \"siapa mengontak apa\".\nDan untuk mengetahui itu gue butuh bantuan ntopng(8) yang exactly bekerja sebagai \"traffic analyzer\". Pikirkan seperti top(1) tapi untuk jaringan.\nUntuk pemasangan ntopng(8) bisa diunduh melalui situsnya disini. Dan berikut salah satu tampilannya:\n Analisa trafik per aplikasi\nDisitu gue bisa mengetahui perangkat-perangkat gue ini menghubungi siapa aja (Amazon, Twitter, Spotify, dkk) dan apa aja (SSH, mDNS, DNS, dkk) plus dengan kategorinya (Tracker/Ads, Fun, Acceptable, dkk).\nKarena ntop adalah Traffic Analyzer, jadi dia pun menganalisa paket apa yang sekiranya dianggap berbahaya ataupun butuh perhatian. Misal ini, gue dapet alert kalau ada paket yang diduga \"malicious\" dengan kategori Suspicious DGA:\n gue rasa karena TLD nya .xyz\nKita bisa setting \"score anomaly\" sesuai dengan selera kita sendiri.\nProses instalasi ntopng(8) relatif sederhana, dan satu-satunya konfigurasi yang gue setting sendiri hanyalah agar listen port ke 3003.\nTentu saja tunnel!\nDNS queries yang ada di perangkat-perangkat gue dikirimkan melalui encrypted protocol yakni HTTPS, TLS, dan QUIC (yang dipilih randomly pakai RR) di AdGuardHome dengan edgyDNS sebagai upstream DNS.\nSetelah itu gue akan membuat IPv6 tunnel via TunnelBroker nya HE biar router gue mendukung IPv6.\nLalu gue buat traffic internet gue di proxy ke edgyPROXY dan menggunakan QUIC sebagai transport protocol.\nBerdasarkan keterbatasan kepengetahuan gue, jika melihat kebutuhan gue diatas, paket yang di-expose ke router dibelakang gue (dan router ISP tentunya) gue rasa bakal encrypted semua:\nDoH, DoT dan DoQ untuk DNS queries\nProxy over QUIC untuk Web traffic (goodbye SNI leak, I guess?)\nDan tentu saja akan terus gue monitor untuk mengetahui mana aja yang miss.\nDi setup seperti ini gue rasa gue belum butuh full tunnel via VPN.\nPertama karena gue bisa kontrol secara penuh untuk mengatur DNS dan HTTP traffic dan yang kedua karena bisa gue kontrol, berarti gue bisa milih untuk pakai encrypted transport protocol hahaha.\nBeda ketika gue pakai routernya GL-inet yang memiliki spek yang minimum. Dia bisa enkripsi paket DNS (built-in support DoT via 1.1.1.1 nya Cloudflare dan NextDNS) tapi gak bisa buat tunnel HTTP packet melalui transport protocol yang aman.\nKalau gue lagi bekerja diluar rumah (fyi gue udah ~2 minggu gak keluar rumah, dan itu sebuah prestasi untuk gue haha) tentu gue akan pakai si router GL-inet karena portable dan juga tunnel ke VPN server gue selalu tersambung.\nJadi gue gak perlu cabut-pasang si router itu lagi ketika keluar rumah sambil membiarkan si raspi gak mendapatkan akses ke internet hahaha.\nBecause why not?\nBecause we can?\nAnything!\nSederhananya, apa yang bisa gue lihat adalah apa yang bisa dilihat oleh siapapun juga (ISP misalnya) dan gue tidak ingin siapapun tersebut mengetahui beberapa hal yang memang tidak ingin gue bagikan (seperti paket untuk DNS & HTTP/S misalnya).\nIt's fine ISP mengetahui gue berkomunikasi dengan [2001:470:ed00::420]:6969 melalui protokol QUIC, tapi untuk urusan kalau ISP tau gue mengakses pornhub.com, sorry, big no.\nMungkin gue berlebihan, atau tingkat insecurity gue adalah paranoid.\nTapi at least gue sudah mengetahui threat model gue, dan pendekatan yang gue lakukan adalah hal-hal yang harus gue pilih untuk threat model yang sudah gue pikirkan tersebut.\nDan yang terakhir sebagai penutup, I'm just having fun!","tags":"raspberrypi,jaringan","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-07-25T09:19:55","created_at":"2021-07-28T06:13:01.584549","updated_at":"2021-07-28T06:13:01.584549","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2823,"title":"Ngobrol Santai Ngebahas Lomba Cloud Computing SMK + Pengumuman Giveaway","url":"https://www.youtube.com/watch?v=GYUyAsASV_o","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-07-25T03:11:40","created_at":"2021-07-25T06:11:38.988033","updated_at":"2021-07-25T06:11:38.988033","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2833,"title":"Tentang menulis tulisan teknis","url":"https://www.evilfactorylabs.org/faultable/tentang-menulis-tulisan-teknis-18g5","body":"Halo,\nPerkenalkan gue @faultable\n dan di komunitas ini gue akan mencoba membantu untuk menuntun rekan komunitas sekalian untuk dapat berbagi pengetahuan dan pengalaman yang dimiliki, menggunakan media tulisan.\nKetika membuat tulisan tidak jarang ada pertanyaan \"Gue nulis tentang ini layak untuk dibagikan gak, ya? yang seringkali ditanyakan kepada diri sendiri (yang mungkin karena memiliki keraguan) dan jika misalnya gue boleh menjawab, jawabannya adalah: Hell yes.\nBerbagi adalah tentang \"pemindahan\" informasi dari pemberi ke penerima. Tugas paling berat dari berbagi adalah memastikan bahwa si penerima dapat menerima informasi dengan baik; jelas, dan yang paling penting: sesuai harapan.\nKabar buruknya, setiap orang memiliki cara menerima informasi yang berbeda-beda. Mungkin beberapa ada yang lebih suka dengan yang singkat-jelas-padat dan beberapa mungkin ke panjang-detail-mendasar. Namun kabar baiknya, kamu tidak perlu menganggap bahwa semua peserta adalah penontonmu, sebagaimana ketika menonton sebuah konser.\nNamun bagi yang baru memulai, bagian ini pun masih relatif sulit untuk dilewati. Banyak cara untuk menghadapinya, namun jika gue boleh memberikan saran: jadikanlah dirimu sebagai penonton VIP alias kamu menulis untuk dirimu sendiri yang mana memindahkan informasi dari yang ada dipikiranmu ke sebuah media dalam bentuk tulisan.\nKarena kamu yang paling mengetahui & mengerti dirimu sendiri dan dirimu yang lain sedang duduk menunggu pertujukanmu di kursi VIP, so, do your best.\nBaiklah, jika kamu sudah memiliki alasan mengapa ingin berbagi dalam bentuk tulisan dan sudah memiliki energi untuk melakukannya, luangkan waktu 5 menit kedepan terlebih dahulu untuk menghindari kehilangan arah karena gue ingin berbagi peta yang biasa gue gunakan ketika membuat sebuah tulisan.\nSederhananya, ini adalah tentang \"apa yang ingin lo bagikan?\" secara umum. Ingin menjelaskan Y dengan bahasa dan gayamu sendiri? Ingin membagikan pengalamanmu terkait X? Ingin memberikan pendapat terkait mengapa X dan bukan Y? \nGue ada 3 contoh tulisan yang pernah gue terbitkan di blog pribadi terkait 3 hal diatas:\nMenjadikan Raspberry Pi sebagai router, sudah banyak artikel di internet tentang membuat router menggunakan Raspberry Pi, dan gue ingin memastikan diri gue bahwa gue memahami konsep router secara high-level seperti dari DHCP sampai ke netfilter, menggunakan bahasa, gaya, dan tools yang cocok untuk gue sendiri\nApakah saya butuh CDN?, ini pun pastinya sudah banyak artikel yang membahas tentang ini di internet yang menggunakan judul yang cta-able yang diterbitkan oleh penyedia web hosting ataupun CDN (yang besar kemungkinan jawabannya adalah \"yes\"). Ditulisan tersebut, gue mencoba berbagi pengalaman secara netral sebagai seorang operator yang menjalankan layanan di internet.\nApa & Mengapa menggunakan Tailscale, ditulisan ini meskipun gue tidak menjelaskan secara eksplisit alternatif yang dibandingkan, setidaknya semoga dapat memberikan sedikit gambaran terkait adanya sebuah perbandingan.\nMenentukan maksud di awal dapat membantu kita (sebagai pemberi informasi) untuk tetap berada di konteks, seperti kita tidak perlu menjelaskan mengapa typeface di logo Nginx tidak menggunakan Helvetica ketika sedang berbagi tentang \"menangani 1000 permintaan per-detik menggunakan Nginx dan Blockchain\".\nJika kita sudah menentukan maksud dari apa yang ingin kita bagikan, let's move off.\nJudul memang penting, namun yang gue yakin, tidak sepenting itu.\nGue yakin pasti ada yang membaca tulisan ini sekalipun judulnya adalah HeLL0 w0Rld ¯\\(ツ)/¯ DCLXVI yang hanya tuhan dan @ri7nz\n yang mengerti maksudnya, anyway.\nMenentukan judul berarti kita memberikan gambaran secara singkat tentang pemeran utama yang ada. Apakah itu Nginx? Apakah itu TypeScript? Apakah itu GCP? Apakah itu HeLL0 w0Rld ¯\\(ツ)/¯ DCLXVI????\nSeringkali kita tertarik ketika melihat ada kata kunci yang ada di sebuah judul (citation needed, GFY HN readers!) seperti jika kita tertarik dengan Postgres, tulisan apapun selagi membahas tentang Postgres, kemungkinan besar akan kita kunjungi.\nDan gue secara pribadi sangat membenci judul yang bersifat click-bait sekaligus membenci judul yang terlihat membosankan. Seperti, daripada menentukan tulisan yang berjudul \"Membuat aplikasi Android menggunakan React Native\" gue lebih suka dengan judul \"Membuat dating app menggunakan Kotlin\".\nUmmm sorry maksud gue \"Membuat dating app menggunakan React Native\" ketika menjadikan \"React Native\" sebagai pemeran utama dan bukan si \"Android\" nya.\nSebagian orang percaya bahwa jika konten adalah raja maka judul adalah ratunya. Yes, but no. Gue termasuk orang yang percaya bahwa \"distribusi\" adalah ratunya, dan distribusi tidak selalu tentang SeaRcH eNginE OptiMization.\nSebagai kesimpulan, kamu bisa melewati terlebih dahulu penentuan judul ini ketika kamu sudah benar-benar mengetahui apa yang ingin kamu bagikan, sehingga kamu mungkin dapat menentukan judul yang 4 sehat 5 sempurna.\nNamun jika belum, kamu bisa menentukan judul sesuka hatimu saja. Masih ingat kan jika dirimu sendirilah si penonton spesial tersebut?\nGue tipe orang yang praktikal, dan tidak menempuh pendidikan formal terkait sastra. Dalam menulis, gue selalu memilih kata yang biasa gue gunakan di dunia nyata, dalam komunikasi verbal.\noke tapi dengan sedikit saringan sejujurnya karena mulut gue sedikit kotor\nGue secara pribadi dalam menggunakan bahasa, memilah kata, dan menentukan tanda baca, sejujurnya menggunakan prinsip sakumaha aing weh alias sesuka gue. Gue menggunakan bahasa yang benar-benar gue pahami, memilih kata yang benar-benar nyaman untuk gue, dan menentukan tanda baca yang sekiranya relevan sehingga gue bisa memberikan instruksi secara implisit kepada pembaca kapan harus terus melanjutkan dan kapan harus berhenti berharap dan mundur.\nKarena yang gue yakin, gue bukan sedang membuat paper ataupun menyusun tesis yang mungkin harus menggunakan EYD yang benar dan bahasa yang baik. Gue selalu menganggap bahwa berbagi dalam bentuk tulisan ini seperti sedang mengobrol dengan orang lain (atau diri sendiri lebih tepatnya) yang mana menggunakan bahasa sehari-hari yang mudah diterima & dimengerti.\nTentu ini bukanlah praktik terbaik, dan gue hanya memberikan sedikit pedoman.\nKarena kesempurnaan yang ada di dunia ini hanyalah ketidaksempurnaan (citation needed!!!).\nDalam konteks menulis, terkadang kita terbunuh oleh asumsi-asumsi yang salahsatunya menyebabkan tulisan tersebut hanya sampai di status draft. Entah sebuah perasaan bahwa tulisanmu kurang jelas, sebuah pemikiran bahwa tulisanmu terlalu singkat, sebuah bisikan bahwa topik pembahasanmu kurang menarik, apapun.\nMantranya untuk menepis asumsi-asumsi tersebut gue rasa satu: persetan.\nYang gue yakini, manusia selalu tumbuh; berkembang dan belajar. Dan juga, pasti pernah membuat sebuah kesalahan.\nAsumsi-asumsi yang ada dipikiran lo tersebut gue rasa hal yang wajar karena bukankah kita cenderung khawatir terhadap apapun yang bersifat ketidakpastian?\nKabar baiknya, sesuatu yang paling pasti di dunia ini hanyalah ketidakpastian, klo menurut orang random bernama Albert Einstein. Yang berarti, seharusnya tidak ada yang pasti di dunia ini.\nJadi, ya, persetan dengan asumsi. Kamu tidak perlu menjadi data-driven untuk menentukan hal yang ingin dibagikan dengan cara riset pasar; menganalisa semantik penulisan, ataupun mengalanisa terkait pemilihan topik yang ingin kamu bagikan.\nCukup bagikan. Setiap penampilan pasti memiliki penontonnya masing-masing.\nIni yang terakhir, just let it flow.\nDan yang paling penting, gue rasa, jangan jadikan aktivitas berbagi dalam bentuk tulisan ini menjadi aktivitas yang menyebalkan.\nJika dirasa seperti itu, mungkin bisa coba untuk dibiasakan dulu. Jika masih, mungkin tulisan bukanlah media yang cocok untukmu.\nSetiap kali gue menerbitkan tulisan, perasaan yang gue rasakan adalah bahagia, termasuk ketika masih dalam proses menulis tersebut.\nTidak jarang gue menyisipkan sedikit lelucon untuk lebih merenyahkan suasana yang gue yakini lelucon tersebut bersifat lucu (atau setidaknya lucu dalam pikiran sendiri, kalau mengutip dari sang pengamat @ervan0707\n).\nApapun yang terjadi, biarkanlah terus mengalir. Seiring berjalan waktu, gue yakin kita akan memiliki topik yang sangat antusias untuk kita bagikan; kita akan mendapatkan pembaca yang tertarik dengan tulisan kita (terlepas tentang apa yang kita tulis), mendapatkan \"suara dan nada\" yang cocok dengan personalitas kita, dan akan mendapatkan timbal balik terkait apa yang kita lakukan (dalam bentuk apapun itu).\nYang pasti, teruslah berpraktek. Berlatih. Berkembang.\nDan yang paling penting, harus membahagiakan~\nGue mohon maaf jika tulisan ini tidak membahas terkait \"menulis tulisan teknis\" sebagaimana yang dijanjikan di judul ini.\nNamun yang menariknya, mungkin kamu masih terus membaca bahkan sampai di paragraf ini.\nSekali lagi, gue masih yakin kalau judul memang penting, namun tidak sepenting itu. Maksud gue dalam menerbitkan tulisan ini adalah untuk merangkul pembaca untuk mulai membagikan apapun yang ingin dibagikan dalam bentuk tulisan, di situs ini.\nJika maksud gue tersebut ternyata tidak sampai ke pemikiran pembaca alias menjadi salah paham, please let me know dan bisa pertimbangkan untuk menyuarakannya di kolom komentar dibawah.\nDan jika ternyata tidak menjadi kesalahpahaman, give me some love by clicking on one of the available reactions on the side (atau bisa dengan menuliskan komentar juga!).\nJika ada yang ingin ditanyakan; memberikan kritik/saran, juga bisa suarakan dikolom komentar, oke?\nSebagai penutup, semoga tulisan ini bisa menjadi salah satu batu loncatan pertama kamu dalam aktivitas berbagi dalam bentuk tulisan.\nJadi, gimana? Udah siap berbagi, ya?","tags":"meta","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-07-24T16:42:08","created_at":"2021-07-28T06:13:01.584549","updated_at":"2021-07-28T06:13:01.584549","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2822,"title":"BELAJAR RESTFUL API (BAHASA INDONESIA)","url":"https://www.youtube.com/watch?v=9ed3b0tSRvI","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-07-24T05:00:04","created_at":"2021-07-24T06:11:54.423082","updated_at":"2021-07-24T06:11:54.423082","deleted_at":null,"source_id":61,"contributor":"pulodev"},{"id":2821,"title":"Pengumuman Giveaway + Ngomongin Apa Aja","url":"https://www.youtube.com/watch?v=NaIg02-6WjY","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-07-23T22:44:33","created_at":"2021-07-24T00:30:42.010488","updated_at":"2021-07-24T00:30:42.010488","deleted_at":null,"source_id":62,"contributor":"PuloDev"}],"total":1340}