{"data":[{"id":2948,"title":"Mengamankan Data User Dari Kebocoran Data Dengan Cloud KMS","url":"https://www.youtube.com/watch?v=LzTM-Y4v4Ek","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-11T22:30:59","created_at":"2021-09-10T00:56:41.502743","updated_at":"2021-09-10T00:56:41.502743","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2955,"title":"Filsafat Pemrograman","url":" https://sekolahkoding.com/artikel/filsafat-pemrograman ","body":"Jika sebelumnya kita berbicara tentang filsafat teknologi secara umum, namun kali ini kita sedikit berfilsafat tentang Pemrograman. Pemrograman adalah...","tags":"\n                bebas\n            ","media":"tulisan","thumbnail":null,"owner":" randynetworks ","draft":false,"original_published_at":"2021-09-11T17:50:54","created_at":"2021-09-11T12:24:08.653265","updated_at":"2021-09-11T12:24:08.653265","deleted_at":null,"source_id":49,"contributor":"sekolahkoding"},{"id":2954,"title":"APA ITU STACK OVERFLOW?","url":"https://www.youtube.com/watch?v=q1g2IUE4fa4","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-11T05:00:14","created_at":"2021-09-11T06:18:53.971384","updated_at":"2021-09-11T06:18:53.971384","deleted_at":null,"source_id":61,"contributor":"pulodev"},{"id":2953,"title":"Cerita Gagal dari Taufan Silitonga - Software Engineer ProEng by Cerita Gagal Bareng Sigit","url":"https://anchor.fm/cerita-gagal-bareng-sigit/episodes/Cerita-Gagal-dari-Taufan-Silitonga---Software-Engineer-ProEng-e16jsvi","body":"Taufan bercerita tentang rolenya sebagai Software Engineer ProEng di tech company di Indonesia. 00:01:13 Apa itu software engineer pro eng? 00:04:10 Komposisi team 00:10:00 Kegagalan ketika jadi software engineer 00:24:00 Pengalaman interview beserta kegagalannya 00:28:50 Pertanyaan tersulit saat interview 00:33:30 Pertanyaan interview confident untuk dijawab 00:42:00 Best practice ketika interview","tags":"interview, software engineer, tips interview, backend","media":"podcast","thumbnail":"https://d3t3ozftmdmh3i.cloudfront.net/production/podcast_uploaded_episode400/847206/847206-1630292799646-b3a6de526be29.jpg","owner":"Cerita Gagal Bareng Sigit","draft":false,"original_published_at":"2021-09-11T00:02:48.471","created_at":"2021-09-11T00:05:20.683238","updated_at":"2021-09-11T00:05:20.683238","deleted_at":null,"source_id":null,"contributor":"Cerita Gagal Bareng Sigit"},{"id":2952,"title":"Pengenalan Jaringan Komputer","url":"https://gadiskoding.my.id/pengenalan-jaringan-komputer.html","body":"Bagaimana sebuah komputer bisa berkomunikasi.","tags":"networking, jaringan, golang","media":"tulisan","thumbnail":"/images/og.png","owner":"Gadis Koding","draft":false,"original_published_at":"2021-09-10T17:00:13.513","created_at":"2021-09-10T17:00:39.210517","updated_at":"2021-09-10T17:00:39.210517","deleted_at":null,"source_id":null,"contributor":"Robocosan"},{"id":2949,"title":"Mengenal SonarQube Alat Untuk Cek Kualitas Program Secara Otomatis","url":"https://medium.com/warung-pintar/mengenal-sonarqube-alat-untuk-cek-kualitas-program-secara-otomatis-93236de1a1d5?source=rss----e0dc78032928---4","body":null,"tags":"kualitas-kode-program,sonarqube,tech,development,analis-kode-program","media":"tulisan","thumbnail":null,"owner":"Muhammad Syarif","draft":false,"original_published_at":"2021-09-10T05:43:17","created_at":"2021-09-10T06:19:11.027462","updated_at":"2021-09-10T06:19:11.027462","deleted_at":null,"source_id":23,"contributor":"pulodev"},{"id":2951,"title":"TUTORIAL DART DASAR (BAHASA INDONESIA)","url":"https://www.youtube.com/watch?v=-mzXdI27tyk","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-10T05:00:00","created_at":"2021-09-10T06:19:40.061057","updated_at":"2021-09-10T06:19:40.061057","deleted_at":null,"source_id":61,"contributor":"pulodev"},{"id":2945,"title":"Design Pattern: Command Pattern (Bahasa Indonesia) | CodingClass S1 ‚¶Å E10","url":"https://www.youtube.com/watch?v=VLLv54kan0c","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-10T03:16:08","created_at":"2021-09-09T00:55:15.018818","updated_at":"2021-09-09T00:55:15.018818","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2947,"title":"Upload Multiple File (Using Trait) For Your Laravel App","url":"https://syofyanzuhad.medium.com/upload-multiple-file-using-trait-for-your-laravel-app-2f84404492a7?source=rss-d7cef7a111e9------2","body":null,"tags":"multiple-upload,php,laravel,traits,upload","media":"tulisan","thumbnail":null,"owner":"Syofyan Zuhad","draft":false,"original_published_at":"2021-09-09T03:52:52","created_at":"2021-09-09T06:19:12.77399","updated_at":"2021-09-09T06:19:12.77399","deleted_at":null,"source_id":74,"contributor":"Syofyan Zuhad"},{"id":2946,"title":"Pattern Blur Image, memilih antara SVG atau PNG","url":"https://blog.cerita-faldi.xyz/pattern-blur-memilih-antara-svg-atau-png/","body":"Sebulan terakhir ini, saya mendapatkan salah satu pekerjaan untuk implementasi sebuah situs dengan desain yang memiliki banyak pattern blur. Pattern blur yang saya maksud itu kurang lebih seperti ini :\nPattern Blurred dari Mas Dimas\nKalau kita implementasi pattern seperti biasa, maka saya menggunakan format SVG untuk melakukan export pattern blur","tags":"CSS,Insight","media":"tulisan","thumbnail":null,"owner":"Faldi","draft":false,"original_published_at":"2021-09-08T23:09:23","created_at":"2021-09-09T00:55:33.760011","updated_at":"2021-09-09T00:55:33.760011","deleted_at":null,"source_id":15,"contributor":"naufaldi"},{"id":2944,"title":"Komposisi Fungsi dengan Elixir Pipe Operator","url":"https://www.youtube.com/watch?v=KorX6AraK4E","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-08T09:00:08","created_at":"2021-09-08T12:25:28.505588","updated_at":"2021-09-08T12:25:28.505588","deleted_at":null,"source_id":72,"contributor":"Riza Fahmi"},{"id":2943,"title":"Generate your Monika Configuration using HTTP Archive (HAR)","url":"https://medium.com/hyperjump-tech/generate-your-monika-configuration-using-http-archive-har-764944cbb9e6?source=rss----fabfd42372dc---4","body":null,"tags":"monitoring,http-archive,open-source,monika,software-development","media":"tulisan","thumbnail":null,"owner":"Denny Pradipta","draft":false,"original_published_at":"2021-09-08T01:48:52","created_at":"2021-09-08T06:19:21.235223","updated_at":"2021-09-08T06:19:21.235223","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2942,"title":"Eps. 58 - Secuil Cerita Belasan Tahun Menjadi Technical Leaderz","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--58---Secuil-Cerita-Belasan-Tahun-Menjadi-Technical-Leaderz-e16t977","body":"Didiet Noor, Head of Engineering Bukalapak, berbagi pengalamannya tentang naik turun dalam perjalanannya sebagai tech lead. Pengen denger tentang gimana caranya belajar mendelegasi tugas? Atau ingin tau caranya mengatur komposisi tim yang paling pas untuk mencapat tujuan bisnis? yuk simak!\nhttps://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-09-06T23:00:00","created_at":"2021-09-07T00:50:48.055451","updated_at":"2021-09-07T00:50:48.055451","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2940,"title":"Isolated Development Environment di Apple Silicon","url":"https://www.evilfactorylabs.org/faultable/isolated-development-environment-di-apple-silicon-518","body":"Sebagai pembuka, ini perlu banget gue nyebutin chip Apple Silicon (M1) karena jika menggunakan chip Intel harusnya enggak bakal seribet ini.\nSudah lama gue menggunakan remote server sebagai development environment utama gue mengingat spesifikasi PC gue (Intel NUC) sedikit sampah. Sistem operasi utama gue adalah GNU/Linux untuk kebutuhan web app development dan menggunakan Ubuntu karena varian ini yang paling terkenal (dan stabil) sejauh yang gue tau.\nSeperti kebanyakan pengembang lain, diri gue sebagai seorang pengembang perangkat lunak pun tidak hanya ketika dari jam 09 sampai 17 aja, di waktu luang ataupun akhir pekan gue terkadang mengembangkan aplikasi juga entah just for fun, pembelajaran, dsb.\nGue lumayan ketat dalam memasang dan menjalankan aplikasi yang ada di komputer gue. Gue rutin memeriksa aplikasi apa saja yang sedang berjalan, apa saja yang membuka koneksi, dan apa saja yang mengirim paket. Disamping itu, kebutuhan penggunaan komputer gue tidak sebatas untuk kepentingan pribadi, melainkan kepentingan pekerjaan juga baik pekerjaan utama ataupun sampingan iseng-iseng berhadiah.\nDi tahun 2021 gue berencana melakukan upgrade terhadap mesin tempur yang gue miliki. Sebenarnya tidak terlalu banyak perubahan, hanya core CPU yang sebelumnya 4 menjadi 8, dan arstektur yang tadinya Intel-based menjadi ARM-based jika membandingkan dengan MBA 2015 gue.\nThroughput nya? Sangat terasa. I/O speed mesin ini rata-rata nya adalah 2.3 GB/s, berbeda dengan yang sebelumnya (MBA dan NUC) yang hanya ~50% dari yang sekarang. Apple menjanjikan 3.5x peningkatan dalam CPU speed, dan sejujurnya gue kurang yakin apakah benar-benar peningkatan tersebut sebesar 3.5x karena yang gue rasakan hanyalah... cepat.\nKarena pertimbangan tersebut gue merasa mubazir bila laptop gue masih dipakai sebatas sebagai SSH client aja, dan juga gue bisa terbebas dari tagihan $22/bulan hanya untuk membuat remote devbox gue berjalan demi mendapatkan mesin dengan 2 vCPU, RAM 4GB, 80GB NVMe SSD, dan alamat IP publik cantik yang beralamat 143.198.198.198.\nTapi sekali lagi, gue tidak ingin mencampur berbagai kepentingan di satu tempat. Dan tentu saja membuat VM adalah jawabannya. Sayangnya, Multipass nya Canonical belum mendukung chip si Apple Silicon ini. Dan Vagrant belum mendukung native support Hypervisor.framework (via xhyve/bhyve) ataupun menggunakan HyperKit nya Docker.\nDan yang paling penting: Gue tidak ingin memasang Docker for Desktop ataupun Virtualbox nya Oracle, no matter what. Tapi kita memiliki Qemu, salah satu swiss army knife untuk virtualization dan emulation yang dibuat oleh lord Fabrice Bellard.\nTapi pengetahuan & pengalaman gue tidak se-dewa itu untuk bisa memahami & menghafal argument-argument penting yang ada di QEMU, dan juga bagian yang paling sulitnya adalah bagaimana membuatnya berjalan dengan baik dan benar.\nLalu gue menemukan UTM versi Mac nya yang gue rasa ini adalah versi GUI dari QEMU karena si UTM ini pada dasarnya menggunakan QEMU, under the hood.\nProses instalasinya mudah, drag-and-drop seperti biasa ke direktori /Application. Dan cara memulainya pun relatif mudah, mari kita membuat VM dengan sistem operasi Ubuntu Server yang menggunakan arsitektur ARM sebagai pembuka topik dari tulisan.\nPertama tentu saja unduh berkas optical disk image nya di halaman ini. \nBrengseknya terakhir gue cek belum ada berkas checksum yang disediakan untuk versi si ARM ini, jadi kita tidak bisa memastikan bahwa berkas yang kita unduh dengan berkas yang ada disediakan Canonical adalah berkas yang sama dan tidak rusak. But YOLO, download now.\nKedua, setting VM seperti biasa.\nBagian yang paling penting menurut gue adalah jenis hardware (di bagian System) yang akan di emulasi (pastikan memilih arsitektur arm64), jumlah memory yang ingin ditawarkan (umumnya 50% dari kapasitas yang asli), dan terakhir, seperti biasa, tambahkan 2 drive yang satu sebagai drive utama dan yang dua sebagai ephemeral drive untuk installer si Ubuntu Server kita.\n\nSisanya, boot dan jalankan proses instalasi seperti biasa. Semuanya harusnya akan berjalan out of the box.\nOke gue bisa aja memasang Postgres, Redis, Traefik, Python, Flask, Node.js, npm, dkk, clone repositori-repositori yang dibutuhkan, switch branch secara manual, dan getting up and running in hard way.\nTidak lupa juga menyesuaikannya dengan lingkungan yang ada, salah satu contohnya adalah mendefinisikan environment variables yang ada.\nDan mungkin tidak masalah selagi lingkungan tersebut sudah ter-isolasi dari lingkungan utama gue. Tapi gue males, dan eventually gue harus memasang docker agar seragam dengan setup yang ada di departemen engineering.\nDi sistem operasi non-linux, Docker (docker engine) bejalan didalam VM yang disebut \"docker machine\". Dan yang paling gue males, dia memakan sumber daya yang tidak sedikit, dan gue tidak peduli sekalipun RAM gue berkapasitas 10TB dengan 69-core CPU.\nKarena bagian instalasi Docker (di guest machine) tidak penting, jadi gue skip. Yang paling penting adalah bagaimana membuatnya dapat berkomunikasi dengan host OS (Mac).\nPort forward di UTM relatif gampang, dan sejujurnya gue masih heran kenapa Docker Desktop belum menawarkan port forward dari host ke container via GUI.\nAnyway, gue akan mendemonstrasikan bagaimana mem-forward port 80 di guest machine ke port 8080 di host machine. Via utm kurang lebih seperti ini:\n\nDan gue rasa sangat intuitif sekalipun ini hari pertama gue menggunakan UTM. Markicob?\n\nDi gambar diatas terlihat bahwa gue mengakses Nginx yang ada di guest OS (Ubuntu) di port 80 via port 8080 yang ada di host OS.\nDi bagian port forwarding ini juga bisa untuk melakukan SSH ke guest OS, karena sejauh yang gue tau si UTM ini belum bisa menggunakan bridged network yang mana tidak bisa berkomunikasi dengan jaringan yang ada di si guest machine begitupula sebaliknya.\nMari kita cek performance penalty yang ada di VM menggunakan bench.sh\n\nGue rasa ada penalti sekitar -40.59% bila dibandingkan dengan benchmark yang ada di host machine:\n\nDan gue rasa it doesn't matter jika melihat keluaran htop(1) yang dilakukan di host & guest machine dengan perintah htop -p $(ps aux | grep -i qemu-aarch64 | head | awk '{print $2}' dan di guest machine tanpa eksplisit membawa pid yang ingin di monitor:\n\nLook how wild Node.js is.\nPR utamanya adalah‚Äîkhususnya bila menggunakan Docker‚Äîharus memastikan bahwa Docker Image yang ingin digunakan dapat berjalan di arsitektur ARM (ARM64). Ini di pipeline CI bisa menggunakan docker/buildx ketika melakukan build, tapi besar kemungkinan aplikasi populer yang akan kita gunakan sudah mendukung untuk arsitektur arm64 ini.\nPR kedua adalah tidak (semoga setidaknya belum) bisa mengakses guest machine IP. Dan berarti mDNS pun tentu saja tidak bisa digunakan. Dan somehow ini bikin frustasi karena misalnya lebih mudah menghafal faultables-raspi.local daripada 192.168.8.69 sekalipun menggunakan static lease di dhcp.\nPR ketiga adalah port forwarding hell, thanks to PR kedua. Bayangkan jika ada 5 VM, bila setiap VM ingin meng-expose minimal 3 port, akan ada 20 port (plus SSH) yang harus gue forward dan hafal) dari guest ke host. Mungkin gue bisa setting reverse proxy untuk masalah ini, yang berarti setidaknya cuma ada 10 port (untuk 22 dan 80 di guest) yang harus gue forward, tapi tetap ini annoying & pain.\nPR terakhir adalah gue belum menemukan cara untuk menjalankan VM ini di background. Harusnya bisa dengan melakukan \"export QEMU command\" dan gue bikin simple script misal seperti vm delman start, yang mana delman adalah nama VM nya. Tapi idk, terlalu males buat nyoba.\nGue berjanji pada diri sendiri khusus untuk provision VM ini hanya untuk kasus jika development environment harus banget ada docker. Selebihnya gue akan mengusahakan dilakukannya di non-vm dan yang ada di radar gue sejak lama adalah menggunakan NixOS.\nDan juga gue akan mengusahakan untuk menggunakan OS yang mendukung arsitektur arm64 alih-alih harus meng-emulasi CPU ke x86 yang pastinya gue rasa akan memiliki penalti yang lebih besar.\nSebagai penutup, apakah gue puas dengan setup seperti ini? Tentu saja! Tidak memasang Docker Desktop dan VirtualBox adalah sebuah kemenangan untuk gue sekalipun dengan memasangnya pun tidak membunuh diri gue secara perlahan.\nJika gue sudah frustasi banget dengan membuat development environment Mac OS di proses ARM, mungkin gue akan mempertimbangkan menggunakan Asahi Linux dan mengucapkan sayonara untuk kesekian kalinya ke Mac OS (would be great kalau Pop!_OS mendukung arsitektur arm64 natively mengingat Ubuntu sudah mendukungnya juga).\nTerakhir, I'm just having fun! Tidak semua pengembang cocok membuat development environment nya ter-isolasi. Tapi jika kamu menggunakan rbenv, pyenv, venv, fnm, nodeenv, jails, lxc, dsb, harusnya kamu sudah mengetahui apakah kamu membutuhkan isolated development environment atau tidak üòâ","tags":"development,setup","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-09-04T21:43:35","created_at":"2021-09-05T00:55:13.174467","updated_at":"2021-09-05T00:55:13.174467","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2937,"title":"Untuk apa developer menulis?","url":" https://sekolahkoding.com/artikel/untuk-apa-developer-menulis ","body":"Untuk apa sih seorang developer belajar menulis? bukan menulis koding, tapi menulis biasa.\"Hmmm.. selama bisa menulis program.. untuk apa lagi belajar...","tags":"\n                menulis\n            ,\n                dokumentasi\n            ","media":"tulisan","thumbnail":null,"owner":" hilmanski ","draft":false,"original_published_at":"2021-09-04T16:46:18","created_at":"2021-09-04T12:24:07.91864","updated_at":"2021-09-04T12:24:07.91864","deleted_at":null,"source_id":49,"contributor":"sekolahkoding"},{"id":2939,"title":"Mengenal Continuous Integration (CI) untuk pengembang","url":"https://www.evilfactorylabs.org/faultable/mengenal-continuous-integration-ci-untuk-pengembang-4lg3","body":"Sebagai seorang pengembang, pekerjaan utama kita besar kemungkinan adalah menulis kode, yang mana akan menghasilkan sebuah aplikasi. Aktivitas penulisan kode tersebut tidak jarang dilakukan bersama dalam bentuk tim yang terdiri dari berbagai sub-grup dan atau anggota yang ahli dalam bidangnya masing-masing.\nUntuk membuat kode yang ditulis oleh pengembang \"berguna\", maka kode tersebut harus dapat berjalan. Namun ada yang lebih penting daripada hanya membuatnya berjalan saja, yakni membuatnya berjalan dan sesuai fungsi juga.\nYang menarik dari aktivitas pengembangan aplikasi ini adalah kode yang ditulis bisa dilakukan bersama, secara paralel. Mungkin bisa bayangkan seperti membuat sebuah novel yang mana setiap bab nya ditulis oleh penulis yang berbeda, secara paralel.\nYang menjadi pertanyaan adalah: bagaimana memastikan bahwa \"plot\" yang ditulis sesuai dengan keseluruhan \"cerita\" yang diharapkan?\nPertanyaan yang tidak kalah penting lagi adalah: bagaimana memastikan bahwa keseluruhan cerita ditulis seperti oleh satu orang?\nDan yang paling penting: bagaimana plot yang ditulis tidak merusak plot lain yang ditulis oleh penulis berbeda?\nSilahkan ganti kata \"plot\" diatas dengan \"fitur\".\nProses Code review ini sudah umum dilakukan di organisasi pengembang. Jika belum familiar dengan code review, mungkin memiliki pertanyaan seperti: Mengapa kode yang gue tulis ditinjau lagi, sedangkan gue pastinya menulis kode yang berjalan?.\nKarena code review, sekali lagi, adalah tentang code review. Ini bukan hanya tentang memastikan kode yang ditulis berjalan, melainkan untuk memastikan bahwa kode yang ditulis sesuai dengan pedoman; konvensi, dan kualitas yang dimiliki organisasi tersebut.\nDan yang tidak kalah penting adalah tentang pemindahan informasi. Tentang membuat tim yang terlibat tetap singkron dengan perubahan yang terjadi. Juga tentang saling belajar cara berpikir dari pengembang yang berbeda-beda.\nUmumnya untuk memastikan bahwa kode yang ditulis berjalan adalah dengan melakukan proses \"build\", jika melewati fase ini, bisa dipastikan kode yang ditulis memang berjalan dan tidak memiliki kesalahan yang membuat aplikasi tersebut gagal dibuat.\nSetelah itu, proses yang dilakukan adalah \"test\". Di fase ini, kita memastikan bahwa kode berjalan sesuai harapan yang mana salah satu harapannya adalah tidak merusak fungsi lain yang sudah/ditulis oleh pengembang lain.\nApa saja yang diuji? Tergantung. Bisa menguji fungsionalitas per-unit, menguji ketika unit-unit tersebut \"berkomunikasi\" dengan unit lain ataupun berbeda, sampai ke pengujian ketika unit-unit tersebut digabungkan menjadi satu-kesatuan. Misal, seperti cerita \"Mengirim surel konfirmasi kata sandi ketika pengguna lupa kata sandinya\". Yang pertama kita uji tentu adalah fungsi mengirim surel beserta konten yang ada, yang dilanjutkan dengan kondisi ketika menggunakan komponen eksternal (seperti protokol SMTP misalnya), yang diakhiri misal dengan alur dari klik tombol \"Forgot password\", mengisi alamat surel, dan mendapatkan surel yang diharapkan.\nTapi mengembangkan aplikasi tidak hanya tentang memedulikan siapa yang menggunakannya saja. Memedulikan pengembangnya juga tidak kalah penting selain demi menjaga kewarasan juga bisa membantu untuk membuat pengembang tersebut menjadi lebih produktif dan bergerak cepat. Seperti, keluhan-keluhan tentang \"legacy code\" sudah menjadi rahasia umum di kalangan pengembang, terlepas berada di organisasi manapun itu.\nLegacy code ini sebenarnya tidak selalu buruk, dan menariknya keluhan tentang legacy code ini memiliki pola. Pengembang relatif akan mengeluhkan legacy code, jika mereka menemukan kode yang sudah ada ditulis:\nRibet/sulit dipahami\nTidak konsisten\nTidak rapih/berpola\nTidak singkron dengan kondisi pada saat ini\nDan hampir jarang‚Äîatau mungkin main gue kurang jauh‚Äîpengembang mengeluhkan \"legacy code\" bila kode yang sudah ada:\nMudah dipahami\nKonsisten\nRapih & berpola\nSingkron dengan kondisi pada saat ini\nSetuju?\nNah, untuk dapat membuat kode yang ada memenuhi poin-poin diatas, organisasi setidaknya harus memiliki pedoman; konvensi, dan kualitas terkait kode yang harus ditulis oleh pengembang.\nNamun yang paling berat bukanlah di pembuatan & penentuan standar terkait pedoman; konvensi, dan kualitas kode tersebut, melainkan di bagaimana memastikan pengembang mengikuti standar tersebut..\nDan proses pemastiannya, selain bukan tanggung jawab utama dari seorang pengembang juga adalah pekerjaan yang sangat membosankan.\n...kecuali?\nKebanyakan para pengembang adalah pribadi yang malas dan (tidak jarang) mudah bosan juga, mereka akan mencari cara untuk mengatasi kemalasan dan kebosanan mereka tanpa mengorbankan esensi utama yang ada.\nJika tidak setuju, silahkan jawab mengapa kamu menulis test alih-alih mengujinya dengan tangan sendiri untuk memastikan kode yang kamu tulis berjalan dan juga tidak merusak kode yang lain?\nSadar-tidak sadar, pengembang berusaha sekeras mungkin untuk menggunakan solusi yang \"otomatis\" daripada \"dengan tangan\". Dari sesederhana menggunakan package manager daripada mengunduh berkas arsip dan mengekstraksinya sendiri sampai ke pembuatan \"jalan pintas\" untuk membuat Makefile dan mengetik make daripada gcc -std=gnu99 -Wall -O2 -I\"./include\" build/x86/obj/*.o build/x86/obj/entry/main.o -o build/x86/bin/app -lpthread untuk membuat kode yang ditulis menjadi sebuah aplikasi.\nJika otomatisasi ini bisa membantu membuat pekerjaan pengembang per-individu menjadi lebih mudah, bukankah seharusnya bisa membuat pekerjaan pengembang dalam konteks kelompok menjadi lebih mudah juga?\nDan ditulisan ini, kita akan membahas itu.\nTentang Continuous Integration.\nTentang menemukan bug lebih cepat, meningkatkan kualitas program, dan tentang mengurangi waktu dalam memvalidasi dan merilis pembaruan.\nSecara otomatis.\nKomponen utama dari praktik CI ini adalah CI Platform itu sendiri. Karena, pada dasarnya, CI hanyalah sebuah proses yang biasa pengembang lakukan, di mesinnya, secara manual.\nDalam praktik CI, umumnya ada 2 fase yang harus dilewati untuk mewujudkan tujuan yang ingin dicapai:\nBuild\nTest\nAlurnya, sederhananya adalah seperti ini:\nPengembang membuat perubahan\nPerubahan tersebut diunggah ke repository bersama\nCI Platform akan melakukan \"build\" dan \"test\"\nJika 2 fase diatas berhasil dilewati, maka perubahan siap untuk digabungkan ke kode utama\nYang berarti, jika menerapkan praktik CI, setiap perubahan yang dibuat seharusnya hanya boleh digabungkan ke kode utama jika semua fase yang ada di platform CI sudah terlewati.\nApa yang dilakukan ketika build? Apa yang dilakukan ketika test? Sekali lagi, tergantung. Jika untuk menjalankan aplikasi tersebut pengembang harus:\nMenggunakan sistem operasi GNU/Linux, Windows dan *BSD.\nMemasang sqlite3, Node.js LTS, dan npm\nMemasang dependensi yang dibutuhkan dengan npm install\nMemastikan ukuran direktori dist kurang dari 10 MB\nMaka pengembang harus menjelaskan langkah-langkah diatas ke platform CI untuk fase \"build\" tersebut.\nBagaimana cara pengembang menjelaskannya ke platform CI? Biasanya setiap platform CI memiliki sebuah berkas khusus yang ditulis menggunakan format tertentu yang mana berkas tersebut bisa dianggap sebagai \"berkas konfigurasi pipeline\".\n...pipeline sederhananya hanyalah kumpulan langkah-langkah yang mana sebelumnya gue sebut sebagai \"fase\". Jika gue berbicara tentang pipeline, bisa diasumsikan gue sedang membicarakan tentang proses dari build-test.\nAnggap aplikasimu ingin berjalan di 2 sistem operasi: GNU/Linux dan Windows.\nSelain itu, aplikasimu bergantung dengan 2 program yang berada di level OS, yakni: imagemagick dan ffmpeg.\nDan persyaratan utama untuk bisa menjalankan programmu adalah:\nMenggunakan Node.js versi LTS\nMenggunakan arsitektur x86\nKapasitas RAM setidaknya 4GB\nDengan sudah mendefinisikan 3 hal diatas, setidaknya pengembang dan atau operator sudah mengetahui limitasi ada dan bisa mengurangi kemungkinan masalah unknown-unknown yang akan terjadi.\nSebagai contoh, disini kita akan menggunakan platform CI dari Gitlab yang bernama Gitlab CI. Dan berdasarkan kondisi diatas, fase build yang akan kita miliki kurang lebih seperti ini:\nstages:\n  - build\n\n.build:\n  script:\n    - npm ci\n    - npm run build\n\nbuild:windows:\n  stage: build\n  extends:\n    - .build\n  tags:\n    - windows\n  before_script:\n    - # download & install imagemagick\n    - # download & install ffmpeg\n    - # download & install node.js lts & npm\n\nbuild:linux:\n  image: ubuntu:focal\n  stage: build\n  extends:\n    - .build\n  before_script:\n    - # download & install imagemagick\n    - # download & install ffmpeg\n    - # download & install node.js lts & npm\n\nNah kunci utama dari fase dianggap sukses atau gagal adalah di exit code. Setiap program pasti memiliki exit code setiap kali dijalankan, misal, ketika kita (atau CI server) menjalankan npm run build, jika program npm berhasil menyelesaikan tugasnya, (run build) maka exit code nya 0, jika gagal, exit code nya pasti bukan 0 tergantung alasan error nya.\nMengapa fase \"build\" ini penting? Bayangkan jika pengembang harus melakukan build manual di mesinnya sendiri setiap kali pengembang lain membuat perubahan ketika melakukan code review, malesin banget gak, sih?\nSelain itu juga, fase ini bisa menghindari masalah klasik \"It works on my machine\" karena pengembang harus mendefinisikan secara eksplisit apa saja yang dibutuhkan dan apa saja yang harus dilakukan.\nDi fase ini semakin menarik. Terlebih platform CI terkadang bukan hanya menguji kode yang pengembang tulis, melainkan menguji kewarasan kita sebagai pengembang juga, iykyk.\nJenis test yang ada pun cukup beragam, tergantung seberapa luas cakupan yang ingin kita uji. Umumnya ada 3 jenis test yang biasa ditulis oleh pengembang:\nUnit test\nIntegration testing\nEnd-to-end test\nUntuk pertanyaan \"Test apa yang harus ditulis, dan kapan harus menulis Unit/Integration/E2E test?\" jawabannya ada di manager kalian atau siapapun itu yang bertanggung jawab.\nDi fase test ini tidak hanya sebatas menguji fungsionalitas dari kode yang ada, melainkan bisa juga melakukan pengujian-pengujian lain seperti:\nKonvensi\nKualitas\nKeamanan\nLisensi\nDsb\nDan akan lebih menarik lagi jika si \"penguji\" tersebut bisa membetulkan sendiri apa yang dia anggap salah, secara otomatis. Bukan hanya sebatas memberikan informasi lalu membuat pipeline tersebut gagal :))\nDengan sudah mendefinisikan jenis test berikut dengan skenarionya, setidaknya pengembang dapat memastikan bahwa perubahan yang dia buat dapat berjalan sehingga salah satunya bisa tidak membuat hidup operator menjadi lebih sulit dalam menentukan letak keberadaan kesalahan yang ada.\nSebagai contoh, disini kita akan menggunakan Gitlab CI lagi. Dan kurang lebih seperti ini untuk mendefinisikan fase test untuk aplikasi kita:\nstages:\n  - test\n\n.test:\n  script:\n    - npm run lint\n    - npm run check-deps\n    - npm run test\n\ntest:windows:\n  stage: test\n  extends:\n    - .build\n    - .test\n  tags:\n    - windows\n\ntest:linux:\n  image: ubuntu:focal\n  stage: test\n  extends:\n    - .build\n    - .test\n\nYang perlu dicatat juga bahwa kita harusnya menguji kode dari hasil build yang kita lakukan di fase sebelumnya. Untuk mencapainya, kita bisa melakukan build lagi (yang tentu saja tidak efektif) lalu test, atau bisa menggunakan pendekatan \"menggunakan artifact\" yang salah satu contohnya berarti di fase test ini, untuk kasus yang menggunakan Node.js, node_modules dan direktori dist diambil dari fase build sebelumnya.\nMengapa fase \"test\" ini penting? Karena sekali lagi, bayangkan jika pengembang harus menjalankan test manual apalagi harus melakukan test manual di mesinnya sendiri setiap kali pengembang lain membuat perubahan ketika melakukan code review, mending resign gak, sih?\nTujuan menulis test pada umumnya untuk membuat pengembang lebih percaya diri ketika membuat perubahan. Meskipun terkadang gue berpikir bahwa menulis test adalah aktivitas yang membuang-buang waktu, jika mengambil sisi positifnya ini membantu:\nAnggota baru untuk mempelajari & memahami aplikasi\nMengetahui known-issue yang ada\nMemprediksi kemungkinan edge cases\nDan yang paling penting: memastikan bahwa perubahan yang dibuat tidak merusak fungsionalitas yang sudah ada, which is nice, right?\nJika fase build & test berhasil, apa lagi yang bisa membuat ragu bahwa perubahan yang kita‚Äîsebagai pengembang‚Äîbuat itu sudah berjalan dan sesuai fungsi sehingga perubahan bisa menjadi lebih cepat dapat digabungkan ke kode utama?\nBerbicara tentang Continuous Integration tentu terasa kurang bila tidak menyinggung tentang Continuous Delivery juga. Continuous Delivery ini sederhanannya adalah jawab akan \"What's next?\" setelah perubahan berhasil digabungkan ke kode utama.\nSetiap organisasi memiliki pendekatan yang beragam dalam mendistribusikan \"artifact\" atau hasil proses build tersebut. Umumnya artifact tersebut berbentuk:\nBerkas arsip, seperti .tar, .zip ataupun sebuah docker image\nBerkas paket, seperti .apk, .deb, dsb.\nJika kita mengambil konteks aplikasi untuk front-end web, besar kemungkinan artifact tersebut adalah sebuah berkas arsip yang berisi direktori node_modules dan dist.\nDan, ya, OCI compliant image seperti Docker Image pun pada dasarnya adalah sebuah berkas arsip.\nHal yang dilakukan di fase release ini pada dasarnya hanya satu: melakukan rilis, dan hal paling sederhana yang dilakukan adalah melakukan \"tagging\" dan menyimpan sesuatu yang sudah di tag tersebut ke sesuatu bernama \"package registry\" ataupun \"artifact repository\" tergantung buzzword mana yang ingin kamu gunakan.\nTagging di versi rilis ini umumnya berisi kumpulan-kumpulan perubahan yang besar pada sebuah aplikasi, bukan hanya sebatas 1 perubahan besar. Dan biasanya digambarkan dengan pemilihan nomor versi.\nAlurnya biasanya seperti ini:\nPengembang menentukan versi X ingin berisi perubahan apa saja yang dilanjutkan dengan membuat Pull/Merge Request\nPull/Merge Request tersebut menggambarkan versi yang akan dirilis, baik menggunakan nama cabang ataupun tag\nPipeline berjalan seperti biasa untuk (P/M)R tersebut.\nJika pipeline berhasil, lakukan tagging dan unggah artifact yang ada ke somewhere\n...yang tentu saja langkah nomor 4 berjalan secara otomatis :))\nMisal, artifact untuk aplikasi kita adalah sebuah Docker image. Kurang lebih kita bisa menggunakan pendekatan seperti ini misalnya:\nstages:\n  - release\n\nrelease:\n  stage: release\n  only:\n    refs:\n      - /^release\\/.*/\n  script:\n    - docker build -f ./release.dockerfile -t $BASE_IMAGE:$CURRENT_TAG .\n    - docker push $BASE_IMAGE:$CURRENT_TAG\n\nMengapa fase \"release\" ini penting? Entahlah, karena males?\nBayangkan harus menjalankan 2 perintah diatas yang besar kemungkinan memakan waktu & sumber daya yang tidak sedikit bila menggunakan mesin sendiri dan secara manual.\nDi tulisan ini gue mencoba untuk berbagi seputar Continuous Integration (CI) dari sudut pandang pengembang. Tantangan dari praktik CI ini sejauh yang gue tahu adalah kurangnya pemahaman terkait apa yang ingin didefinisikan di setiap fase yang ada.\nYang mana jawaban singkatnya adalah: Hal-hal yang kamu lakukan di mesinmu sendiri untuk menjalankan tugas X, itulah yang dilakukan di CI pipeline juga. Bedanya, tugas-tugas tersebut didefinisikan secara deklaratif.\nGue tidak bisa berbicara benefit praktik CI ini dari perspektif bisnis, tapi kalau dari sisi pengembang, jika lo males:\nMemastikan perubahan terkait kode yang ditulis memenuhi standar penulisan\nMemastikan bahwa perubahan tersebut berjalan sesuai kebutuhan, spesifikasi, dan kasus\nMemastikan bahwa perubahan tersebut tidak merusak fungsi yang sudah ada\nMelakukan rilis\n...secara manual, besar kemungkinan organisasi lo harus menggunakan sistem CI!\nSebagai penutup, otomatisasi bukanlah solusi untuk setiap masalah, pasti masih harus ada sentuhan tangan manusia, karena benefitnya adalah untuk membantu dan bukan untuk mengganti. \nJika organisasimu belum menerapkan sistem CI dan kamu belum terlalu berani untuk mengusulkannya, mungkin bisa mempertimbangkan untuk membagikan tulisan ini ke organisasimu?\nSemoga tulisan ini mencerahkan & berguna, jika terdapat salah paham; konsep, penulisan atau apapun itu, tolong bisa diutarakan di kolom komentar dibawah.\nThank you!","tags":"devops","media":"tulisan","thumbnail":null,"owner":"Rizaldy","draft":false,"original_published_at":"2021-09-04T14:26:26","created_at":"2021-09-04T18:18:22.871978","updated_at":"2021-09-04T18:18:22.871978","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2920,"title":"Design Pattern: Strategy Pattern (Bahasa Indonesia) | CodingClass S1 ‚¶Å E9","url":"https://www.youtube.com/watch?v=-H74s-aTMrU","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-04T03:33:39","created_at":"2021-09-02T12:25:10.385763","updated_at":"2021-09-02T12:25:10.385763","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2922,"title":"Eps. 57 - Empowering Youth Through Informal Education","url":"https://anchor.fm/ngobrolinstartup/episodes/Eps--57---Empowering-Youth-Through-Informal-Education-e16r6jo","body":"CEO Global Millennial Group, Fikri, kali ini ngobrol tentang bagaimana dia berkontribusi untuk ikut ikut mengembangkan para pemuda melalui pendidikan formal. Yuk simak!\nhttps://anchor.fm/ngobrolinstartup/support","tags":"","media":"podcast","thumbnail":null,"owner":"Imre Nagi","draft":false,"original_published_at":"2021-09-03T06:59:27","created_at":"2021-09-03T12:25:51.319821","updated_at":"2021-09-03T12:25:51.319821","deleted_at":null,"source_id":30,"contributor":"imrenagi"},{"id":2921,"title":"Evan Purnama, Jatuh Bangun Bersama Qiscus","url":"https://anchor.fm/ceritanya-developer/episodes/Evan-Purnama--Jatuh-Bangun-Bersama-Qiscus-e16rhd3","body":"Sebagai co-founder, kita dituntut untuk bisa mengembangkan startup yang kita bangun agar bisa terus tumbuh dan mendapatkan revenue. Hal ini membutuhkan kemampuan leadership yang harus terus dilatih.\n\n\"Untuk mengasah kemampuan ini kita harus melatih zoom in dan zoom out. Kita harus melihat secara luas sebetulnya produk kita itu bagaimana dan arahnya mau kemana. Tapi di sisi lain kita harus bisa zoom in sampai bisa melacak errornya di mana dan nyambung di servis apa,\" ujar Co-founder sekaligus CTO Qiscus.\n\nPenasaran mengenai jatuh bangunnya Evan Purnama dalam membangun Qiscus. Dengerin ceritanya developer sampai tuntas karena akan ada info hiring di akhir episode.","tags":"","media":"podcast","thumbnail":null,"owner":"Riza Fahmi","draft":false,"original_published_at":"2021-09-03T03:14:36","created_at":"2021-09-03T06:19:20.929112","updated_at":"2021-09-03T06:19:20.929112","deleted_at":null,"source_id":3,"contributor":"rizafahmi"},{"id":2941,"title":"Cara Saya Belajar Pemrograman","url":"https://rahmatagungjulians.tech//blog/cara-saya-belajar-pemrograman","body":"Saya ingin membagikan metode belajar pemrograman yang Saya gunakan untuk mempelajari hal baru dan menambah pengetahuan.","tags":"sharing","media":"web","thumbnail":null,"owner":"rahmatagungj@gmail.com (Rahmat Agung Julians)","draft":false,"original_published_at":"2021-09-03T00:00:00","created_at":"2021-09-06T18:18:44.654348","updated_at":"2021-09-06T18:18:44.654348","deleted_at":null,"source_id":73,"contributor":"Rahmat Agung Julians"},{"id":2919,"title":"Cara membuat dependency dropdown wilayah Indonesia dengan Laravel, jQuery, Laravolt","url":"https://syofyanzuhad.medium.com/cara-membuat-select-wilayah-indonesia-dengan-ketergantungan-laravel-jquery-laravolt-96524cce3d81?source=rss-d7cef7a111e9------2","body":null,"tags":"laravolt,laravolt-indonesia,laravel,wilayah-indonesia,select","media":"tulisan","thumbnail":null,"owner":"Syofyan Zuhad","draft":false,"original_published_at":"2021-09-02T07:54:57","created_at":"2021-09-02T12:25:08.976577","updated_at":"2021-09-02T12:25:08.976577","deleted_at":null,"source_id":74,"contributor":"Syofyan Zuhad"},{"id":2916,"title":"Deploy Website dengan AWS Amplify #CloudJam","url":"https://www.youtube.com/watch?v=eQ6PoJtivZw","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-09-01T03:53:40","created_at":"2021-08-31T12:25:19.482755","updated_at":"2021-08-31T12:25:19.482755","deleted_at":null,"source_id":62,"contributor":"PuloDev"},{"id":2917,"title":"Use Existing Postman Collections with Monika: An Alternative Solution to Postman Monitoring","url":"https://medium.com/hyperjump-tech/use-existing-postman-collections-with-monika-an-alternative-solution-to-postman-monitoring-770572eedb2c?source=rss----fabfd42372dc---4","body":null,"tags":"monitoring,postman-collections,postman,monika,synthetic-monitoring","media":"tulisan","thumbnail":null,"owner":"Denny Pradipta","draft":false,"original_published_at":"2021-08-31T11:06:39","created_at":"2021-08-31T12:25:46.919367","updated_at":"2021-08-31T12:25:46.919367","deleted_at":null,"source_id":46,"contributor":"2co_p"},{"id":2911,"title":"[mks.py] Python Continuous Integration With Github Action","url":"https://www.youtube.com/watch?v=D2da7lMS7wE","body":null,"tags":"","media":"video","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-28T18:31:44","created_at":"2021-08-28T06:18:38.794842","updated_at":"2021-08-28T06:18:38.794842","deleted_at":null,"source_id":28,"contributor":"oon"},{"id":2914,"title":"Automate Resizing Bulk Images Using Libvips","url":"https://www.evilfactorylabs.org/fahmifan/automate-resizing-bulk-images-using-libvips-54a5","body":"Original post: fahmifan.id/blog/automate-resizing-bulk-images-using-libvips\nWith the growing popularity of ShopeeFood, many restaurants were applying for partnership with them, included my relative's Padang restaurant. But, their registration was not easy. They need a photo for each menu to be in a format of 720x720 px. For a Padang restaurant with over 50 menus and unfortunately the restaurant's menu photos were in different sizes.  \nI was too lazy to resized them manually. At first, I search for a service that could resize an image. But they weren't able to resize so many images at once. So I thought to write a program to automate this.\nbimg.\nThe code was pretty simple, we only need to iterate all of the photos in a directory. Then, for each of photo, resize it into 720x720 px. But, because the photos are not all squares, we can't use the Resize method instead, we use ResizeAndCrop that will resize the photos into 720x720 px and crop it fill to center\nimport (\n    \"fmt\"\n    \"path\"\n\n    \"github.com/h2non/bimg\"\n)\n\nvar root = \"/menu-photos\"\nvar outdir = \"/menu-photos/720x720\"\n\nfunc resize(filepath, filename string) error {\n    buf, err := bimg.Read(filepath)\n    if err != nil {\n        return err\n    }\n\n    img := bimg.NewImage(buf)\n    size, err := img.Size()\n    if err != nil {\n        return err\n    }\n\n    newImage, err := img.ResizeAndCrop(720, 720)\n    if err != nil {\n        return err\n    }\n\n    size, err = bimg.NewImage(newImage).Size()\n    if err != nil {\n        return err\n    }\n\n    if size.Width != 720 || size.Height != 720 {\n        fmt.Printf(\"wrong size: '%s' %vx%v\\n\", filename, size.Width, size.Height)\n    }\n\n    fmt.Printf(\"resize & crop: %s\\n\", filename)\n    return bimg.Write(path.Join(outdir, filename), newImage)\n}\n\nTo make the code faster, we can utilized goroutine. Here i spawned 4 goroutine that resize the images concurently.\ntype resizeJob struct {\n    FilePath string\n    FileName string\n}\n\nfunc main() {\n    jobChan := make(chan resizeJob, 4)\n\n    wg := &sync.WaitGroup{}\n    nworker := 4\n    // spawn workers\n    for i := 0; i < nworker; i++ {\n        wg.Add(1)\n        go worker(wg, jobChan)\n    }\n\n    err := filepath.Walk(root, func(path string, info fs.FileInfo, err error) error {\n        if info.IsDir() {\n            return nil\n        }\n        // enqueue jobs\n        jobChan <- resizeJob{FilePath: path, FileName: info.Name()}\n        return nil\n    })\n    close(jobChan)\n    if err != nil {\n        fmt.Fprintln(os.Stderr, err.Error())\n        return\n    }\n\n    // wait for workers to finished\n    wg.Wait()\n    fmt.Println(\"done\")\n}\n\nfunc worker(wg *sync.WaitGroup, jobChan chan resizeJob) {\n    defer wg.Done()\n    for file := range jobChan {\n        err := resize(file.FilePath, file.FileName)\n        if err != nil {\n            fmt.Fprintln(os.Stderr, err.Error())\n        }\n    }\n}\n\nCredits\nAng√®le Kamp on Unsplash","tags":"livips,go,resize,image","media":"tulisan","thumbnail":null,"owner":"Fahmi Irfan","draft":false,"original_published_at":"2021-08-28T13:44:56","created_at":"2021-08-28T18:18:15.990317","updated_at":"2021-08-28T18:18:15.990317","deleted_at":null,"source_id":70,"contributor":"evilfactorylabs"},{"id":2912,"title":"#14: Ahmad Riza - Berkenalan Dengan Pemrogram Di Industri Minyak Bumi","url":"https://ujung.ee/eps-14-ahmad-riza-pemrogram-industri-perminyakan/","body":"Di episode ke-14, kali ini kami akan membahas soal pekerjaan pemrogram di industri yang nampak membosankan: industri perminyakan. Eits, tapi jangan salah, walaupun kesannya membosankan tapi ternyata pekerjaan pemrogram di sana seru lho. Tamu kami kali ini namanya Ahmad Riza, berkarir sebagai pemrogram di industri perminyakan sepanjang hidupnya. Semoga membuka wawasan baru untuk para pendengar Ujung ke Ujung.","tags":"","media":"podcast","thumbnail":null,"owner":"","draft":false,"original_published_at":"2021-08-28T10:00:00","created_at":"2021-08-28T06:18:45.194466","updated_at":"2021-08-28T06:18:45.194466","deleted_at":null,"source_id":24,"contributor":"naufaldi"}],"total":1425}